{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-03-05T22:59:36.024804+00:00",
  "repo": "quicwg/load-balancers",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "editorial",
      "description": "",
      "color": "fc94f8"
    },
    {
      "name": "needs-discussion",
      "description": "",
      "color": "32d5db"
    },
    {
      "name": "Parked",
      "description": "",
      "color": "D03AB5"
    }
  ],
  "issues": [
    {
      "number": 6,
      "id": "MDU6SXNzdWU1NzM2MjA2NDE=",
      "title": "Setup CI",
      "url": "https://github.com/quicwg/load-balancers/issues/6",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The editor's draft and the `gh-pages` branch are currently empty.",
      "createdAt": "2020-03-01T21:40:15Z",
      "updatedAt": "2020-03-06T18:58:20Z",
      "closedAt": "2020-03-06T18:58:20Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe this is resolved.",
          "createdAt": "2020-03-06T18:58:16Z",
          "updatedAt": "2020-03-06T18:58:16Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "MDU6SXNzdWU1NzM2MjEwNzk=",
      "title": "SCID acronym",
      "url": "https://github.com/quicwg/load-balancers/issues/7",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This is often used to mean Source Connection ID in other contexts.  A collision here is likely to cause confusion.",
      "createdAt": "2020-03-01T21:43:26Z",
      "updatedAt": "2020-06-16T22:00:22Z",
      "closedAt": "2020-06-16T22:00:22Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Recommended name? SCCID?",
          "createdAt": "2020-03-06T20:57:02Z",
          "updatedAt": "2020-03-06T20:57:02Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "I think it might just be best to call it the \"Server CID\" any other abbreviated term will get confused IMO.",
          "createdAt": "2020-03-06T23:12:10Z",
          "updatedAt": "2020-03-06T23:12:10Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\"Server CID\" doesn't seem to fit well with \"Stream Cipher Connection ID\"",
          "createdAt": "2020-03-09T15:21:30Z",
          "updatedAt": "2020-03-09T15:21:40Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "So SCID didn't mean \"Server Connection ID\"? There is definitely confusion here. I'd just recommend not abbreviating anything more than CID.",
          "createdAt": "2020-03-09T15:33:47Z",
          "updatedAt": "2020-03-09T15:33:47Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I guess this proves MT's point. \"STream Cipher Connection ID\" (just like PCID, OCID, BCID)",
          "createdAt": "2020-03-09T15:54:35Z",
          "updatedAt": "2020-03-09T15:54:35Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looking again, the document never uses any acronym for 'stream cipher connection ID', so there's no issue there. This is just about 'S' meaning \"source\" or \"server\".",
          "createdAt": "2020-05-26T18:04:23Z",
          "updatedAt": "2020-05-26T18:04:23Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWU1NzM2MjQzMDg=",
      "title": "Unguessable connection IDs",
      "url": "https://github.com/quicwg/load-balancers/issues/8",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "needs-discussion"
      ],
      "body": "There is a requirement that it be difficult for a party other than the server and load balancer to guess a CID that will be accepted as valid for a target connection.\r\n\r\nThis requirement needs to be validated for the schemes described in the draft.  This might impose some constraints on the designs chosen.\r\n\r\nFor instance, I don't believe that the plaintext algorithm meets this goal.  The server ID can take all the available space, which is probably wrong.  Clearly it is impossible to create sufficient connection IDs for even a single connection if there is only one valid identifier per server.  However, it might be argued that even an 18 byte server ID makes it too easy to guess a valid connection ID for a connection (just 16 guesses would be enough to get a 50% chance at that).  So it seems to me that a shorter connection ID is necessary.\r\n\r\nThe same applies to any attempt at obfuscation.\r\n\r\nThe encrypted versions might be similarly challenging to get right.  The For Server Use field in the stream cipher variant needs to be sufficiently long as to avoid engineered collisions.  The value used for the stream cipher is malleable, which means that an attacker isn't prevented from guessing.  In many ways, this is more challenging than the plaintext variant because the nonce consumes space.\r\n\r\nThe zero-padding in the block cipher mode might be the best way of preventing guessing, if it were sufficiently long.  Similarly, if \"Encrypted bits for server use\" were sufficiently sparsely populated, then guessing can be hard enough.",
      "createdAt": "2020-03-01T22:06:18Z",
      "updatedAt": "2020-12-11T23:35:02Z",
      "closedAt": "2020-12-11T23:35:02Z",
      "comments": [
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "> There is a requirement that it be difficult for a party other than the server and load balancer to guess a CID that will be accepted as valid for a target connection.\r\n\r\n- What exactly does \"a CID that will be accepted as valid for a target connection\" mean?\r\n- What is exactly making this requirement?",
          "createdAt": "2020-03-02T04:37:05Z",
          "updatedAt": "2020-03-02T04:37:05Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "A connection ID that is accepted as valid for a target connection is any value that will cause packets to be routed to the node that serves that connection.\r\n\r\nThe transport draft [says](https://quicwg.org/base-drafts/draft-ietf-quic-transport.html#section-5.1-3):\r\n\r\n> Connection IDs MUST NOT contain any information that can be used by an external observer (that is, one that does not cooperate with the issuer) to correlate them with other connection IDs for the same connection. ",
          "createdAt": "2020-03-02T23:30:13Z",
          "updatedAt": "2020-03-02T23:30:13Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this issue is conflating two different things:\r\n1) Is it easy to generate a CID that has a high probability of being considered valid by the LB? For all but BCID with zero-padding, the answer is clearly \"yes\" unless the SID space is sparsely populated. But that doesn't make them valid at the server. Moreover, if I am just trying to get random packets past the LB, it's far more productive to just generate a bunch of Initials.\r\n\r\nIn the absence of an LB, all CIDs get through to the server, so I don't understand why this is a problem.\r\n\r\n2) The transport draft language (it seems to me) exists mostly to prevent linkability in migration events. Although I've mentioned several times that linkability is a continuum, it is pretty clear that PCID fails at this and OCID makes it harder but no one would bet the house on it being truly secure -- hence the name.\r\n\r\nI think we're due for an actual WG discussion on OCID, but for PCID would it be sufficient for you, MT, if we said that servers using PCID MUST use disable_migration? To be honest, I thought I had already done this but it's not there.",
          "createdAt": "2020-03-06T21:24:55Z",
          "updatedAt": "2020-03-06T21:24:55Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "I really want to push back hard on any restrictions around migration for the Plaintext CID algorithm. It is by far the simplest and cheapest algorithm to support in the LB, and IMO must remain a valid option for QUIC load balancing.\r\n\r\nAs far as giving any information to an external observer, it's possible an external observer can work out the Server ID for each CID. Whether this is practically useful information depends on the number of connections being managed by the individual servers.\r\n\r\nIMO, we cannot restrict the full set of QUIC features to only work on the most complex and costly algorithms. Some solutions may never implement them.",
          "createdAt": "2020-03-06T23:46:08Z",
          "updatedAt": "2020-03-06T23:46:08Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah wait, I found the text in security considerations:\r\n\r\n> Servers that are running the Plaintext CID  algorithm SHOULD only use it to generate new CIDs for the Server Initial Packet and SHOULD NOT send CIDs in QUIC NEW_CONNECTION_ID frames.  Doing so might falsely suggest to the client that said CIDs were generated in a secure fashion.\r\n\r\nSo it's a SHOULD right now.",
          "createdAt": "2020-03-09T16:52:00Z",
          "updatedAt": "2020-03-09T16:52:00Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To summarize the issue with Plaintext CID. This is the easiest to implement, so is mostly likely to be adopted.\r\n\r\nHowever:\r\n1) This makes DoS attacks on a single server quite straightforward. There is no consensus as to whether single-server DoS is a threat to mitigate or not.\r\n2) Makes connection IDs more linkable.\r\n3) Unless we add a server transport parameter for it, the client has no idea they're more linkable.\r\n4) We could prohibit migration to fix the linkability problem.\r\n5) If we prohibit migration, than the only reason to do plaintext CIDs, instead of just 5-tuple routing, is to support NAT rebinding.\r\n\r\nTo some extent, Obfuscated CID might have similar issues.",
          "createdAt": "2020-07-03T18:15:43Z",
          "updatedAt": "2020-07-03T18:15:43Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The discussion at IETF 109 suggested that the level of linkability associated with the PCID algorithm did not violate the spirit of quic-transport (see @martinthomson and @ianswett in the QUIC-LB segment here: https://datatracker.ietf.org/meeting/109/materials/minutes-109-quic-00)",
          "createdAt": "2020-12-11T23:35:02Z",
          "updatedAt": "2020-12-11T23:35:02Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "MDU6SXNzdWU1NzM2Mjc1OTE=",
      "title": "Effect on stateless resets",
      "url": "https://github.com/quicwg/load-balancers/issues/9",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The draft doesn't address the impact of each method of connection ID generation on how servers can use stateless resets.\r\n\r\nMost of this is likely bound up in decisions stemming from #8.  If you can guess a valid but unused connection ID, then you might be able to induce a stateless reset that could be used to kill an open connection.\r\n\r\nAs the draft only includes methods that include an explicit server identifier, it is possible that as long as valid values cannot be guessed, the effect is minimal and each server instance can have its own configured stateless reset key (or a shared key from which a per-server key is derived using a KDF).",
      "createdAt": "2020-03-01T22:30:24Z",
      "updatedAt": "2020-07-06T19:17:21Z",
      "closedAt": "2020-07-06T19:17:21Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't understand the attack here. A given CID will deterministically map to a specific server instance. So there is no way for another server to receive a packet with that CID and generate a stateless reset. What am I missing?\r\n\r\n<strike>There might be something here with the differing treatment of long-header vs. short-header packets, (and the option for servers to send resets on long headers), but I'll have to think about it more.</strike>",
          "createdAt": "2020-03-06T21:02:55Z",
          "updatedAt": "2020-03-06T21:07:24Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As to the last point, nope: even a long header with a DCID that conforms to the server's expectations (i.e. maps to a real server) will get delivered to that server, so I don't think that's an attack.",
          "createdAt": "2020-03-06T21:06:56Z",
          "updatedAt": "2020-03-06T21:06:56Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson Should we talk about this issue more, or are you satisfied enough that I can close it?",
          "createdAt": "2020-05-26T18:12:10Z",
          "updatedAt": "2020-05-26T18:12:10Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "I don't see any mention of stateless reset in the draft at all.  That's probably something worth addressing, even if it is to say what you have already.",
          "createdAt": "2020-05-27T01:39:55Z",
          "updatedAt": "2020-05-27T01:39:55Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "MDU6SXNzdWU1NzM2Mjc5NTI=",
      "title": "Moving connections between server instances",
      "url": "https://github.com/quicwg/load-balancers/issues/10",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Some text on how a server cluster might support moving of connections from one server instance to another would be useful.  The current design might permit portability under certain conditions, but there are things that might need to be considered, such as the way in stateless resets are generated.",
      "createdAt": "2020-03-01T22:33:06Z",
      "updatedAt": "2020-03-09T15:18:44Z",
      "closedAt": "2020-03-09T15:18:44Z",
      "comments": [
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "Are you referring to load balancing already existing connections to a new server? Are you envisioning the first server issuing new CIDs (that point to the new server) and setting Retire Prior To to retire the old CIDs so that future traffic redirect to the new server? How do you imagine the rest of the connection state would get moved?",
          "createdAt": "2020-03-02T04:32:17Z",
          "updatedAt": "2020-03-02T04:32:17Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "This applies to cases where clusters are rebalanced, where instances go down and others are expected to pick up the slack, and all similar cases.  In some cases this requires an unspecified mechanism for transferring state between instances.  In others, the instance might remain constant but the identifiers used might need to rotate.\r\n\r\nThis is likely addressed by using Retire Prior To as you say.  Text on that would help.",
          "createdAt": "2020-03-02T23:24:25Z",
          "updatedAt": "2020-03-02T23:24:25Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good idea, it wouldn't hurt to have a short non-normative section on this.",
          "createdAt": "2020-03-06T20:56:34Z",
          "updatedAt": "2020-03-06T20:56:34Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "MDU6SXNzdWU1NzQzMTUyMzE=",
      "title": "Configuration ID might be too small",
      "url": "https://github.com/quicwg/load-balancers/issues/12",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "needs-discussion"
      ],
      "body": "As server clusters increase in size, the need to reallocate server identifiers becomes more acute. \r\n\r\nIn one model, the configuration ID is used to indicate a stable routing configuration.  Server identifiers for a given configuration ID are routed to the same server, no matter how many other instances are added or removed.  In order to allow for changes in the cluster, the configuration ID is used so that old servers can be removed from consideration and new ones added.\r\n\r\nIf these changes happen frequently enough, the number of bits allocated to identifying a configuration might be insufficient.  Why not make the length of the identifier flexible?  That might mean that you need to make the length of the length similarly configurable.",
      "createdAt": "2020-03-02T23:28:35Z",
      "updatedAt": "2020-12-11T23:36:47Z",
      "closedAt": "2020-12-11T23:36:47Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It was not the intent of these bits to support long-lived configurations, instead supporting key rotation, upgrades, and the like. I would much rather people overprovisioned the server ID space than using this tool, TBH.\r\n\r\nHowever, the only cost is limiting the theoretical size of CIDs. At the moment, we can support up to 64B, future-proofing the encodings against future versions of QUIC. I'm open to another bit for this, but how would a configurable number of CR bits work with multiple configurations? How does a config that needs 5 bits and one that needs 2 coexist, especially if the latter needs length self-encoding?",
          "createdAt": "2020-03-06T20:39:11Z",
          "updatedAt": "2020-03-06T20:39:11Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As we talk through the implications of mutually mistrustful servers in #29, I think the case for adding another bit is compelling. I'm going to remove the needs-discussion label and come up with a PR that takes another bit.",
          "createdAt": "2020-07-02T22:29:59Z",
          "updatedAt": "2020-07-02T22:29:59Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm returning this to needs-discussion, as @huitema points out there is a privacy tradeoff here.\r\n\r\nIf the config codespace is large, it's straightforward to have each mistrustful server have its own totally unique config. On the other hand, keeping this long-lived config difference leaks the type of flow. Assuming it's routed based on SNI, it leaks the SNI of each CID, and in that sense also increases linkability.",
          "createdAt": "2020-07-06T19:10:03Z",
          "updatedAt": "2020-07-06T19:10:03Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Alright, I've reflected on this a bit more.\r\n\r\nIn general, different server entities will have different external IP addresses and/or ports, so the load balancer can distinguish the correct QUIC-LB config without resorting to the CR bits. As IP and port are visible to everyone, there is no privacy leakage.\r\n\r\nThe problem occurs when mutually mistrustful servers share the same IP/port and are switched on something else. That \"something\" may be something present only in the client hello, with the classical load balancer simply using the 4tuple after that. The only thing I am aware of in practice is the SNI. If there are others, please say so in this thread.\r\n\r\nIf the SNI is encrypted, the unprivileged LB envisioned in QUIC-LB does not have access to it. So we can assume this use case only applies to unencrypted SNI.\r\n\r\nOption 1: mistrustful servers share the same config. a third party will be able to extract your server mapping, but in practice it will be hard for an attacker to obtain this position on purpose. If this is the best outcome, we can stick with 2 config rotation bits.\r\n\r\nOption 2: Issue them different config rotation codepoints. So an observer can see the SNI and associate it with certain CR bits; if the client later migrates, it will still be able to associate that connection with that SNI. If this is better than Option 1, we should probably add a third config rotation bit.\r\n\r\nOther (minor) costs of having 3 config rotation bits:\r\n- length self-encoding can only support 31 byte connection IDs, instead of 63 (obviously this is only relevant for hypothetical future versions of QUIC)\r\n- each config can have its own set of server IDs. So there is considerably more config state at the LB. As SIDs can be up to 18B, it's 18B x (# of servers) x (# of config rotation codepoints). This memory footprint will roughly double by going from 3 to 7 codepoints.\r\n\r\nI've talked myself into Option 1 as being a mildly better situation, thus sticking with 2 CR bits.\r\n\r\n\r\n\r\n",
          "createdAt": "2020-10-28T21:36:02Z",
          "updatedAt": "2020-10-28T21:36:02Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Update: the ECHO design might allow the LB privileged access to the SNI, so it might be encrypted. However, an attacker could connect to the domains at that IP and obtain the config rotation bits. So option 2 actually circumvents ESNI entirely!",
          "createdAt": "2020-11-18T00:34:07Z",
          "updatedAt": "2020-11-18T00:34:07Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing -- I have received no pushback on doing nothing (leaving it at 2 bits), so I'm going to do nothing.",
          "createdAt": "2020-12-11T23:36:47Z",
          "updatedAt": "2020-12-11T23:36:47Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "MDU6SXNzdWU1ODc5NDQ5Njc=",
      "title": "Giving the client more information",
      "url": "https://github.com/quicwg/load-balancers/issues/16",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "needs-discussion"
      ],
      "body": "QUIC-LB has a bit of an incentive mismatch. The server infrastructure decides how linkable the CID algorithm is, but the client bears most of the cost of the CIDs being linkable. Worse yet, the client has no idea, without a lot of effort, what the servers are doing. Even worse, the servers have some incentives to pick something that's easily linkable.\r\n\r\nIn Section 8, it says:\r\n\r\n> Servers that are running the Plaintext CID algorithm SHOULD only use it to generate new CIDs for the Server Initial Packet and SHOULD NOT send CIDs in QUIC NEW_CONNECTION_ID frames\r\n\r\nThis is a concise way of not giving the client tools to link itself by trying an unsafe migration.\r\n\r\nWe could just stick with that. A richer way to go would be to create a new transport parameter (e.g. cid_is_linkable, cid_not_encrypted) that would explicitly communicate the risks to the client. We could have a different value for OCID or batch PCID and OCID together.\r\n",
      "createdAt": "2020-03-25T19:41:47Z",
      "updatedAt": "2020-12-11T23:32:07Z",
      "closedAt": "2020-12-11T23:32:07Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Due to lack of enthusiasm at IETF 109, closing this issue.",
          "createdAt": "2020-12-11T23:32:07Z",
          "updatedAt": "2020-12-11T23:32:07Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "MDU6SXNzdWU2MTQyMDc4NTA=",
      "title": "Load Balancing Invariant Longer Header Packets",
      "url": "https://github.com/quicwg/load-balancers/issues/20",
      "state": "CLOSED",
      "author": "nibanks",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "We've had some discussion in this area in the past, and we decided that the best way to statelessly (and consistently) load balance long header packets would be to use a hash of the UDP 4-tuple and the client's source CID; since these are the only constants for all incoming (to the server) long header packets. I have come up with a couple of problems with this approach:\r\n\r\n1. As far as I know, there is no statement in the Invariants that says these must all stay constant for all future versions of QUIC.\r\n\r\n2. Using the hash approach can only function statelessly if there is not change in the DIP configuration. If the set of servers being load balanced changes (which we must assume to be common), then whatever stateless logic you have that maps hash to DIP would also change, resulting in long header packets getting routed incorrectly most likely.\r\n\r\n3. A follow up to (2), if you assume that the long header packets cannot therefore be routed statelessly based on the hash, and state must be tracked to continue to consistently route all long header packets until they are no longer used, at what point can the LB discard this state. By design, there is no on-path signal to indicate \"long header packets are no longer used\". Any heuristic that might be added here would be affected by (1) too.\r\n\r\nBecause of these issues, I'm left scratching my head on the best way to recommend to LBs on how to load balance invariant long header packets. The best thing I can think of is:\r\n\r\n- Use the hash mentioned above, but maintain state for each flow (tuple+client_cid).\r\n- Reset a timer (5 sec? 10 sec? 30 sec?) after each new packet is received for the flow. Discard the state when the timer fires.\r\n\r\nBecause the client's CID is included in the flow calculation, it allows an attacker to create nearly unlimited number of flow states on the LB. You might argue that Retry could be first used by a (cooperating) DoS appliance to first validate source address, but after that is done, this attack can still be executed. It would then require some heuristics on the LB to protect against.\r\n\r\n@martinduke @martinthomson any ideas here? ",
      "createdAt": "2020-05-07T17:00:47Z",
      "updatedAt": "2020-05-22T15:47:43Z",
      "closedAt": "2020-05-22T15:47:43Z",
      "comments": [
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "Another, simpler option is just to say live with the disruption of doing things statelessly. Only connections in the second round trip of the handshake would be affected (depending on loss). It's a fairly small window of time, compared to the lifetime of connections. But the clients that do get dropped have a really bad experience, because there will be no stateless reset to immediately kill their connection. They'd have to wait for a timeout.",
          "createdAt": "2020-05-07T17:05:05Z",
          "updatedAt": "2020-05-07T17:05:05Z"
        },
        {
          "author": "udippant",
          "authorAssociation": "NONE",
          "body": "Re (2) - that problem exists for TCP as well. I.e. if you route an incoming TCP connection from a  stateless L4LB to backend servers based on 4-tuple hash, any change in number of backend servers can result in the routing of subsequent packets for the same flow to a different backend server.\r\n\r\nUsing LRU cache for such connection table in L4LB has been a convenient way to address this issue for us ( for >99% of the flows). You may need to tune parameters such as size and TTL for items in the table to your needs. \r\nAlso, a pre-configured upper bound to limit the size of the connection table should address the concern you mentioned regarding exposure to attack vector of unlimited states in L4LB. \r\n\r\nFinally, even for LongHeader packets, packets of type 'Handshake' echo back the \"destination connection id' chosen by the server. So you can use similar logic to route these LongHeader sub-types as you use to route ShortHeader packets if the servers and L4Lb cooperatively choose the 'destination connection Id' [for e.g. as @martinduke  proposed].",
          "createdAt": "2020-05-07T18:39:41Z",
          "updatedAt": "2020-05-07T18:39:41Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "Yeah, a LRU cache is a good solution. The difference between TCP and QUIC here is that TCP provides on path signals the LB can use to clean up state, but QUIC doesn't provide any. So, it' is purely a LRU + some timer.\r\n\r\nAlso, I'm looking for an invariant solution to routing packets. The fact that Handshake packets are similar to Short header packets assumes too much about the per-version semantics.",
          "createdAt": "2020-05-07T18:55:28Z",
          "updatedAt": "2020-05-07T18:55:28Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The draft already addresses this issue in Section 4.\r\n\r\nExcept for some Initial and 0RTT packets, all DCIDs are server generated and so there is no routing problem.\r\n\r\nFor Initial/0RTT, the DCID might turn out to be routable (e.g. it came from a Retry). If not, it is a \"non-compliant DCID\" which is dropped if it's in a short header. If it's a long header:\r\n\r\n> Load balancers MUST forward packets with long headers with non-compliant DCIDs to an active server using an algorithm of its own choosing. It need not coordinate this algorithm with the servers. The algorithm SHOULD be deterministic over short time scales so that related packets go to the same server.\r\n\r\nThis approach is designed to be version-invariant. I suppose a later version could drastically lengthen the time that non-server-generated CIDs were used, but I don't see why they would. The time scale till we get a server-generated CID is quite small, and if somehow the hash still messes up, the only affect is that 0RTT packets get sprayed where they aren't useful. I'm not too worried about that. Ultimately, if neither CID nor UDP tuple is stable, I don't know how you even map the packet to a connection independently of the load balancer problem.",
          "createdAt": "2020-05-07T19:42:02Z",
          "updatedAt": "2020-05-07T19:42:02Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "If we want a version-invariant solution (which is my immediate goal), we can't special case any of the long header packets based on type (Initial, Handshake, 0-RTT).\r\n\r\nBut, either way, @martinduke it sounds like you're in the boat of \"do it stateless and live with the (hopefully small) consequences\"?",
          "createdAt": "2020-05-07T19:50:52Z",
          "updatedAt": "2020-05-07T19:50:52Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I am on team stateless.\r\n\r\nWe don't need to process the packet subtype (Initial, Handshake, 0RTT). The QUIC-LB language just talks about long headers. There are some embedded assumptions: specifically, that client-generated DCIDs aren't around for a long time, and are only in long headers.\r\n\r\nI do think you're raised a point that we should explicity express our assumptions about version invariance. There are a few pathological things future versions could to to make the CID encoding fail: extremely small max CID lengths, client-generated CIDs in short headers, very long intervals before switching to server-generated CIDs, etc.\r\n\r\nMoreover, the LB requirement to use some algorithm that is invariant over small time scales raises some questions. How is the implementer to know if QUICv2 will allow the client first flight to have a consistent DCID but wildly varying SCIDs or UDP src ports? Or consistent SCID but randomized DCID?\r\n\r\nI'll write up a section to discuss these concerns, but I think we should just write them down and shrug.",
          "createdAt": "2020-05-07T20:04:56Z",
          "updatedAt": "2020-05-07T20:04:56Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "Does the invariants ever state that the tuple can't change during the handshake? If that's allowed in the future, the first packet could be from one tuple with the client chosen CID, then the next could be from a new tuple, with the server chosen CID...",
          "createdAt": "2020-05-07T20:13:00Z",
          "updatedAt": "2020-05-07T20:13:00Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It does not. If we feel strongly that something is likely to not remain constant in some future version of QUIC, we can recommend it that LBs not use it in their algorithm. If not, we should just note the assumption and move on.",
          "createdAt": "2020-05-07T20:17:45Z",
          "updatedAt": "2020-05-07T20:17:45Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "There is a question here as to whether this is invariant, but here we go...\r\n\r\nThe goal is to route on the basis of connection ID as much as possible.  But you don't always have an existing mapping.  That might be because you don't know if the connection ID was generated locally, or because you know for certain that it wasn't.  In those cases, the only thing you have to fall back on is the addressing information.  So as Udip says, keeping a cache of flows for those packets you can't recognize is sensible.\r\n\r\nIn reading this, I was thinking \"what can the invariants draft say about this?\"  And it seems like there is something we could say here.\r\n\r\nRight now, when you get a packet, there is some uncertainty about whether the destination connection ID is one of yours.  That is pretty much unavoidable for the long header, unless we create a new invariant way of signaling this (which I don't think we will do).  However, for the short header, I think we could say, definitively, that the connection ID is one that the destination server has selected.  That might help load balancers in this situation.  From my reading of this thread, it seems like this property was assumed throughout, but I realize that we never wrote that down.\r\n\r\n(You can avoid relying on this property by making your connection IDs self-authenticating, but you always have to suffer some false-positive chance, as the amount of data is pretty low.)\r\n\r\n",
          "createdAt": "2020-05-07T23:23:54Z",
          "updatedAt": "2020-05-07T23:24:58Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "Ideally, we'd want the following promises from the Invariants:\r\n\r\n- Short header packets always use your chosen CID\r\n- Long header packets never change UDP 4-tuple\r\n- Long header packets from the client have a constant source CID",
          "createdAt": "2020-05-07T23:44:44Z",
          "updatedAt": "2020-05-07T23:44:44Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Only 1 client-chosen server CID per connection would be sufficient as well,\nI think.\n\nFor packets that contain a client-chosen server CID, we need the LBs to\nhave something consistent to grab on to: this could be any combination of\nUDP address/port\nsource CID\ndestination CID.\n\nif any of these become invariant, we can tell LBs to use it exclusively\nwhen handling non-compliant DCIDs.\n\nOn Thu, May 7, 2020 at 4:44 PM Nick Banks <notifications@github.com> wrote:\n\n> Ideally, we'd want the following promises from the Invariants:\n>\n>    - Short header packets always use your chosen CID\n>    - Long header packets never change UDP 4-tuple\n>    - Long header packets from the client have a constant source CID\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/quicwg/load-balancers/issues/20#issuecomment-625551885>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AF2EYELEB2R2HHAFAP7RP23RQNBXRANCNFSM4M3P2FKA>\n> .\n>\n",
          "createdAt": "2020-05-07T23:49:22Z",
          "updatedAt": "2020-05-07T23:49:22Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "> Only 1 client-chosen server CID per connection would be sufficient as well, I think.\r\n\r\nThis is on the basis that the load balancer can route based on the destination connection ID always.  I think that is right.  And it might be my preferred option.  The list of asks increases if you don't have that, as Nick points out.",
          "createdAt": "2020-05-07T23:55:11Z",
          "updatedAt": "2020-05-07T23:55:11Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Martin, the PR has a pretty good list of relevant things that are not quite\nguaranteed by the invariants draft. We don\u2019t have to have them all but if\nany are oversights please put them in.\n\nOn Thu, May 7, 2020 at 4:55 PM Martin Thomson <notifications@github.com>\nwrote:\n\n> Only 1 client-chosen server CID per connection would be sufficient as\n> well, I think.\n>\n> This is on the basis that the load balancer can route based on the\n> destination connection ID always. I think that is right. And it might be my\n> preferred option. The list of asks increases if you don't have that, as\n> Nick points out.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/quicwg/load-balancers/issues/20#issuecomment-625554775>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AF2EYENL4IYYE5PUFJ7LAWDRQNC6XANCNFSM4M3P2FKA>\n> .\n>\n",
          "createdAt": "2020-05-08T01:20:13Z",
          "updatedAt": "2020-05-08T01:20:13Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In V1, we do assume that the addresses and ports will remain constant during the handshake. That means we can hash or route long header messages with the \"non-compliant DCID\" based on the combination of addresses, ports, SCID and DCID. This has an interesting robustness property: Initial packets sent by different parties will be routed to different contexts, even if the SCID and DCIDs collide -- either by mistake or intentionally. We may think of relaxing the rule in a future version and allow addresses to change during handshake, but I would not like losing the current robustness.",
          "createdAt": "2020-05-08T01:38:58Z",
          "updatedAt": "2020-05-08T01:39:43Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "MDU6SXNzdWU2MjMzMDQxNDM=",
      "title": "Tweak non-compliant DCID recommendation",
      "url": "https://github.com/quicwg/load-balancers/issues/22",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "@martinthomson sayeth on the list:\r\n\r\n>  That routing will rely on the stability of a subset of fields.  I would select from (source IP, source port, destination IP, destination port, DCID) and no others.\r\n\r\nIt would be useful to include something like this in Section 4 as a non-normative hint on what fields to use, since our hint currently consists of an example that just uses the DCID.\r\n\r\nSimilarly, make that assumption clearer in Section 8.\r\n",
      "createdAt": "2020-05-22T15:50:03Z",
      "updatedAt": "2020-07-01T00:47:53Z",
      "closedAt": "2020-07-01T00:47:53Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "NONE",
          "body": "For what it's worth, Google's load balancer only uses destination CIDs for routing. We always pick 64bit CIDs during the handshake so we can assume that short headers always carry 64bit CIDs.",
          "createdAt": "2020-05-22T17:48:35Z",
          "updatedAt": "2020-05-22T17:48:35Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Do all CIDs resolve to a valid server ID?",
          "createdAt": "2020-05-22T18:15:45Z",
          "updatedAt": "2020-05-22T18:15:45Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "@DavidSchinazi do you not care about an attacker specifically crafting destination CIDs to attack a particular server?",
          "createdAt": "2020-05-22T18:39:21Z",
          "updatedAt": "2020-05-22T18:39:21Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "NONE",
          "body": "@martinduke \r\n> Do all CIDs resolve to a valid server ID?\r\n\r\nWe do not have a concept of server ID, but yes every CID routes to a server.\r\n\r\n@nibanks\r\n> @DavidSchinazi do you not care about an attacker specifically crafting destination CIDs to attack a particular server?\r\n\r\nWe do not care about that attack. I haven't seen any indication that it can actually cause harm in real life.",
          "createdAt": "2020-05-22T19:41:49Z",
          "updatedAt": "2020-05-22T19:41:49Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@DavidSchinazi very well, then you have no non-compliant DCIDs. You would only need to upgrade your LBs for new versions if they allowed client-chosen DCIDs < 8 bytes.",
          "createdAt": "2020-05-22T22:08:33Z",
          "updatedAt": "2020-05-22T22:08:33Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "MDU6SXNzdWU2MjMzMzQxOTI=",
      "title": "Fix Figures 3 and 4",
      "url": "https://github.com/quicwg/load-balancers/issues/23",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The bit variable length bit fields are wrong, and don't match the text. Fix them.",
      "createdAt": "2020-05-22T16:32:44Z",
      "updatedAt": "2020-05-26T18:14:13Z",
      "closedAt": "2020-05-26T18:14:13Z",
      "comments": []
    },
    {
      "number": 27,
      "id": "MDU6SXNzdWU2Mzc4NTQxNTY=",
      "title": "Discuss uniqueness of config across load balancers",
      "url": "https://github.com/quicwg/load-balancers/issues/27",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Add a security consideration to avoid the following scenario:\r\n\r\nMyCloudProvider has a single QUIC-LB config for all its load balancers. It rotates keys periodically, etc, but everyone gets the same config. Obviously, all the attacker has to do is open an account with MyCloudProvider and it is able to recover all the server IDs.\r\n\r\nConfigs ought to be restricted to load balancers serving a finite set of servers. It is possible another MyCloudProvider customer is in the pool behind that load balancer, but that's already a privileged position as already described in the draft.\r\n\r\nObviously, this will require some wordsmithing, as the statement above isn't very precise.",
      "createdAt": "2020-06-12T16:00:00Z",
      "updatedAt": "2020-07-06T19:17:38Z",
      "closedAt": "2020-07-06T19:17:38Z",
      "comments": []
    },
    {
      "number": 28,
      "id": "MDU6SXNzdWU2NDAwMDg4NDM=",
      "title": "Routing of ICMP Packet too big messages",
      "url": "https://github.com/quicwg/load-balancers/issues/28",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "QUIC-LB LBs will not have the ability to properly route ICMP PTB messages without some additional work.\r\n\r\n1) Servers SHOULD prepend a garbage Handshake packet to their MSS Probes, so that the SCID is there.\r\n2) LBs SHOULD learn to parse these to extract the SCID and route them as they would a packet with that DCID.\r\n\r\nAlternatively, it could keep track of client IPs/ports and their mapping to servers.",
      "createdAt": "2020-06-16T22:20:28Z",
      "updatedAt": "2020-06-19T19:07:01Z",
      "closedAt": "2020-06-19T19:07:01Z",
      "comments": []
    },
    {
      "number": 31,
      "id": "MDU6SXNzdWU2NDIxNTk3NDk=",
      "title": "Add retry_source_connection_id to Retry Service Token Format",
      "url": "https://github.com/quicwg/load-balancers/issues/31",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The server now needs to include this field.\r\n\r\nFor the no-shared state service, we just need language that the Retry service needs to encode enough information validate the packet DCID as well and drop if it fails validation. If it does, the server MUST use the packet DCID in the retry_source_connection_id  TP.\r\n\r\nFor the shared state service, the retry source connection ID is going to have to be in the token. We might be able to compress this by xoring some fields; I'll think about it.",
      "createdAt": "2020-06-19T18:45:31Z",
      "updatedAt": "2020-06-29T19:11:43Z",
      "closedAt": "2020-06-29T19:11:43Z",
      "comments": []
    },
    {
      "number": 34,
      "id": "MDU6SXNzdWU2NDkzNTQzMjk=",
      "title": "Support of server generated HCID with retry tokens",
      "url": "https://github.com/quicwg/load-balancers/issues/34",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Since draft 28, the retry mechanism includes a requirement that the client DCID in the retried connection matches the server SCID in the retry packet. I do not see a discussion of mechanisms to verify the retried DCID in section 5 of the draft.",
      "createdAt": "2020-07-01T22:08:32Z",
      "updatedAt": "2020-07-03T01:09:27Z",
      "closedAt": "2020-07-03T01:09:27Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I suggest you have a look at Sec 6 of the editor's draft:\r\nhttps://quicwg.org/load-balancers/draft-ietf-quic-load-balancers.html#name-retry-service",
          "createdAt": "2020-07-02T22:27:49Z",
          "updatedAt": "2020-07-02T22:27:49Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes of course, this is addressed in the editor's draft. Let's close this issue.",
          "createdAt": "2020-07-03T01:09:27Z",
          "updatedAt": "2020-07-03T01:09:27Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "MDU6SXNzdWU2NDkzODQyODg=",
      "title": "Using ECB for retry tokens seems sub optimal",
      "url": "https://github.com/quicwg/load-balancers/issues/35",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Section 5.3 specifies a  Shared-State Retry Service describes a token format in which the token include the ODCID, a client IP encoded on 128 bits, and a 20 octets data-time, plus additional data. The token is encrypted using AES ECB. This seems sub-optimal:\r\n\r\n1) Using AES GCM or another AEAD format seems more natural. AEAD checks will immediately detect an invalid token, while using ECB forces reliance on invalidity heuristics.\r\n\r\n2) If using AEAD, there is no need to encode the IP address in the token. It can be derived from the IP header and placed in a pseudo header. The pseudo header can then be authenticated as part of AEAD decryption.\r\n\r\n3) The pseudo header approach can be used to authenticate other fields, e.g. verify that the DCID matches the SCID sent in the Retry packet.\r\n\r\n4) Encoding the time as 64 bits time64_t seems more natural than ASCII encoding, and also shorter.\r\n",
      "createdAt": "2020-07-01T23:03:07Z",
      "updatedAt": "2020-12-18T16:38:02Z",
      "closedAt": "2020-12-18T16:38:02Z",
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The editor draft also encodes the server's SCID in the token. That too could be moved to a pseudo-header, since the field is assume present in the DCID of the post retry Initial.",
          "createdAt": "2020-07-03T01:11:09Z",
          "updatedAt": "2020-07-03T01:11:09Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closed by #33 ",
          "createdAt": "2020-07-09T01:16:44Z",
          "updatedAt": "2020-07-09T01:16:44Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This was closed in error, as #33 deals with the Stream Cipher.",
          "createdAt": "2020-11-03T18:51:20Z",
          "updatedAt": "2020-11-03T18:51:20Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I filed a very similar issue and then closed it when I realized the duplication. The text of that issue:\r\n\r\nI'm not an encryption expert, but if IIUC it's insufficiently hard to forge a shared-state retry token.\r\n\r\nBy inducing a Retry, an attacker can obtain the Retry SCID Length, and then focus entirely on an ODCIDs that allow the CID + CID Length part of the token to be a multiple of 16 B. For example, if RSCIDL= 10 B, then make ODCIDL = 20 B -> 32 Bytes for the block.\r\n\r\nThis then breaks Retry forgery into three separate problems:\r\n(1) Obtaining the mapping of IP Address to the first 16 Bytes of the token. A well-positioned observer could build a database of these in the time scale between token key rotations.\r\n(2) Generate lots of Retry tokens with an ODCID of the correct length, so there is a range of valid CID blocks.\r\n(3) Obtain a valid Retry every few seconds, using the right ODCID length, so that we have a valid timestamp.\r\n\r\nThus, the attacker has a database of\r\n\r\nvalid encrypted IP addresses\r\nvalid encrypted CIDs (really, it's the CID length that would cause validation to fail)\r\nvalid timestamps\r\nAs the spec uses AES-ECB, these blocks can be mixed and matched to create valid Retry tokens.\r\n\r\nThis is not exactly trivially open to attack [1], but it does feel like we're conceding a lot of entropy here. I would like someone to propose an alternate design that restores some of that entropy.\r\n\r\n[1] Step (1) seems to require a fairly privileged position in the network.",
          "createdAt": "2020-11-03T19:06:18Z",
          "updatedAt": "2020-11-03T19:06:18Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@huitema Could I trouble you for a PR on this?",
          "createdAt": "2020-11-03T19:43:57Z",
          "updatedAt": "2020-11-03T19:43:57Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sure. I can basically propose what I am doing in picoquic.\r\nAnd yes, the repetitive nature of ECB enables attacks.",
          "createdAt": "2020-11-04T00:43:36Z",
          "updatedAt": "2020-11-04T00:43:36Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinduke please review PR #59",
          "createdAt": "2020-11-04T02:31:20Z",
          "updatedAt": "2020-11-04T02:31:20Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "MDU6SXNzdWU2NTA3MTI2ODA=",
      "title": "Make it clear the server might do length encoding on its own",
      "url": "https://github.com/quicwg/load-balancers/issues/38",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "The length encoding is mainly there for crypto offload, and the server MAY use this option even if the load balancer and config agent don't need it.",
      "createdAt": "2020-07-03T17:49:04Z",
      "updatedAt": "2020-07-06T19:18:09Z",
      "closedAt": "2020-07-06T19:18:09Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing; this text already exists in Sec 3.3.",
          "createdAt": "2020-07-06T19:18:09Z",
          "updatedAt": "2020-07-06T19:18:09Z"
        }
      ]
    },
    {
      "number": 41,
      "id": "MDU6SXNzdWU2NTUwMjU5NjQ=",
      "title": "Simplify the configuration by merging server-id and zero-pad",
      "url": "https://github.com/quicwg/load-balancers/issues/41",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The encrypted CID format includes a zero-pad field that is used to detect whether the decryption succeeded or not. I suggest merging this field with the server ID field, and test whether the decryption succeed by checking whether the server ID is valid or not. This assumes that the server ID field is sparsely populated. For example, if there are just 256 servers, in theory a 1-octed field would be sufficient; instead, we could use a 4 or 5 octet server ID field that would be sparsely populated, allowing for error detection.\r\n\r\nThis would allow for unified validity detection across all supported methods:\r\n* clear text: verify that the server ID is valid;\r\n* obfuscated: the divider need to have the same size as the full length server ID; the modulo is the server ID; validity can be verified there.\r\n* stream: decrypt and verify that the server-id is valid\r\n* encrypt: decrypt and verify that the server-id is valid\r\n\r\nIt would also allows for simplification of the configuration for the encrypted method, by specifying just one field instead of two.",
      "createdAt": "2020-07-10T20:43:31Z",
      "updatedAt": "2020-07-20T18:39:51Z",
      "closedAt": "2020-07-20T18:39:51Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I agree this is simpler with no cost at all. Care to do a PR?",
          "createdAt": "2020-07-17T17:56:06Z",
          "updatedAt": "2020-07-17T17:56:06Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "MDU6SXNzdWU2NTk0ODEwNzk=",
      "title": "Fix terminology of Config Rotation",
      "url": "https://github.com/quicwg/load-balancers/issues/42",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Erik Fuller points out via email:\r\n\r\n> This term \u201cconfiguration phase\u201d had me confused. These two sentences are the only place we reference it. It\u2019s basically a configuration ID so we can distinguish between settings across connections during a deployment, right? Once a new config is deployed, what happens to all the connections in the old format?\r\n> \r\n> After reading through I\u2019m still not certain what \u201cphase of the algorithm\u201d means\r\n\r\nHe's right. We should just call it a configuration ID and be clearer on what's what.",
      "createdAt": "2020-07-17T17:57:49Z",
      "updatedAt": "2020-07-17T22:15:08Z",
      "closedAt": "2020-07-17T22:15:08Z",
      "comments": []
    },
    {
      "number": 46,
      "id": "MDU6SXNzdWU2NjI1NTc4Njg=",
      "title": "A little confused about configuration agent",
      "url": "https://github.com/quicwg/load-balancers/issues/46",
      "state": "CLOSED",
      "author": "Neo-ZK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Hi Author:\r\n    I have a little confused about 'configuration agent', from the description of draft, I think it should be a centralized control plane of 'load balancer' and 'server', but from the name 'agent', it seems like it should be a agent component which was used to receive message from control plane. So, what is the most correct definition of 'configuration agent'?",
      "createdAt": "2020-07-21T04:11:13Z",
      "updatedAt": "2020-08-14T02:10:45Z",
      "closedAt": "2020-08-14T02:10:45Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In the definitions section, it says: \"A \"configuration agent\" is\r\nthe entity that determines the QUIC-LB configuration parameters for the network\r\nand leverages some system to distribute that configuration.\"\r\n\r\nThe draft isn't really trying to define the architecture of the control plane. I'm not sure what the distinction is, for this spec, between being \"the control plane\" or something that \"receives messages from the control plane\". It is whatever is assigning server IDs.\r\n\r\nIs there other language that would make this clearer?\r\n",
          "createdAt": "2020-07-29T20:14:56Z",
          "updatedAt": "2020-07-29T20:14:56Z"
        },
        {
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Um...I got it. My question comes from that we want to do an implementation about quic-lb, and contribute it to the nginx community, but for nginx, there are not any uniform centralized component to generate and distribute server ID, so we are confused with that if we should do a 'configuration agent' implementation. From your answer, we think that we can just open source quic-lb route ability, and provide a uniform server id usage api. ",
          "createdAt": "2020-07-30T02:54:04Z",
          "updatedAt": "2020-07-30T02:54:04Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah. So the draft originally had an in-band config channel but the group pulled it out for several reasons. I am personally not sure how people will deploy configurations for QUIC-LB in the real world, but for now you probably can't go wrong with adding the parameters to a configuration interface and just having a human being start the process.\r\n\r\nI would suspect that open source QUIC servers would have a check box that says \"accept QUIC-LB configuration\" or something and then it would open a REST interface or whatever to accept it. I would love to hear from cloud providers to understand what config frameworks there are, but I suspect we're going to write something down in a draft somewhere.",
          "createdAt": "2020-07-30T03:14:53Z",
          "updatedAt": "2020-07-30T03:14:53Z"
        },
        {
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I would suspect that open source QUIC servers would have a check box that says \"accept QUIC-LB configuration\" or something and then it would open a REST interface or whatever to accept it. I would love to hear from cloud providers to understand what config frameworks there are, but I suspect we're going to write something down in a draft somewhere.\r\n\r\nAh,  maybe a brief introduction can be write into `1.1.  Terminology`\r\n\r\n\r\n",
          "createdAt": "2020-07-30T03:29:05Z",
          "updatedAt": "2020-07-30T03:29:05Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "so this is already there:\r\nSec 1: \r\nWhile this document describes a small set of configuration parameters to make\r\nthe server mapping intelligible, the means of distributing these parameters\r\nbetween load balancers, servers, and other trusted intermediaries is out of its\r\nscope. There are numerous well-known infrastructures for distribution of\r\nconfiguration.\r\n\r\nSec 1.1\r\nA \"configuration agent\" is\r\nthe entity that determines the QUIC-LB configuration parameters for the network\r\nand leverages some system to distribute that configuration.\r\n\r\nIs this what you're looking for?",
          "createdAt": "2020-08-13T19:48:52Z",
          "updatedAt": "2020-08-13T19:48:52Z"
        },
        {
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> so this is already there:\r\n> Sec 1:\r\n> While this document describes a small set of configuration parameters to make\r\n> the server mapping intelligible, the means of distributing these parameters\r\n> between load balancers, servers, and other trusted intermediaries is out of its\r\n> scope. There are numerous well-known infrastructures for distribution of\r\n> configuration.\r\n> \r\n> Sec 1.1\r\n> A \"configuration agent\" is\r\n> the entity that determines the QUIC-LB configuration parameters for the network\r\n> and leverages some system to distribute that configuration.\r\n> \r\n> Is this what you're looking for?\r\n\r\nOK, thanks for answering, I'd close this issue soon",
          "createdAt": "2020-08-14T02:10:00Z",
          "updatedAt": "2020-08-14T02:10:00Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "MDU6SXNzdWU2Njc3OTMyOTk=",
      "title": "Cut obfuscated server ID algorithm",
      "url": "https://github.com/quicwg/load-balancers/issues/47",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "As discussed at IETF 108.  Split from #8.",
      "createdAt": "2020-07-29T12:07:37Z",
      "updatedAt": "2020-08-13T19:34:58Z",
      "closedAt": "2020-08-13T19:34:58Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for filing this. I agree that this was the feedback, but I'll take it from the list to be sure.",
          "createdAt": "2020-07-29T18:57:32Z",
          "updatedAt": "2020-07-29T18:57:32Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Removing this seems fine to me.",
          "createdAt": "2020-07-29T19:16:23Z",
          "updatedAt": "2020-07-29T19:16:23Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, do it.",
          "createdAt": "2020-07-29T19:24:46Z",
          "updatedAt": "2020-07-29T19:24:46Z"
        },
        {
          "author": "pravb",
          "authorAssociation": "NONE",
          "body": "Seems fine.",
          "createdAt": "2020-07-29T19:24:52Z",
          "updatedAt": "2020-07-29T19:24:52Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "NONE",
          "body": "Do it.",
          "createdAt": "2020-07-29T19:28:51Z",
          "updatedAt": "2020-07-29T19:28:51Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "NONE",
          "body": "Do it.",
          "createdAt": "2020-07-29T19:34:21Z",
          "updatedAt": "2020-07-29T19:34:21Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Nick Harper concurred on the list",
          "createdAt": "2020-07-29T19:59:45Z",
          "updatedAt": "2020-07-29T19:59:45Z"
        }
      ]
    },
    {
      "number": 50,
      "id": "MDU6SXNzdWU2ODcyMzU0MzE=",
      "title": " A bit maybe used in cid  to mark whether the server info encoded in the long header or not?",
      "url": "https://github.com/quicwg/load-balancers/issues/50",
      "state": "CLOSED",
      "author": "Lingtaonju",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Dear sir,\r\nAs you know,  there is no bit in the cid to mark whether the cid encoded the server info or not.  In this case, no matter the server info encoded or not, the load balancer needs to  decrypt or decode the cid. Do you think this is a useless try when the packet is the first initial packet?  Do you think this is a useful idea to expand  the cid format to use the first bit to mark the cid encoded or not?   However, in this case, the client need to obey the rule.",
      "createdAt": "2020-08-27T13:17:16Z",
      "updatedAt": "2020-10-10T02:21:56Z",
      "closedAt": "2020-10-10T02:21:56Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In fact, there is a bit. If the first two bits are '11' that means that the server didn't encode its ID and the load balancer should use 4-tuple routing:\r\n\r\nhttps://quicwg.org/load-balancers/draft-ietf-quic-load-balancers.html#name-configuration-failover\r\n\r\nThe very first packet usually has a CID chosen by the client, which knows nothing about QUIC-LB. The beginning of Section 4 is mostly about how load balancers should handle these.",
          "createdAt": "2020-08-28T17:53:01Z",
          "updatedAt": "2020-08-28T17:53:01Z"
        },
        {
          "author": "Lingtaonju",
          "authorAssociation": "NONE",
          "body": "OK, I almost have forgot the first two Config Rotation bits can be used to mark the cid server info's  validity.\r\n\r\nHowever, in this case, I want to know , for the very first packet, will the draft  suggest  the clients to generate the dcid with the first two bits \"11\" , if they know  the QUIC-LB used.\r\n \r\nAs,  if so,  the  QUIC-LB  know all packets' cid information to prevent useless decode/decrypt  try for the very first packet.",
          "createdAt": "2020-08-31T06:23:21Z",
          "updatedAt": "2020-08-31T06:26:28Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No, this draft does not assume client cooperation at all. The very beginning of Section 4 explains how to handle client-generated CIDs.",
          "createdAt": "2020-08-31T15:59:29Z",
          "updatedAt": "2020-08-31T15:59:29Z"
        },
        {
          "author": "Lingtaonju",
          "authorAssociation": "NONE",
          "body": "> No, this draft does not assume client cooperation at all. The very beginning of Section 4 explains how to handle client-generated CIDs.\r\n\r\nThanks for your reply. Actually, I understand your works and Section 4.\r\nHowever, my point is that , even this draft does not assume client cooperation at all,  this draft can suggest the client to generate a cid with 11  for the very first initial packet.\r\n\r\nThis is useful for QUIC-LB if client obeys the rule, if not , the Section 4 also works well. \r\n",
          "createdAt": "2020-09-01T12:27:05Z",
          "updatedAt": "2020-09-01T12:27:46Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In #52 I'm adding CR bits as a reason for noncompliance.\r\n\r\nIt's fine if the client wants to set '11' , but I don't think it's important to do that. At most all we're saving the LB is a very small decrypt operation.",
          "createdAt": "2020-09-01T15:51:43Z",
          "updatedAt": "2020-09-01T15:51:43Z"
        },
        {
          "author": "Lingtaonju",
          "authorAssociation": "NONE",
          "body": "Even thought the decryption has a low consumption, I insist that the cost can be avoided.\r\n\r\nI admit that the lb can't assume client cooperation at all, however, the draft can suggest the client to obey the rule: \r\n_\" As, it is impossible for the client to know the server information at the beginning of the QUIC conn, so the DCID in the initial can't encode the server info, in this case,  the Client should make the first two bits with \"11\". \"_\r\n",
          "createdAt": "2020-09-14T02:18:57Z",
          "updatedAt": "2020-09-14T02:18:57Z"
        }
      ]
    },
    {
      "number": 51,
      "id": "MDU6SXNzdWU2ODcyNDY5MDk=",
      "title": "Any suggestion about transmit client ip from quic-lb to quic-server?",
      "url": "https://github.com/quicwg/load-balancers/issues/51",
      "state": "CLOSED",
      "author": "Neo-ZK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Dear author:\r\n    As you know, in many production scenarios, quic-server need to know the real ip/port of client. But when there is a quic-lb in the middle(a fullnat quic-lb), there are not any standard way to implement this function. Actually this function is not difficult to implement, will quic-lb-draft suggest or define a standard way for this function later?",
      "createdAt": "2020-08-27T13:33:15Z",
      "updatedAt": "2020-10-30T15:07:53Z",
      "closedAt": "2020-10-30T15:07:53Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That is not currently an objective for this document. I would probably start with taking the PROXY protocol and adapting it for UDP. Perhaps that would be a good draft!",
          "createdAt": "2020-08-28T17:59:35Z",
          "updatedAt": "2020-08-28T17:59:35Z"
        },
        {
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, I got it",
          "createdAt": "2020-08-31T11:38:02Z",
          "updatedAt": "2020-08-31T11:38:02Z"
        },
        {
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Um...I reconsider the situation, can UDP-PROXY-protocol cover all UDP-based transport protocol? Consider this, for QUIC, we may send client ip to quic-server when receive initial packet. For RTP, we may send client ip to real-server when receive first packet...\r\nThere are so much UDP-based protocol, can all situation be covered in one draft?",
          "createdAt": "2020-09-02T14:41:20Z",
          "updatedAt": "2020-09-02T14:41:20Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes\n\nOn Wed, Sep 2, 2020 at 7:41 AM ZengKe <notifications@github.com> wrote:\n\n>\n>\n> Um...I reconsider the situation, can UDP-PROXY-protocol cover all\n> UDP-based transport protocol? Consider this, for QUIC, we may send client\n> ip to quic-server when receive initial packet. For RTP, we may send client\n> ip to real-server when receive first packet...\n>\n>\n> There are so much UDP-based protocol, can all situation be covered in one\n> draft?\n>\n>\n>\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/quicwg/load-balancers/issues/51#issuecomment-685782202>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AF2EYENV43NSOGCBLX3E6D3SDZKSBANCNFSM4QM75G5Q>\n> .\n>\n>\n>\n",
          "createdAt": "2020-09-02T16:08:24Z",
          "updatedAt": "2020-09-02T16:08:24Z"
        },
        {
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\ud83d\udc4c Looking forward to your draft, by the way, could you please tell me when will you start writing this draft?",
          "createdAt": "2020-09-04T02:35:00Z",
          "updatedAt": "2020-09-04T02:35:00Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure I volunteered to write it!\n\nOn Thu, Sep 3, 2020 at 7:35 PM ZengKe <notifications@github.com> wrote:\n\n> \ud83d\udc4c Looking forward to your draft, by the way, could you please tell me\n> when will you start writing this draft?\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/quicwg/load-balancers/issues/51#issuecomment-686864678>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AF2EYEPEQZKXFOUPYOUAIDTSEBG6FANCNFSM4QM75G5Q>\n> .\n>\n",
          "createdAt": "2020-09-04T03:16:02Z",
          "updatedAt": "2020-09-04T03:16:02Z"
        },
        {
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I'm not sure I volunteered to write it!\r\n\r\nAh, if you have any interests to do this, I would like to do some contribution about it",
          "createdAt": "2020-09-04T03:21:02Z",
          "updatedAt": "2020-09-04T03:21:02Z"
        },
        {
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Furthermore, I think it's a very important function for production environment",
          "createdAt": "2020-09-04T03:22:44Z",
          "updatedAt": "2020-09-04T03:22:44Z"
        },
        {
          "author": "Lingtaonju",
          "authorAssociation": "NONE",
          "body": "Is it possible that in quic lb, only a special proxy protocol is designed for quic, such as carrying pp packet only for initial packet, so as to avoid per-packet carrying to reduce overhead ?",
          "createdAt": "2020-09-14T01:53:57Z",
          "updatedAt": "2020-09-14T01:53:57Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "IMO Proxy Protocol is a NAT function, not a load balancing function. I don't think it belongs in this draft. I do have an individual draft (quic-natsupp) that touches on some issues with QUIC NATs, and this could house this work, but I think it'd be better just to write a draft that describes this.\r\n\r\nI'll also note that the latest proxy protocol spec seems to offer UDP support, if I'm reading it correctly:  https://developers.cloudflare.com/spectrum/getting-started/proxy-protocol/#:~:text=When%20using%20UDP%20(currently%20an,Proxy%20Protocol%20to%20'on'.\r\n\r\nThere are some complexities in doing this well for QUIC. It ought to be version-independent (so no using specific long header packet types) and has to handle address migration properly.",
          "createdAt": "2020-09-24T16:10:30Z",
          "updatedAt": "2020-09-24T16:10:30Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "closing this as out of scope for quic-lb.",
          "createdAt": "2020-10-30T15:07:53Z",
          "updatedAt": "2020-10-30T15:07:53Z"
        }
      ]
    },
    {
      "number": 53,
      "id": "MDU6SXNzdWU3MDA5MTMxOTU=",
      "title": "Keepalive design discussion",
      "url": "https://github.com/quicwg/load-balancers/issues/53",
      "state": "CLOSED",
      "author": "Neo-ZK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hi author:\r\n    Will quic-lb design Keepalive mechanism next? Surely it's a very important mechanism in load balancer.",
      "createdAt": "2020-09-14T09:00:56Z",
      "updatedAt": "2020-11-04T02:16:47Z",
      "closedAt": "2020-11-04T02:16:47Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure what you mean by a keepalive mechanism. Layer 4 load balancers can't inject messages into the connection. What are you trying to achieve?",
          "createdAt": "2020-09-24T17:29:18Z",
          "updatedAt": "2020-09-24T17:29:18Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Any further response to this?",
          "createdAt": "2020-11-03T19:15:49Z",
          "updatedAt": "2020-11-03T19:15:49Z"
        },
        {
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for answering",
          "createdAt": "2020-11-04T02:16:47Z",
          "updatedAt": "2020-11-04T02:16:47Z"
        }
      ]
    },
    {
      "number": 54,
      "id": "MDU6SXNzdWU3MTg1MTQ3Nzk=",
      "title": "A question about retry token format",
      "url": "https://github.com/quicwg/load-balancers/issues/54",
      "state": "CLOSED",
      "author": "Lingtaonju",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In following `Figure 6: Cleartext format of shared-state retry tokens` , the token format only encode original dcid and retry scid, but not initial scid.\r\n\r\n![image](https://user-images.githubusercontent.com/19946268/95644074-5e8d3380-0ae6-11eb-8296-3b4c3c92b9ed.png)\r\n\r\n\r\nAs in the transport draft, it describes that all these three cids are carried in the transport parameters for Authenticating:\r\n![image](https://user-images.githubusercontent.com/19946268/95644109-b330ae80-0ae6-11eb-83e6-c260c4924cf2.png)\r\n\r\n",
      "createdAt": "2020-10-10T02:55:18Z",
      "updatedAt": "2020-10-28T22:55:49Z",
      "closedAt": "2020-10-28T22:55:49Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If you read it carefully, I think you'll see that this information isn't necessary in the token. The server needs S1, S2, and S3. S1 is the ODCID field. S2 is the RSCID field. S3 is the source connection ID it uses in the Initial it sends in response to the token! It is not even generated until the Retry token has been processed.",
          "createdAt": "2020-10-28T22:55:49Z",
          "updatedAt": "2020-10-28T22:55:49Z"
        }
      ]
    },
    {
      "number": 55,
      "id": "MDU6SXNzdWU3MTg3NDU2OTY=",
      "title": "question about timestamp in token",
      "url": "https://github.com/quicwg/load-balancers/issues/55",
      "state": "CLOSED",
      "author": "Lingtaonju",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As the draft describes:\r\n\r\n'The date-time string is a total of 20 octets and encodes\r\n the time the token was generated. The format of date-time is\r\n described in Section 5.6 of [RFC3339].'\r\n\r\nthis needs 20 octets in ascii,\r\nmay be the unix time which is the the number of seconds since the Unix epoch in 8 octets\r\nis a better choice in transmission and computing ?",
      "createdAt": "2020-10-11T02:59:43Z",
      "updatedAt": "2020-10-30T13:56:11Z",
      "closedAt": "2020-10-30T13:56:11Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@Lingtaonju  have a look at the PR, please",
          "createdAt": "2020-10-29T21:46:22Z",
          "updatedAt": "2020-10-29T21:46:22Z"
        }
      ]
    },
    {
      "number": 57,
      "id": "MDU6SXNzdWU3MzU1NTQ2ODQ=",
      "title": "Rework Shared-State Token Security",
      "url": "https://github.com/quicwg/load-balancers/issues/57",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I'm not an encryption expert, but if IIUC it's insufficiently hard to forge a shared-state retry token.\r\n\r\nBy inducing a Retry, an attacker can obtain the Retry SCID Length, and then focus entirely on an ODCIDs that allow the CID + CID Length part of the token to be a multiple of 16 B. For example, if RSCIDL= 10 B, then make ODCIDL = 20 B -> 32 Bytes for the block.\r\n\r\nThis then breaks Retry forgery into three separate problems:\r\n(1) Obtaining the mapping of IP Address to the first 16 Bytes of the token. A well-positioned observer could build a database of these in the time scale between token key rotations.\r\n(2) Generate lots of Retry tokens with an ODCID of the correct length, so there is a range of valid CID blocks.\r\n(3) Obtain a valid Retry every few seconds, using the right ODCID length, so that we have a valid timestamp.\r\n\r\nThus, the attacker has a database of \r\n- valid encrypted IP addresses\r\n- valid encrypted CIDs (really, it's the CID length that would cause validation to fail)\r\n- valid timestamps\r\n\r\nAs the spec uses AES-ECB, these blocks can be mixed and matched to create valid Retry tokens.\r\n\r\nThis is not exactly trivially open to attack [1], but it *does* feel like we're conceding a lot of entropy here. I would like someone to propose an alternate design that restores some of that entropy.\r\n\r\n[1] Step (1) seems to require a fairly privileged position in the network.\r\n",
      "createdAt": "2020-11-03T18:44:47Z",
      "updatedAt": "2020-11-03T19:05:45Z",
      "closedAt": "2020-11-03T19:05:45Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is a duplicate of #35, which I reopened. Closing.",
          "createdAt": "2020-11-03T19:05:45Z",
          "updatedAt": "2020-11-03T19:05:45Z"
        }
      ]
    },
    {
      "number": 60,
      "id": "MDU6SXNzdWU3NDUxOTc1OTg=",
      "title": "SNI switching",
      "url": "https://github.com/quicwg/load-balancers/issues/60",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Some load balancers today switch based on the SNI. Obviously, this is not version-invariant. We should add some language about this.\r\n\r\nWhat should such an LB when it encounters an unknown version? It probably has no choice but to forward it based on CID and hope for the best.",
      "createdAt": "2020-11-18T00:45:39Z",
      "updatedAt": "2020-12-16T00:02:35Z",
      "closedAt": "2020-12-16T00:02:35Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If the differing domains trust each other, the servers could helpfully generate Retry packets to redirect the client to the right place. This assumes a bunch of shared state, and that those servers support the same version while the LB does not.\r\n\r\nOf course, if version support differs, the VN process has serious problems.",
          "createdAt": "2020-11-18T00:53:09Z",
          "updatedAt": "2020-11-18T00:53:09Z"
        },
        {
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe encrypt sni will be the real standard later(see https://tools.ietf.org/html/draft-ietf-tls-esni-08), I just think that there is no need for quic lb considering sni",
          "createdAt": "2020-12-11T03:08:42Z",
          "updatedAt": "2020-12-11T03:09:30Z"
        }
      ]
    },
    {
      "number": 62,
      "id": "MDU6SXNzdWU3NjE1NTYzMDk=",
      "title": "Add Acknowledgments",
      "url": "https://github.com/quicwg/load-balancers/issues/62",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Martin Thomson\r\nChristian Huitema\r\n\r\nothers I'm missing?",
      "createdAt": "2020-12-10T19:43:45Z",
      "updatedAt": "2020-12-12T00:11:13Z",
      "closedAt": "2020-12-12T00:11:13Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closed by https://github.com/quicwg/load-balancers/commit/a564b0c3cca21a0dea6a41488924dfdc49ce3b3a",
          "createdAt": "2020-12-12T00:11:13Z",
          "updatedAt": "2020-12-12T00:11:13Z"
        }
      ]
    },
    {
      "number": 64,
      "id": "MDU6SXNzdWU3NjMxNDQ0MTM=",
      "title": "PCID without SID configuration?",
      "url": "https://github.com/quicwg/load-balancers/issues/64",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "martinduke"
      ],
      "labels": [
        "needs-discussion"
      ],
      "body": "@ianswett proposed a PCID design that assigns SIDs on the fly instead of having to pre-configure them. There are drawbacks but it has some nice properties.",
      "createdAt": "2020-12-12T01:21:15Z",
      "updatedAt": "2021-03-15T23:32:05Z",
      "closedAt": "2021-03-15T23:32:05Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is merged, but I'm going to take the question of what we can do with these dueling plaintext designs to the list.",
          "createdAt": "2021-01-11T21:37:48Z",
          "updatedAt": "2021-01-11T21:37:48Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "List discussion was not helpful; closing this with the dynamic method still in the draft.",
          "createdAt": "2021-03-15T23:32:05Z",
          "updatedAt": "2021-03-15T23:32:05Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "MDU6SXNzdWU3Njk1OTY2NDg=",
      "title": "Cryptographic agility",
      "url": "https://github.com/quicwg/load-balancers/issues/65",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The stream and block cipher configuration are locked to AES-ECB.  AES-128-ECB too (this needs to be clear).\r\n\r\nThis is a fine design.  If a better design is required, that can be achieved by adding a new arm to `routing_algorithm`.  It might pay to say that and cite https://tools.ietf.org/html/rfc7696 at the same time.",
      "createdAt": "2020-12-17T06:46:03Z",
      "updatedAt": "2020-12-23T02:44:53Z",
      "closedAt": "2020-12-23T02:44:53Z",
      "comments": []
    },
    {
      "number": 66,
      "id": "MDU6SXNzdWU3NzExMTYwMzc=",
      "title": "Security Considerations for Shared-State Retry Keys",
      "url": "https://github.com/quicwg/load-balancers/issues/66",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "huitema"
      ],
      "labels": [],
      "body": "@huitema has done some nice analysis on the constraints of using a 96-bit random nonce to encrypt the Shared-state retry keys. This analysis should be in security considerations.",
      "createdAt": "2020-12-18T19:20:34Z",
      "updatedAt": "2021-01-11T15:11:33Z",
      "closedAt": "2021-01-11T15:11:33Z",
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I did a nice analysis? I am collecting here the relevant comments on PR #59:\r\n\r\n1- (by @huitema ) Birthday paradox says with a 64 bit random field you will expect collisions after 2^32 tokens -- and that you have to change the key sooner than that if you want to minimize the risk. If you want the risk of collision below 10E-5 (five nines...) then you should not use the key more than 19 million times. It should be technically possible to make the identifier 12 bytes long -- that's the normal size of the IV for AES GCM. The same reasoning says that the key should not be use more that 4.0 E+14 times -- 400 trillion times. That may be the way to go. Better than trying to squeeze an 18 bytes ID there. Or we would have to use something a bit more exotic than AES GCM, but I would rather not go there.\r\n\r\n2- (by @martinduke ) I think we have five options: (1) A 96-bit random number for the sequence number, and just assume there are no collisions (you've computed the very low probability) -- this is wire inefficient but very easy (2) For the shared-state case, the service simply forwards packets with server-generated tokens rather than trying to validate them. Therefore this format is only generated by the retry service and it can use all the sequence numbers without fear of collision. -- this is very easy and wire-efficient, but slightly reduces the usefulness of the Retry Service.\r\n\r\n3- (by @huitema) we only have the following 2 options: (1) A 96-bit random number for the sequence number, and just assume there are no collisions (you've computed the very low probability) -- this is wire inefficient but very easy. (3c) Assign each server a shorter ID for Retry purposes, and put in the token: medium token size, but involves the most configuration. For AEAD, compose the 96 bit sequence as \"(up to) 32 bit server ID\" + \"(up to) 64 bit server-chosen token ID\". The advantage of (3c) over (1) it potentially reduced transmission overhead. For example, the server ID might well be just 16 bits, the token ID might be just 32 bits. If we have a server ID, the LB can use it to direct the incoming Initial to the server that allocated the token, which may or may not be useful. The drawback of (3c) is more configuration, and also exposing the server ID in cleartext. If server ID privacy is an issue, we need something like header protection as part of the token protection.\r\n\r\nAfter discussion, we realized that the \"96 random bits\" option was preferable overall, because:\r\n\r\n1) It does not require managing short \"configuration identifiers\" in complement to server ID;\r\n2) It does create some configuration overhead, but that's limited to at most 4 bytes per token, thus manageable;\r\n3) Birthday paradox tells us that the first collision has a 50% chance of happening after 2^48 tokens have been allocated, which is a fairly large number in practice. We will want to rotate the token encryption key sooner than that.\r\n",
          "createdAt": "2020-12-18T20:02:35Z",
          "updatedAt": "2020-12-18T20:02:35Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Or do you want to compare AES-GCM to other solutions, such as AES-ECB? ECB encryption has a predictability issue, which is demonstrated for example by the penguin picture in [this Wikipedia page](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation). That weakness can expose repetitive patterns in 16-bytes chunks of the token, server-id for example.",
          "createdAt": "2020-12-18T20:07:24Z",
          "updatedAt": "2020-12-18T20:07:24Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "AEAD encryption also has the advantage of immediate detection of forged tokens.",
          "createdAt": "2020-12-18T20:08:09Z",
          "updatedAt": "2020-12-18T20:08:09Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "But there is one weakness in the \"96 bit random\" proposal. It requires that the generators actually use a crypto grade random number generator.",
          "createdAt": "2020-12-18T20:09:58Z",
          "updatedAt": "2020-12-18T20:09:58Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I was referring to the specific bit about how long it is safe to use a given key because we have 96 bits of entropy. Not the rest.",
          "createdAt": "2020-12-18T22:39:42Z",
          "updatedAt": "2020-12-18T22:39:42Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oh, that. We should ask CFRG, but the conservative behavior would be to follow the guidelines in QUIC-TLS section 6.6: \"For AEAD_AES_128_GCM and AEAD_AES_256_GCM, the confidentiality limit is 2^23 encrypted packets; see Appendix B.1. For AEAD_CHACHA20_POLY1305, the confidentiality limit is greater than the number of possible packets (2^62) and so can be disregarded. For AEAD_AES_128_CCM, the confidentiality limit is 2^21.5 encrypted packets; see Appendix B.2. Applying a limit reduces the probability that an attacker can distinguish the AEAD in use from a random permutation; see [AEBounds], [ROBUST], and [GCM-MU].\" So, basically, 8 million tickets.",
          "createdAt": "2020-12-18T23:52:28Z",
          "updatedAt": "2020-12-18T23:52:28Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "But the CFRG computations assume messages that are 10K long. Tickets would typically be 1/100th of that, that may well make a difference. Or maybe it doesn't. Got to ask.",
          "createdAt": "2020-12-18T23:55:07Z",
          "updatedAt": "2020-12-18T23:55:07Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The 96 bits make a difference with 64 bits in the risk of collisions. If there are 2^32 tickets issued with the same key, the chances of at least one collision with 64 bit unique number is 50%; with 96 bits, it is about 1.1E-10. Even if there are only 2^26 tickets issued with that key, the chances of at least one collision with 64 bit unique number is still 0.016%, which many will find too high for comfort.",
          "createdAt": "2020-12-19T00:06:55Z",
          "updatedAt": "2020-12-19T00:06:55Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Do you feel comfortable writing a paragraph about this in the Security Considerations?",
          "createdAt": "2020-12-21T17:15:49Z",
          "updatedAt": "2020-12-21T17:15:49Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closed via #78 ",
          "createdAt": "2021-01-11T15:11:33Z",
          "updatedAt": "2021-01-11T15:11:33Z"
        }
      ]
    },
    {
      "number": 67,
      "id": "MDU6SXNzdWU3NzExMTc2NTA=",
      "title": "Packet Number in Retry Token",
      "url": "https://github.com/quicwg/load-balancers/issues/67",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "martinduke"
      ],
      "labels": [],
      "body": "Currently the Initial Packet number MAY be encoded in the Retry Token. We must either:\r\n\r\n- Include language that a server MUST NOT reject a token because this information is not present; OR\r\n- Just make it part of the format. (IMO this would be bad, because then the Retry service would have to decrypt the packet number)",
      "createdAt": "2020-12-18T19:23:04Z",
      "updatedAt": "2021-01-07T17:41:22Z",
      "closedAt": "2021-01-07T17:41:22Z",
      "comments": []
    },
    {
      "number": 68,
      "id": "MDU6SXNzdWU3NzExMjAwNDg=",
      "title": "Rules for Resumption Tokens",
      "url": "https://github.com/quicwg/load-balancers/issues/68",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "martinduke"
      ],
      "labels": [],
      "body": "We should tighten up the rules for Resumption Token processing by the Retry Service.\r\n\r\nWhen active, it should reject the packet, but it should send Retry. I believe we can distinguish resumption from Retry because the CID length fields are zero; as any Retry token must have a ODCIDL of at least 8, this would appear to be robust.\r\n\r\nOn a related note, the requirement on servers to encode a way to distinguish the two token types is silly, because of this propery.",
      "createdAt": "2020-12-18T19:27:44Z",
      "updatedAt": "2021-01-07T17:45:09Z",
      "closedAt": "2021-01-07T17:45:09Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed by #71 ",
          "createdAt": "2021-01-07T17:45:09Z",
          "updatedAt": "2021-01-07T17:45:09Z"
        }
      ]
    },
    {
      "number": 72,
      "id": "MDU6SXNzdWU3NzMyODEzMTI=",
      "title": "Retry service NATs and ports",
      "url": "https://github.com/quicwg/load-balancers/issues/72",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "martinduke"
      ],
      "labels": [],
      "body": "A few more issues with Retry tokens:\r\n\r\nFor Retry, we're supposed to check the client port. Because this isn't true for NEW_TOKEN, we probably can't put it in the shared-state pseudoheader.\r\n\r\nRelatedly, we currently just say that the shared-state Retry Service has to be behind any NAT.  This isn't enough.\r\n\r\nFor non-shared-state, we're probably fine. For a Retry, the NAT will keep the 4-tuple binding so that on either side there is something to validate.\r\n\r\nFor shared-state:\r\n* if the service is in front of the NAT, the server can't validate the address.\r\n* if the service is behind the NAT, it'll \"work\" but to add any value at all there really has to be a port in there somewhere.\r\n\r\nWe can probably assume that the alternate path that creates the need for shared state won't cause a service-generated token to suddenly appear on the unprotected path.",
      "createdAt": "2020-12-22T22:06:34Z",
      "updatedAt": "2021-01-07T17:44:52Z",
      "closedAt": "2021-01-07T17:44:52Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed by #71 ",
          "createdAt": "2021-01-07T17:44:52Z",
          "updatedAt": "2021-01-07T17:44:52Z"
        }
      ]
    },
    {
      "number": 73,
      "id": "MDU6SXNzdWU3ODA5MjY0MDk=",
      "title": "Switch to QUIC notation",
      "url": "https://github.com/quicwg/load-balancers/issues/73",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "martinduke"
      ],
      "labels": [
        "editorial"
      ],
      "body": "There are so many variable length fields that the ASCII art doesn't serve much of a purpose. Just switch to the notation used in quic-transport for the various CID and token formats.",
      "createdAt": "2021-01-07T00:10:48Z",
      "updatedAt": "2021-01-07T18:32:54Z",
      "closedAt": "2021-01-07T18:32:54Z",
      "comments": []
    },
    {
      "number": 74,
      "id": "MDU6SXNzdWU3ODA5NDAxNjE=",
      "title": "ODCID is at least 64 bits",
      "url": "https://github.com/quicwg/load-balancers/issues/74",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "martinduke"
      ],
      "labels": [],
      "body": "The diagrams indicate they are in the range 0..160. This is incorrect.",
      "createdAt": "2021-01-07T00:33:51Z",
      "updatedAt": "2021-01-07T17:44:26Z",
      "closedAt": "2021-01-07T17:44:26Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "SS Tokens can have this, because they could be NEW_TOKEN tokens. But the shared state format is limited to 64.",
          "createdAt": "2021-01-07T01:43:31Z",
          "updatedAt": "2021-01-07T01:43:31Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed by #71",
          "createdAt": "2021-01-07T17:44:26Z",
          "updatedAt": "2021-01-07T17:44:26Z"
        }
      ]
    },
    {
      "number": 80,
      "id": "MDU6SXNzdWU3ODM3MjMxNjY=",
      "title": "Server ID: bits instead of octets?",
      "url": "https://github.com/quicwg/load-balancers/issues/80",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "martinduke"
      ],
      "labels": [],
      "body": "@ianswett asks if there is added value in expressing server ID lengths in bits instead octets.\r\n\r\nThis is a bit of implementation complexity and a lot of churn in the spec and the handful of implementations that exist, but it does give the configuration agent a little more granularity.\r\n\r\nDoes anyone find the value of this granularity to be compelling?",
      "createdAt": "2021-01-11T21:36:45Z",
      "updatedAt": "2022-07-08T21:03:12Z",
      "closedAt": "2022-07-08T21:03:12Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My thinking is that increasing/decreasing the server ID space by 256 is quite a large jump and could make config rotation a bit more complex.\r\n\r\nAdding an extra bit to the server ID doubles the number of IDs, which is a fairly widely used increase in data structures and algorithms.",
          "createdAt": "2021-01-11T22:04:25Z",
          "updatedAt": "2021-01-11T22:04:25Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "While having such fine control would optimize for efficiency, splitting up bytes like this would complicate implementation. I'm also doubt that 1B of overhead is really going to affect anything.\r\n\r\nClosing this issue due to old age; can reopen if anyone wants to fight it out.",
          "createdAt": "2022-07-08T21:03:12Z",
          "updatedAt": "2022-07-08T21:03:12Z"
        }
      ]
    },
    {
      "number": 81,
      "id": "MDU6SXNzdWU3ODM3NDM0MTU=",
      "title": "Low-config PCID: why stop using some server IDs?",
      "url": "https://github.com/quicwg/load-balancers/issues/81",
      "state": "CLOSED",
      "author": "dtikhonov",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This part is unclear to me:\r\n\r\n> A server SHOULD have a mechanism to stop using some server IDs if the list gets large relative to its share of the codepoint space, so that these allocations time out and are freed for reuse by servers that have recently joined the pool.\r\n\r\nIt is not obvious why these server IDs would be used by new server instances.",
      "createdAt": "2021-01-11T22:13:11Z",
      "updatedAt": "2021-01-13T14:27:45Z",
      "closedAt": "2021-01-13T14:27:44Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Imagine a case where the entire server ID space has been allocated and these allocations never expire. Then there is no way for new pool members to receive assignments unless the config agent issues a whole new configuration! SIDs have to forward to their original assignments, or connections will break.",
          "createdAt": "2021-01-12T20:43:38Z",
          "updatedAt": "2021-01-12T20:43:38Z"
        },
        {
          "author": "dtikhonov",
          "authorAssociation": "MEMBER",
          "body": "I see!  Thank you for the explanation.",
          "createdAt": "2021-01-13T14:27:44Z",
          "updatedAt": "2021-01-13T14:27:44Z"
        }
      ]
    },
    {
      "number": 82,
      "id": "MDU6SXNzdWU3ODQ1ODE1NDA=",
      "title": "Allow-list and deny-list for QUIC versions",
      "url": "https://github.com/quicwg/load-balancers/issues/82",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It would help the anti-DDoS properties if the Retry Service could receive explicit instructions about which QUIC versions the server might support. This provides a way to deploy new versions without having to upgrade the retry service software or hardware.",
      "createdAt": "2021-01-12T20:45:39Z",
      "updatedAt": "2021-01-25T17:21:42Z",
      "closedAt": "2021-01-25T17:21:42Z",
      "comments": []
    },
    {
      "number": 84,
      "id": "MDU6SXNzdWU3ODczMTA5MDA=",
      "title": "Low-Config CID creating huge problems with coexistence of configurations",
      "url": "https://github.com/quicwg/load-balancers/issues/84",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "martinduke"
      ],
      "labels": [],
      "body": "For low-config CID (LCID), which dynamically allocates server IDs, the current editor's draft has a heuristic to extract a server ID from a client-generated non-compliant CID. The fundamental issue is that the server *has* to get an SID from an incoming Initial, even if the SR bits of the Connection ID imply that it doesn't map to the LCID config.\r\n\r\n> \r\n> If the DCID references the 4-tuple routing bits or an undefined configuration, use the following procedure to establish a predictable template for server ID extraction:\r\n> * Identify the instance of Low-Config CID configuration with the largest config rotation codepoint. For example, if configurations 0b10, 0b01, and 0b00 all use the low-config CID algorithm and have server ID lengths of 3, 5, and 7 octets, respectively, and a packet comes in with codepoint 0b11, the load balancer would extract 3 octets for the server ID.\r\n> * Extract the appropriate number of octets.\r\n> * If the server ID matches one already in the table, forward the packet to that server.\r\n> * If not, the load balancer runs the algorithm of its choosing and adds the extracted server ID to the table corresponding to the highest-value Low-Config CID Configuration codepoint.\r\n\r\nThis doesn't work with config rotation. The main principle in CR is that the load balancer needs to get the configuration first -- otherwise the server might generate CIDs that the LB can't route, and we break ongoing connections. Given that, we have a problem. Consider:\r\n\r\n1. LB and server both have LCID configuration 0b00 with SIDL of 1.\r\n2. LB gets LCID configuration 0b01 with an SIDL of 2.\r\n3. LB gets a packet with CR bits 0b01 and octets 2-3 0xfa13, and randomly forwards it to the server\r\n4. The LB will add an SID entry for 0xfa13, but the server will add an SID entry for 0xfa.\r\n5. The server will generate CIDs with CR 0xb00 and SID 0xfa, and the LB will not route them correctly.\r\n\r\nStated more generally: in the current design, the LB can never be sure if the server has a given configuration and that makes it very hard for the LB to infer what the server is going to do with a given CID to get an SID for its table. We don't even know if it's non-compliant at the server or not!\r\n\r\nThere are some potential fixes here:\r\n1) Give up on dynamic server ID allocation\r\n2) Have the LB keep track of config rotation bits it's observed in short header packets to each server -- this is an indication the server has the CR bits. This is also seems vulnerable to attack with injection of random short-header packets.\r\n3) Reserve the SID corresponding to *all* configurations when routing a packet. In effect, this makes it impossible to adapt the crypto algorithms to use dynamically allocated server ID and have them coexist with plaintext ones: the crypto algorithms will essentially have randomly distributed plaintext fields, so the table will fill up fast.\r\n4) Remove config rotation from dynamic allocation; this makes changes to config a site maintenance event. This also effectively prevents using crypto with dynamic allocation, because you can't rotate keys.\r\n5) Change the behavior of a server when it gets CR bits it doesn't understand. Don't extract a server ID. If the server has no IDs because it just booted, simply echo the client-generated CID. When the server gets a config that lets it extract an SID from this, or gets a CID on another connection that it can decode, then it can update the CID on this connection. This implies that we could have valid short header packets with non-compliant DCIDs, so we'd have to have the LB admit these instead of dropping them like it does currently.\r\n6) Same as #5, but instead of echoing the client-generated CID, it uses the 4-tuple routing bits for a new CID. This will make the\r\nCID compliant, but abandon the whole purpose of QUIC-LB until an Initial with the right CR bits arrives (1 in 4 chance per connection).\r\n\r\n***\r\n\r\nUnfortunately, this breaks even more badly it coexists with a configuration with static SIDs. Another example:\r\n1. LB and server have LCID config 0b00 with an SIDL of 1. Server A has SID 0x01 and Server B has SID 0x02.\r\n2. LB gets stream CID config 0b01 (encrypted, static SIDs)\r\n3. An Initial packet has CR bits 0b01. The second octet is 0x02 but the proper SCID decoding maps to Server A. So, it routes to Server A.\r\n4. Server A doesn't have config 0b01 yet, so it extracts an SID from the CID and adds 0x02 to its list of SIDs. It generates an Low-config CID that the LB will route to Server B!\r\n\r\nFrom this, I conclude that dynamically and statically configured SIDs can't safely coexist in the same config space.\r\n\r\n***\r\n\r\nThis is all very hard to reason about. All the options are ugly but my instinct is to retreat to the first option and just abandon this dynamic design.\r\n\r\n\r\n",
      "createdAt": "2021-01-16T01:05:23Z",
      "updatedAt": "2021-02-02T23:35:01Z",
      "closedAt": "2021-02-02T23:35:01Z",
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For the stateless algorithm, can we assume that servers are configured with a \"current epoch\" in a way that's properly synchronized with the LB, and that the epoch is encoded in the first byte of the \"compliant\" CID? Then the LB can do the following:\r\n\r\n1) For Initial packets, assume non compliance. Treat CID as if they were part of the current epoch. Derive mapping from CID to server ID according to current epoch' key. \r\n\r\n2) For all other packets, assume compliance. If epoch is \"too old\", drop the packet (server should have sent new CID to client.) Otherwise, derive mapping from CID to server ID according to specified epoch' key. (Or if CID in cache, use cache.)\r\n",
          "createdAt": "2021-01-16T03:18:45Z",
          "updatedAt": "2021-01-16T03:18:45Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks Christian!\r\n\r\nI am not sure I fully understand your proposal, but I will make some points:\r\n\r\n1) quic-lb tries to distinguish only short-header and long-header packets to remain version invariant. There is no notion of Initials.\r\n\r\n2) the second Initial carries a server generated CID, and 0RTT does not. so it is not so simple as sniffing the Initial codepoint.\r\n\r\n3) IIUC the CR codepoint is much like your \"epoch.\" I think the problem is when you are switching epochs; the LB must understand both and can't be sure which epoch any given server is on. Indeed, this is the heart of the issue.\r\n\r\nOr perhaps I've wildly misunderstood your proposal.",
          "createdAt": "2021-01-16T05:51:00Z",
          "updatedAt": "2021-01-16T05:51:00Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So it boils down to a synchronization problem. The LB knows that a server is in epoch N+1 if it sees a CID from that server with the new epoch. So the transition will work like this:\r\n\r\n1) Before transition, server use epoch N. LB sees from that server CID with epoch N.\r\n2) At some point, LBtransitions to N+1.\r\n3) If the server notices the LB's transition, it also moves to epoch N+1\r\n4) Some time after that, the LB sees clients sending packets to that server with DCID marked for epoch N+1, at which points it knows server and LB are synchronized.\r\n\r\nThe main problem is that there is no synchronization signal from LB to server. The server cannot look at the ID and infer that the LB has moved to a new epoch.\r\n\r\nIt might be possible to use the retry frames to solve that. When it receives a new initial that would map to server X before confirmation that server X is on epoch N+1, the LB might send a retry to the client, suggesting a conforming DCID marked with epoch N+1. The server will receive the retried Initial, and learn that the new epoch has started. The idea probably needs some exploring, but that seems plausible.",
          "createdAt": "2021-01-16T06:28:44Z",
          "updatedAt": "2021-01-16T06:29:37Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Assuming handshakes are going on, yes, LBs can see what configs are operating. This is my option 2 but using egress SCID instead of ingress DCID, definitely an improvement.\r\n\r\nSeveral drafts ago we moved away from explicit in-band signaling. Now we're headed back.",
          "createdAt": "2021-01-16T07:00:41Z",
          "updatedAt": "2021-01-16T07:00:41Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ianswett and I had a long discussion about this problem. We reached a consensus that solution #6 was the least bad one. To summarize:\r\n1. If a client-generated CID comes in that does not match a known config, do not add an SID entry at the LB or server.\r\n2. If it does match a config codepoint, extract the SID accordingly and add it to the table.\r\n3. There will be cases where the LB has a config codepoint, but the server does not. If so, the LB has \"wasted\" an entry but this is not a big problem. The reverse would be a problem, but it is already a requirement for the LB to have the superset of server configs.\r\n4. When it first loads a config, the server will not have any SIDs. This should correct itself after a handful of connections, but until it does the CIDs it generates use the 4-tuple routing codepoint. When it does get an SID, it can retire the old ones across all connections. Thus, there are transitory states where a server can't support rebinding and migration.\r\n\r\nThis is still open for discussion, but I am working on a large PR to reorganize the whole routing section around dynamic SID allocation.",
          "createdAt": "2021-01-28T22:24:04Z",
          "updatedAt": "2021-01-28T22:24:04Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One Note: I believe it can support NAT rebinding, just not migration or changing CIDs.  If a client unknowingly changes its address due to a NAT rebind, it does not change its CID.",
          "createdAt": "2021-01-28T23:25:06Z",
          "updatedAt": "2021-01-28T23:25:06Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No, because if it's the 4-tuple routing codepoint the LB ignores the rest of the CID. So it will route based on the (changed) 4tuple",
          "createdAt": "2021-01-28T23:26:53Z",
          "updatedAt": "2021-01-28T23:26:53Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Of course, I was thinking of something else.",
          "createdAt": "2021-01-28T23:36:16Z",
          "updatedAt": "2021-01-28T23:36:16Z"
        }
      ]
    },
    {
      "number": 85,
      "id": "MDU6SXNzdWU3ODczMjA2MjY=",
      "title": "Bytes for server use",
      "url": "https://github.com/quicwg/load-balancers/issues/85",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Make sure each algorithm always provides 2-3 octets for server use. The current SID limits don't do that.",
      "createdAt": "2021-01-16T01:48:21Z",
      "updatedAt": "2021-02-02T23:23:07Z",
      "closedAt": "2021-02-02T23:23:07Z",
      "comments": []
    },
    {
      "number": 88,
      "id": "MDU6SXNzdWU3OTY0OTE1MTA=",
      "title": "Extend low-config concept to all algorithms",
      "url": "https://github.com/quicwg/load-balancers/issues/88",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In principle, the low-config algorithm's method of extracting a server ID can be extended to all the algorithms. Thus the \"server ID allocation method\" would be an independent variable, with value 'dynamic' and 'static', and the algorithms could operate with either method.\r\n\r\nThis is a significant refactor of the routing section, but will make future decisions about static/dynamic much cleaner to discuss.",
      "createdAt": "2021-01-29T01:02:05Z",
      "updatedAt": "2021-02-02T23:38:20Z",
      "closedAt": "2021-02-02T23:38:19Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closed by #89 ",
          "createdAt": "2021-02-02T23:38:19Z",
          "updatedAt": "2021-02-02T23:38:19Z"
        }
      ]
    },
    {
      "number": 91,
      "id": "MDU6SXNzdWU3OTk1NjE5MzQ=",
      "title": "Replace configuration pseudocode with YANG",
      "url": "https://github.com/quicwg/load-balancers/issues/91",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As the config gets more complicated, the C-ish pseudocode is getting more unwieldy. YANG is the standard for configuration models, so I should bite the bullet and just figure out YANG.",
      "createdAt": "2021-02-02T18:36:47Z",
      "updatedAt": "2021-02-04T20:37:14Z",
      "closedAt": "2021-02-04T20:37:14Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closed by #90 ",
          "createdAt": "2021-02-04T20:37:05Z",
          "updatedAt": "2021-02-04T20:37:05Z"
        }
      ]
    },
    {
      "number": 96,
      "id": "MDU6SXNzdWU4MjI1OTMyNjI=",
      "title": "Retry service handling of non-Initial",
      "url": "https://github.com/quicwg/load-balancers/issues/96",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In Section 7:\r\n\"Retry services MUST forward all QUIC packets that are not of type Initial or 0-RTT. Other packet types might involve changed IP addresses or connection IDs, so it is not practical for Retry Services to identify such packets as valid or invalid.\"\r\n\r\nMUST is too strong. If it keeps any state (i.e. tracking 4-tuples) it can drop non-initial packets. (However, this would make migration not work).\r\n\r\nIf the Retry Service is in front of a QUIC-LB load balancer, the LB will drop random 1-RTT packets but not Handshake and 0-RTT unless it is version-aware, so passing 1-RTT is \"safe.\"\r\n\r\nIf the Retry Service is behind the load balancer, which is probably better because LBs are often NATs, then random 1-RTT is already dropped and it is safe to forward 1-RTT to preserve migration.\r\n\r\nIf there's a non QUIC-LB load balancers, migration doesn't work anyway; might as well drop it.\r\n\r\nIf it's a single server and the CIDs are random, admitting 1-RTT is weakening the DoS defense.\r\n\r\nAnd then there is the issue with QUIC versions and admitting/dropping them, which is hard to adjudicate with short headers.\r\n\r\n",
      "createdAt": "2021-03-04T23:27:29Z",
      "updatedAt": "2021-03-12T22:32:28Z",
      "closedAt": "2021-03-12T22:32:28Z",
      "comments": [
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "I don't know. Do you have a case where Retry services should not forward those packets? I don't want this to be a source of ossification because of a possibly incorrect assumption about placement of the retry service in the pipeline.",
          "createdAt": "2021-03-05T00:32:50Z",
          "updatedAt": "2021-03-05T00:32:50Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, the reason to not forward them is to block DDoS vectors. A garbage Handshake or 1-RTT packets is at least easily discarded by the server without much in the way of processing. I would actually appreciate some input from your Azure contacts about this; is filtering non-SYN packets important today?",
          "createdAt": "2021-03-05T16:59:17Z",
          "updatedAt": "2021-03-05T16:59:17Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "Here's the data I can provide: As I understand it, the DDoS would be in front of the LB. It's all in hardware so it's update cycle could be very long, so any logic added there could effectively be written in stone for many years. So, I really want to be careful about any assumptions here. If we get it wrong for a future version, either all of Azure might end up breaking/preventing future versions/features or we'd have to completely disable and lose the protection.\r\n\r\nOn the topic of dropping garbage/invalid packets, I'd be Ok with that. Perhaps we could change the text to the following?\r\n\r\n> Retry services MUST forward all **valid** QUIC packets that are not of type Initial or 0-RTT. Other packet types might involve changed IP addresses or connection IDs, so it is not practical for Retry Services to identify such packets as valid or invalid.\r\n\r\nThis adds some wiggle room for what is considered \"valid\" or not. Obviously if the header is garbage it can be tossed. If a device **knows** a particular CID is invalid, then it could drop it. I'd just strongly caution any \"smarts\" here because of the possibility of changes in the future.",
          "createdAt": "2021-03-05T17:05:57Z",
          "updatedAt": "2021-03-05T17:05:57Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If \"in front of the LB\" is cancnical use case, I can shade the language towards that.\r\n\r\nHowever, this makes me wonder about the shared-state case. My perception is that combining a NAT with an LB is quite common; will shared token verification work if the server and retry service are seeing different client IP addresses? This calls into question the entire shared-state concept.",
          "createdAt": "2021-03-05T17:08:32Z",
          "updatedAt": "2021-03-05T17:08:32Z"
        }
      ]
    },
    {
      "number": 98,
      "id": "MDU6SXNzdWU4MjgwMDg0MDU=",
      "title": "Consider an alternative name to 'non-compliant'",
      "url": "https://github.com/quicwg/load-balancers/issues/98",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In PR #95 I suggested non-routable, though I realize non-conformant may also be an option.\r\n\r\nThe sentence which caused me to suggest non-routable is: https://github.com/quicwg/load-balancers/blob/master/draft-ietf-quic-load-balancers.md#non-compliant-connection-ids-non-compliant\r\n\r\n> These client-generated CIDs might not conform to the expectations of the routing algorithm and therefore not be routable by the load balancer. Those that are not routable are \"non-compliant DCIDs\" and receive similar treatment regardless of why they're non-compliant:\r\n\r\nI'm happy to write a PR if others find non-compliant potentially confusing as well.",
      "createdAt": "2021-03-10T16:33:04Z",
      "updatedAt": "2021-04-03T18:34:45Z",
      "closedAt": "2021-04-03T18:34:45Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like it. Let's go with it.",
          "createdAt": "2021-03-12T22:31:52Z",
          "updatedAt": "2021-03-12T22:31:52Z"
        }
      ]
    },
    {
      "number": 99,
      "id": "MDU6SXNzdWU4MjgwMzc4MTQ=",
      "title": "Consider an alternative name to 'arbitrary' algorithm",
      "url": "https://github.com/quicwg/load-balancers/issues/99",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I'd suggest 'Fallback' or another word than arbitrary.\r\n\r\nA definition of Arbitrary is: \"Based on random choice or personal whim, rather than any reason or system.\"\r\n\r\nIn fact, there are sensible constraints on this algorithm to ensure routing works correctly for non-compliant CIDs and connections don't fail.",
      "createdAt": "2021-03-10T16:54:03Z",
      "updatedAt": "2021-04-03T18:35:11Z",
      "closedAt": "2021-04-03T18:35:10Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed.",
          "createdAt": "2021-03-12T22:31:22Z",
          "updatedAt": "2021-03-12T22:31:22Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closed by #109 ",
          "createdAt": "2021-04-03T18:35:10Z",
          "updatedAt": "2021-04-03T18:35:10Z"
        }
      ]
    },
    {
      "number": 101,
      "id": "MDU6SXNzdWU4MzA3NjMxODU=",
      "title": "Reduce load of Dynamic SID allocation",
      "url": "https://github.com/quicwg/load-balancers/issues/101",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Today, an \"lb_timeout\" parameter tells LBs how long they need to save an SID allocation after it's last observed on an incoming packet. Servers may have to retire CIDs when they're approaching this limit. It's the only current method of getting rid of these, as we lack any sort of in-band mechanism for the two entities to communicate.\r\n\r\nAdvantages:\r\n- servers have more SIDs to choose from, which dramatically improves the entropy of PCID (where, admittedly, the operator has chosen not to care about concealing the mapping)\r\n- the server is seldom compelled to retire active CIDs, so the overhead of NEW/RETIRE_CONNECTION_ID frames is low\r\n\r\nDisadvantages:\r\n- If the server ID space >> the number of servers, over time the LB's table gets very large, to the extent it could challenge the RAM of the device. Careful selection of a server ID length can help, but that's putting a lot on the operator.\r\n- The lb_timeout mechanism is annoying because LBs that store a little bit of state have to inspect every packet to make a note of the last time it observed an SID. Servers have to do the same to check when things expire. This seems easy to mess up.\r\n- Servers also have to decode every incoming Initial CID to extract the SID.\r\n\r\nAn alternative would configure servers to keep a small number of SIDs. This could be as low as 1 but might be 8 or 16. If an allocatable SID arrives at the server, if it does not *instantly* use that SID in the CID it sends with the server hello, it forfeits the allocation.\r\n\r\nExample of acceptance:\r\n- SID 0x14 arrives in a Client Initial. LB hashes it to a server and adds it to a hash table of provisional allocations\r\n- Server generates CID using 0x14 and sends it the Server Initial, adding it to its list of server IDs\r\n- LB notes that the first inbound short header encoded 0x14 and makes it a permanent allocation\r\n\r\nExample of rejection\r\n-  SID 0x15 arrives in a Client Initial. LB hashes it to a server and adds it to a hash table of provisional allocations\r\n-  Other long headers with 0x15, with any 4-tuple, also go to the server thanks to the provisional list (you can't be provisional to two servers!)\r\n- Server generates a CID that encodes 0x14.\r\n- LB notes that the first inbound short header did not encode 0x15 and decrements the ref count for the provisional allocation, deleting it if the ref count is zero.\r\n\r\nWe could even make it so the server MUST accept the first n that it can; then, the LB need not even do a provisional allocation after that peer has reached the threshold.\r\n\r\nAdvantages:\r\n- much fewer resources for SID tables\r\n- no timers, less CID parsing & inspection\r\n- the architecture doesn't mandate more CID retiring due to changing SIDs\r\n\r\nDisadvantages:\r\n- ?",
      "createdAt": "2021-03-13T01:04:38Z",
      "updatedAt": "2021-10-04T16:46:09Z",
      "closedAt": "2021-10-04T16:46:09Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Can't make it a MUST for the server to take the first N SIDs; if it has its own load balancer (eg routing to multiple cores) it will have to wait until each of them has gotten an SID, which might take a while.",
          "createdAt": "2021-03-13T01:38:56Z",
          "updatedAt": "2021-03-13T01:38:56Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This has a trivial attack: If I send a storm of initial packets with random CIDs, followed by 1RTT packets with the same CID, I force the LB to add it to its table, rapidly filling it up. We could fix this by forcing the LB to sniff SCIDs from the server instead of 1-RTT packets, which seems a little gross.\r\n\r\nFor not-PCID, it would be sufficient to simply check that there's a new CID, even if it encodes the same SID.",
          "createdAt": "2021-03-18T20:20:57Z",
          "updatedAt": "2021-03-18T21:37:25Z"
        }
      ]
    },
    {
      "number": 102,
      "id": "MDU6SXNzdWU4MzIwMjY4NjM=",
      "title": "Is the non-shared-state use case realistic?",
      "url": "https://github.com/quicwg/load-balancers/issues/102",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "needs-discussion"
      ],
      "body": "Buried deep in Sec 7.2.2:\r\n\r\nIn **inactive mode**, the service MUST forward all packets that have no token or a token with the first bit set to '1'. It MUST validate all tokens with the first bit set to '0'. If successful, the service MUST forward the packet with the token intact. If unsuccessful, **it MUST either drop the packet or forward it with the token removed**. The latter requires decryption and re-encryption of the entire Initial packet to avoid authentication failure. Forwarding the packet causes the server to respond without the original_destination_connection_id transport parameter, which preserves the normal QUIC signal to the client that there is an on-path attacker.\r\n\r\nMy understanding of these services is that they will be injected in the path only when under DoS attack. According to this, something has to hang around to validate Retry tokens. Is this feasible?",
      "createdAt": "2021-03-15T17:20:47Z",
      "updatedAt": "2021-05-05T19:03:33Z",
      "closedAt": "2021-05-05T19:03:33Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hardware is probably the use case here.",
          "createdAt": "2021-05-05T19:03:33Z",
          "updatedAt": "2021-05-05T19:03:33Z"
        }
      ]
    },
    {
      "number": 103,
      "id": "MDU6SXNzdWU4MzIyNzk4MzQ=",
      "title": "Dynamic SIDs and High Availability",
      "url": "https://github.com/quicwg/load-balancers/issues/103",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "ianswett"
      ],
      "labels": [],
      "body": "How does a dynamic framework survive an HA handover? It would seem to lose all the SID allocations and break all connections.",
      "createdAt": "2021-03-15T23:30:48Z",
      "updatedAt": "2021-10-05T17:05:28Z",
      "closedAt": "2021-10-05T17:05:28Z",
      "comments": []
    },
    {
      "number": 105,
      "id": "MDU6SXNzdWU4MzkwNzgzMzg=",
      "title": "Applicability to DTLS 1.3",
      "url": "https://github.com/quicwg/load-balancers/issues/105",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Almost by accident, QUIC-LB can also route DTLS 1.3 associations over UDP, as long as the client agrees to support connection IDs.\r\n\r\nThe Ciphertext packets match the short header in the relevant ways, and so can be routed without any issues.\r\n\r\nThe plaintext packets appear to be QUIC short headers, but as the second byte happens to always be 0xfe, QUIC-LB will 4-tuple route it.\r\n\r\nIIUC, this doesn't apply to earlier versions of DTLS. So, one can deploy DTLS behind a QUIC-LB infrastructure as long as\r\n1) Servers reject DTLS < 1.3\r\n2) Servers reject ClientHellos that do not have the connection_id extension.\r\n\r\nOne could also write a slightly different version of QUIC-LB that supported DTLS without reservations, but you'd have to be aware that the packet was DTLS and leverage information about the format of the first byte.",
      "createdAt": "2021-03-23T20:06:29Z",
      "updatedAt": "2021-05-05T18:52:15Z",
      "closedAt": "2021-05-05T18:52:15Z",
      "comments": []
    },
    {
      "number": 107,
      "id": "MDU6SXNzdWU4NDM1MTM2ODQ=",
      "title": "More text on configuration sharing",
      "url": "https://github.com/quicwg/load-balancers/issues/107",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Sec 11.4 recommends either separating mistrustful servers by IP, or assigning them different config rotation bits. The text is not adequate.\r\n\r\n- Separating by IP address undermines the privacy value of ECHO & DoH (see the MAPRG IETF 110 talk)\r\n- Any sub-IP routing has to be SNI-switched; if ECHO is operating, the load balancer must be a \"client-facing server\" in the ECHO architecture (draft-ietf-tls-esni Sec 3.1).\r\n- Doing SNI switching as an ECHO server and then just encoding the result in the config rotation bits leaks the information they're trying to conceal.\r\n- It might be worth it to fix up the \"arbitrary algorithm\" text to consider possible SNI switching.\r\n\r\nAs we migrate towards ECHO and DoH, maybe the best we can do is give all tenants on an IP the same config and try to obscure their co-tenancy as much as possible.",
      "createdAt": "2021-03-29T15:57:49Z",
      "updatedAt": "2021-04-21T21:03:40Z",
      "closedAt": "2021-04-21T21:03:40Z",
      "comments": []
    },
    {
      "number": 108,
      "id": "MDU6SXNzdWU4NDYzMjEyNTU=",
      "title": "Confused about `AEAD Checksum` in retry token",
      "url": "https://github.com/quicwg/load-balancers/issues/108",
      "state": "CLOSED",
      "author": "Neo-ZK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Hi martin:\r\n\r\n1. It seems that draft limits the encryption algorithm of retry token must be `AES-128-GCM`, but the description of AEAD CheckSum is `AEAD Checksum (length depends on encryption algorithm)`.\r\n\r\n2. Further more, what is `AEAD Checksum` and why we need it? AEAD encryption algorithm just need `key, association data , iv` to do encryption/decryption and authentication.   ",
      "createdAt": "2021-03-31T09:53:25Z",
      "updatedAt": "2021-04-06T03:41:23Z",
      "closedAt": "2021-04-02T21:58:03Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi William\r\n\r\n1) The checksum thing is a good point. I'll fix it.\r\n\r\n2) Like for QUIC packets themselves, there is an authentication tag that AES-GCM generates and we append it to the token. I am not a crypto expert, but I believe this is how the decoder detects if the AAD was changed or there's a problem with the ciphertext.",
          "createdAt": "2021-04-02T21:55:41Z",
          "updatedAt": "2021-04-02T21:55:41Z"
        },
        {
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> 2\\. Like for QUIC packets themselves, there is an authentication tag that AES-GCM generates and we append it to the token. I am not a crypto expert, but I believe this is how the decoder detects if the AAD was changed or there's a problem with the ciphertext.\r\n\r\nYou means that `checksum ` is something just like `Retry Integrity Tag` in `Retry packet`? If so, I think it's a redundant design,  the design of `Retry packet` can ensure that the data can not be tampered with. Moreover, if we must need this, maybe we should have an alternative name of `checksum`, and give a more detail description of it ",
          "createdAt": "2021-04-06T03:41:23Z",
          "updatedAt": "2021-04-06T03:41:23Z"
        }
      ]
    },
    {
      "number": 111,
      "id": "MDU6SXNzdWU4NTIwNjg5NTY=",
      "title": "Consider an alternative name of `AEAD checksum`",
      "url": "https://github.com/quicwg/load-balancers/issues/111",
      "state": "CLOSED",
      "author": "Neo-ZK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hi martin:\r\n`AEAD checksum` is not a standard name of AEAD verification message, which should be `AEAD Integrity Check Value`, see section 6 of rfc4106",
      "createdAt": "2021-04-07T06:45:00Z",
      "updatedAt": "2021-04-21T23:16:38Z",
      "closedAt": "2021-04-21T23:16:38Z",
      "comments": []
    },
    {
      "number": 113,
      "id": "MDU6SXNzdWU4NTIwNzgxNzM=",
      "title": "Consider giving more information about `AEAD IV`",
      "url": "https://github.com/quicwg/load-balancers/issues/113",
      "state": "CLOSED",
      "author": "Neo-ZK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Hi martin:\r\n \r\nThe defination of `AEAD IV` and `AEAD nonce` brought me a great confusion when I implement the share-state retry service. Though finally I got what the draft want to express, I still suggest we should give more information about them\r\n\r\nAccording to section 1.5 of rfc5084:\r\n```\r\nAES-GCM has four inputs: an AES key, an initialization vector (IV), a plaintext content, and optional additional authenticated data (AAD).\r\n```\r\n\r\nAccording to section 3.4 of rfc5116\r\n```\r\nFor example, AES-GCM ESP [RFC4106] can be expressed as follows.  The\r\n   AEAD inputs are\r\n\r\n      P = RestOfPayloadData || TFCpadding || Padding || PadLength ||\r\n      NextHeader\r\n\r\n      N = Salt || IV\r\n\r\n      A = SPI || SequenceNumber\r\n\r\n   where the symbol \"||\" denotes the concatenation operation, and the\r\n   fields RestOfPayloadData, TFCpadding, Padding, PadLength, NextHeader,\r\n   SPI, and SequenceNumber are as defined in [RFC4303], and the fields\r\n   Salt and IV are as defined in [RFC4106]. \r\n```\r\n\r\nI guess that `AEAD nonce` in current draft is the `nonce` define in rfc5116,  `AEAD IV` is just a random value(or a incrementing number) to generate `AEAD nonce`. If I were true, please consider my PR for my suggestion.",
      "createdAt": "2021-04-07T06:57:35Z",
      "updatedAt": "2021-07-09T19:45:31Z",
      "closedAt": "2021-07-09T19:45:31Z",
      "comments": [
        {
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Additional, it's no need to make the length of `AEAD IV`(current draft define)  variable, just 96 bit is sufficient. Current aes-128-gcm related cipher suites all use this value",
          "createdAt": "2021-04-16T08:02:26Z",
          "updatedAt": "2021-04-16T08:02:26Z"
        },
        {
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We can also add some illustration of `Key Sequence`, draft use `identifier` in other place",
          "createdAt": "2021-04-16T09:36:22Z",
          "updatedAt": "2021-04-16T09:36:22Z"
        }
      ]
    },
    {
      "number": 114,
      "id": "MDU6SXNzdWU4NTIwODQ4MTg=",
      "title": "Consider giving a test vector of shared-state-retry-token?",
      "url": "https://github.com/quicwg/load-balancers/issues/114",
      "state": "CLOSED",
      "author": "Neo-ZK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hi martin:\r\n\r\nMaybe we can give a test vector of shared-state-retry-token in appendix, in fact, I encountered a lot of confusions in the implementation of it, a test vector may make the whole process easier to understand;-)\r\n\r\nIf you think it's necessary, I'd like to make a pr for it. ",
      "createdAt": "2021-04-07T07:06:11Z",
      "updatedAt": "2021-05-14T20:37:48Z",
      "closedAt": "2021-05-14T20:37:48Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed by #117 ",
          "createdAt": "2021-05-14T20:37:48Z",
          "updatedAt": "2021-05-14T20:37:48Z"
        }
      ]
    },
    {
      "number": 118,
      "id": "MDU6SXNzdWU4NzY3NTg5NTQ=",
      "title": "Crypto Agility in Shared State Retry",
      "url": "https://github.com/quicwg/load-balancers/issues/118",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Secure ciphers are much more important for Shared State Retry than for the load balancer stuff and Initial Encryption. Therefore, some crypto agility to allow this mechanism to adapt as ciphers deprecate would be good.\r\n\r\nThe key sequence can also imply a cipher, so we'll add that to the data model. Some fields will vary length based on the cipher.\r\n\r\nWe should also make it so everyone MUST support AES128-GCM.",
      "createdAt": "2021-05-05T19:16:19Z",
      "updatedAt": "2021-10-04T18:00:23Z",
      "closedAt": "2021-10-04T18:00:23Z",
      "comments": []
    },
    {
      "number": 119,
      "id": "MDU6SXNzdWU4ODM2MTc5OTA=",
      "title": "Introduce some practical experience in ant group.",
      "url": "https://github.com/quicwg/load-balancers/issues/119",
      "state": "CLOSED",
      "author": "Lingtaonju",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Dear  Duke and Banks,\r\nas you know , in ant group, the biggest fintech company in the world, we have designed and run the quic lb to support quic migration and other characteristic for many years.  We are glad to see that you  are trying to make quic lb standard.  \r\nIn addition to  the content of this onging quic lb draft,  I want to provide some more practical experience in ant group which maybe make it more substantial.\r\n\r\nIn this issue, I will  firstly show you the stateless reset  in quic lb, details here: \r\n\r\n```\r\nAs the transport-draft described, stateless reset provided as an option of last resort for an\r\nendpoint that does not have access to the state of a connection. To realize this, endpoint(e.g: server) \r\nsends stateless reset packet to the sender(such as client). The stateless reset packet is stateless, \r\nso, in the cluster, if all the servers use the same static key, it will work.\r\nMore details about how is omitted here. \r\n\r\n```\r\n\r\nAs reset is stateless,  we make  it  work in quic lb. \r\n```\r\n1. quic lb use the same  encryption algorithm (HKDF, HMACK) and static key  with quic server.\r\n2. for valid quic short header packet with server info encoded, but corresponding ups is down \r\n   or removed from the cluster, quic lb will generate the valid reset packet to make client terminate \r\n   the connection.\r\n3. other details  I wii show you in the PR\r\n```\r\n\r\nAbout the stateless, we can discuss here. Looking forward to your feedback\r\n\r\n\r\n\r\n\r\n\r\n",
      "createdAt": "2021-05-10T07:43:28Z",
      "updatedAt": "2022-04-07T19:57:47Z",
      "closedAt": "2022-04-07T19:57:47Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Interesting design --- thanks for the PR!\r\n\r\nI will have to think about this some more, but here are some quick reactions, mostly related to security. None of these mean that I'm rejecting the idea.\r\n\r\n(1) QUIC-LB is already very complicated (maybe too complicated?), and I am reluctant to add yet more features. Can you share data on how this helps in your deployment? To me, stateless reset is an edge case that wouldn't happen all that often and didn't have particularly important benefits to offloading it.\r\n\r\nIn particular, this implies an out-of-band method to communicate server state. If a server was going down for maintenance or at a rate-limit, why wouldn't the server simply close connections and refuse new ones, or use its own flow control? Why not use a Retry service to redirect new connections to a different server?\r\n\r\n(2) The consequences of leaking this key are especially large -- for SCID/BCID, it's just compromising the server mapping; for Retry Services, you can break the Retry mechanism. For this, an attacker can inject packets to kill any connection it can observe.\r\n\r\n(3) There probably needs to be some further protection against Stateless Reset Oracle (Sec 21.11 of quic-transport). I believe it would be sufficient to only allow this in response to short header packets.\r\n\r\n(4) The configuration actions need much more definition to be a usable standard. There needs to be a format of the information you're encrypting, in addition to a key and cipher.\r\n\r\n(5) Unlike the Retry Services piece, this directly ties in with load balancing, but load balancing tries to be version-independent and this not version independent.\r\n\r\n(6) This can't work without length self-encoding; otherwise, the LB can't reliably extract the CID.\r\n",
          "createdAt": "2021-05-14T21:31:21Z",
          "updatedAt": "2021-05-14T21:31:21Z"
        },
        {
          "author": "Lingtaonju",
          "authorAssociation": "NONE",
          "body": "Dear duke, thanks for your reply. For these considerations, I made some following additions\uff0cwe can discuss further :\r\n+ For question (1)\r\n\r\n```\r\n\u201cQUIC-LB is already very complicated (maybe too complicated?), and I am reluctant to add yet more features.\u201d\r\n```\r\n\r\nI agree with this view partially. In the design of a certain function, it is complicated and many things are considered\uff0cbut in terms of the features of the Quic LB itself, I think more can be added?\u00a0 QUIC LB can do more things for this complicated UDP protocol, more features means necessity but not confusion ?\r\n\r\n```\r\n\" To me, stateless reset is an edge case that wouldn't happen all that often and didn't have particularly important benefits to offloading it\"\r\n```\r\nThe necessity of stateless rest in quic lb can be summarized:\r\n1. Take the common open source based access network ( client -> lvs -> nginx -> real server)  for example, lvs has the ability to reset unknown tcp packets, in other words, lvs has tcp stack ability.\u00a0 QUIC-LB \u00a0Maybe also needs this ability?\u00a0 QUIC LB should reset the unkown QUIC packets, but not just drop it. So this is the basic ability,\u00a0 although it may not wok often, it is essential.\r\n\u00a0\r\n2. Consider a typical situation where the backend carried in the DCID does not exist or unhealty because of maintenance. This situation is similar to that tcp's session state does not exist in LVS. It should be reset directly by QUIC LB instead of drop or send to other machines \uff1f\r\n \r\n```\r\n\"In particular, this implies an out-of-band method to communicate server state. If a server was going down for maintenance or at a rate-limit, why wouldn't the server simply close connections and refuse new ones, or use its own flow control? Why not use a Retry service to redirect new connections to a different server\"\r\n```\r\nRate-limit description in PR is not  particularly suitable, as stateless reset is not used to cancel initial packet, but rate-limit almost works in connection created, so I will delete this in PR. \r\nThis reset works for connection already established while server had restarted or other reason lost the state,  so the server  can reset like tcp of cause,  the same to other servers in the cluster, but as stated above I think QUIC LB  should also this ability.\r\n\r\n+ For question (2)(3)(4)(6) ,\u00a0 I think more design detailes can be discussed later ?  Just like firewall and lb's tcp reset can bring security risks, quic lb's reset may also not avoid this risk , but can be designed more carefully.\r\n\r\n+ For question(5),\u00a0 I'm sorry that I  didn't get the point, why reset is version-related, but not retry service?  I think neither reset nor retry, quic version in lb and server needs match. \r\n\r\nWaiting for you reply.\r\n",
          "createdAt": "2021-05-16T13:50:48Z",
          "updatedAt": "2021-05-16T13:50:48Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> \r\n> I agree with this view partially. In the design of a certain function, it is complicated and many things are considered\uff0cbut in terms of the features of the Quic LB itself, I think more can be added?  QUIC LB can do more things for this complicated UDP protocol, more features means necessity but not confusion ?\r\n> \r\n\r\nAt the next meeting, I will ask if there is interest in addressing this use case.\r\n\r\n> ```\r\n> \" To me, stateless reset is an edge case that wouldn't happen all that often and didn't have particularly important benefits to offloading it\"\r\n> ```\r\n> \r\n> The necessity of stateless rest in quic lb can be summarized:\r\n> \r\n>     1. Take the common open source based access network ( client -> lvs -> nginx -> real server)  for example, lvs has the ability to reset unknown tcp packets, in other words, lvs has tcp stack ability.  QUIC-LB  Maybe also needs this ability?  QUIC LB should reset the unkown QUIC packets, but not just drop it. So this is the basic ability,  although it may not wok often, it is essential.\r\n> \r\n>     2. Consider a typical situation where the backend carried in the DCID does not exist or unhealty because of maintenance. This situation is similar to that tcp's session state does not exist in LVS. It should be reset directly by QUIC LB instead of drop or send to other machines?\r\n\r\nI don't think \"DCID [I think you mean server ID?] does not exist\" is a real use case, unless the packet is garbage or an attack, as clients should always use server-generated CIDs in any short header. QUIC-LB can be implemented statelessly, so there is no analogy to the LB not having session state. In fact, if there is no record of a 4-tuple, this generally indicates a NAT rebinding or an address migration, and the connection should definitely NOT be reset.\r\n\r\nIf a server is going down for maintenance, one would think the operator would make an effort to close down existing sessions gracefully (perhaps through HTTP/3 goaway). If the LB simply stops treating that as a valid server ID, there won't be more connections routed there.\r\n\r\n> This reset works for connection already established while server had restarted or other reason lost the state, so the server can reset like tcp of cause, the same to other servers in the cluster, but as stated above I think QUIC LB should also this ability.\r\n> \r\n>     * For question (2)(3)(4)(6) ,  I think more design detailes can be discussed later ?  Just like firewall and lb's tcp reset can bring security risks, quic lb's reset may also not avoid this risk , but can be designed more carefully.\r\n> \r\n>     * For question(5),  I'm sorry that I  didn't get the point, why reset is version-related, but not retry service?  I think neither reset nor retry, quic version in lb and server needs match.\r\n\r\nRetry services are version-dependent, but they act on Initial Packets that encode the version. Stateless Resets operation on 1-RTT packets with no version information.\r\n\r\nFurthermore, while in principle Retry Services can be the same device as the LB, I doubt that will be the case in practice. (I've considered splitting Retry Services into a separate draft for this reason). However, as a \"Reset Service\" would need to understand the state of the server pool, and would usually be part of the load balancer instance. It would therefore introduce version-dependence to a device that is currently roughly version-independent.\r\n",
          "createdAt": "2021-05-20T21:06:25Z",
          "updatedAt": "2021-05-20T21:06:25Z"
        },
        {
          "author": "Lingtaonju",
          "authorAssociation": "NONE",
          "body": "As blocked by something, sorry for the late reply.\r\n\r\n**Firstly :**\r\n> At the next meeting, I will ask if there is interest in addressing this use case.\r\n\r\nGreat, thanks. I am looking forward to the upcoming discussion.\r\n\r\n**Secondly:**\r\n> Retry services are version-dependent, but they act on Initial Packets that encode the version. Stateless Resets operation on 1-RTT packets with no version information.\r\n\r\nGot that.\r\nBut, I think this is the same problem for quic server who should send stateless reset? As this short header packet's version is also unknown for quic server. So, stateless reset should be version-independent?\r\n\r\nAs rfc 9000 says:\r\nThis stateless reset design is specific to QUIC version 1. An endpoint that supports multiple\r\nversions of QUIC needs to generate a Stateless Reset that will be accepted by peers that support\r\nany version that the endpoint might support (or might have supported prior to losing state).\r\nDesigners of new versions of QUIC need to be aware of this and either (1) reuse this design or (2)\r\nuse a portion of the packet other than the last 16 bytes for carrying data.\r\n\r\n**Thirdly:**\r\n> However, as a \"Reset Service\" would need to understand the state of the server pool, and would usually be part of the load balancer instance.\r\n\r\nI tend to think this should be lb's inner function, but not lb's third-party service. This function may be not used often, but should not missing.\r\n\r\n**Fourthly:**\r\n> I don't think \"DCID [I think you mean server ID?] does not exist\" is a real use case, unless the packet is garbage or an attack, as clients should always use server-generated CIDs in any short header.\r\n\r\nYes, I mean DCID is SID here which encoded server info. But my point is , \"the backend or server \" carried in the DCID , doesn't appear in quic_lb's upstream pool. This is the key point for the necessary to introduce reset in quic lb.\r\nAs for the reason why the server info does not exist in lb's upstream pool, this may have many causes, for example the backend is deleted because of unhealty.\r\n\r\n> If a server is going down for maintenance, one would think the operator would make an effort to close down existing sessions gracefully (perhaps through HTTP/3 goaway)\r\n\r\nThis is the graceful method, but for some interupt/ accidents case, reset also needs for quiclb  the same as quic server do.\r\n\r\n\r\n**Finally:**\r\nAs rfc9000 describes in Stateless Reset Oracle:\r\n```\r\n If there is no chance of the packet being routed to the correct\r\ninstance, it is better to send a stateless reset than wait for the connection to time out. \r\n```\r\nI think quiclb should do this but not just drop a packet when quic server(ups) not exists in SID.\r\n\r\n",
          "createdAt": "2021-06-28T03:49:56Z",
          "updatedAt": "2021-06-28T07:29:19Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As I presented at IETF 112, I am leaning towards splitting up the draft into separate LB and Retry documents, as these functions are quite separate. Assuming that this split occurs, I think it makes sense to propose Reset Offload as a separate function and draft.",
          "createdAt": "2021-11-16T21:51:40Z",
          "updatedAt": "2021-11-16T21:51:40Z"
        },
        {
          "author": "Lingtaonju",
          "authorAssociation": "NONE",
          "body": "> \r\n\r\nNice,  in this case,  more offload func can be added.\r\nLooking forward to the next news",
          "createdAt": "2021-11-24T09:23:12Z",
          "updatedAt": "2021-11-24T09:23:12Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing -- stateless reset is out of scope for either draft.",
          "createdAt": "2022-04-07T19:57:47Z",
          "updatedAt": "2022-04-07T19:57:47Z"
        }
      ]
    },
    {
      "number": 121,
      "id": "MDU6SXNzdWU4OTk5MzkxNDE=",
      "title": "Align stream cipher and block cipher formats",
      "url": "https://github.com/quicwg/load-balancers/issues/121",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The clear text stream cipher and block cipher formats are specified as:\r\n```\r\n[B][nonce][server-ID][server-use]\r\n[B][server-ID][server-use]\r\n```\r\nI think that this difference is not necessary. In the block cipher format, the first `16-length_of_sid` bytes are effectively used as a nonce: using the same value and the same server ID would result in the same initial 16 bytes, with exactly the same privacy effect as failing to properly initialize the nonce in the stream-cipher case. I wish we could unify these two formats, to:\r\n```\r\n[B][server-ID][server-use]\r\n```\r\nWith just three parameters:\r\n```\r\n[B][     server-ID      ][     server-use     ]\r\n   <-- length of SID -->\r\n   <--- scope of encryption --->\r\n<--------------- length of CID --------------->\r\n```\r\nThe scope of encryption would be 0 bytes for the clear text format, 16 bytes for the block cipher format, and a value greater than server-ID length and lower than the length of the CID for the stream cipher format. This will of course require that the first bytes of the server-use field act as a nonce. Alternately, we could have:\r\n```\r\n[B][     server-ID      ][ nonce ][ server-use  ]\r\n   <-- length of SID -->\r\n   <---- scope of encryption ---->\r\n<---------------- length of CID ---------------->\r\n```\r\nWhich achieves the same unification result, but is maybe a bit more explicit.\r\n\r\n",
      "createdAt": "2021-05-24T19:22:08Z",
      "updatedAt": "2021-09-23T21:32:57Z",
      "closedAt": "2021-09-23T21:32:57Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this would simplify things, yes. Though it might be worth it to separate the server-use bit into a nonce and server-use, since one has uniqueness constraints and one doesn't.",
          "createdAt": "2021-05-24T19:35:35Z",
          "updatedAt": "2021-05-24T19:35:35Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thinking of that a bit more, it is possible to further simplify. In the case of the stream cipher, the \"nonce\" part cannot be more than 16 bytes long. This means that the nonce will include:\r\n* All of the \"server-use\" bytes if the are fewer than 16 such bytes \r\n* The initial 16 bytes of the \"server use\" field if there are more\r\n```\r\n[B][     server-ID     ][ server-use ]\r\n   <-- length of SID -->\r\n   <------ scope of encryption ------>\r\n<---------- length of CID ----------->\r\n\r\n[B][     server-ID     ][ server-use (> 16B) ]\r\n   <-- length of SID --><-- 16 bytes -->\r\n   <------- scope of encryption ------->\r\n<-------------- length of CID --------------->\r\n```\r\nWith that, for all schemes we will require just two parameters, the length of the SID and the length of the CID. This simplifies configuration and APIs.\r\n\r\nAt that point, the \"nonce\" requirement is not particularly onerous. There is already an operational requirement that CID as a whole be unique -- conflicting values would lead to packets delivered to the wrong context. If we use \"all the bytes\" then the server-use field is effectively a nonce. The requirement only applies to the cases where the server use field is larger than 16 bytes. We can mention it, the same way we should mention it for the block cipher.\r\n\r\nThere is a small technical weakness, because the uniqueness of the CID could also result from the randomness of the first byte. This could be fixed by using the first byte in the encryption passes: use first-byte + server ID when encrypting the nonce if the server ID is fewer than 16 bytes. (Is there really a use case for a 16 bytes server ID? Would 15 bytes be sufficient?)\r\n",
          "createdAt": "2021-05-25T14:59:30Z",
          "updatedAt": "2021-05-25T14:59:30Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like how this is developing.\r\n\r\nI should clarify that the \"CID length\" is actually the minimum length of the CID -- that's all the LB will look at. The server can pad it out to 20B but that's not relevant to the algorithm.\r\n\r\nRegarding the first byte: if using length-self-encoding, there will be little or not entropy there.\r\n\r\nI don't think the case for a 16B SID is compelling.",
          "createdAt": "2021-05-25T15:25:48Z",
          "updatedAt": "2021-05-25T15:25:48Z"
        }
      ]
    },
    {
      "number": 122,
      "id": "MDU6SXNzdWU4OTk5NDUwNTM=",
      "title": "Retry Service SHOULD preserve server ID",
      "url": "https://github.com/quicwg/load-balancers/issues/122",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The Retry Service may not have the necessary state to encode server ID in the CID. But if it does, it SHOULD encode the same server ID in the new CID (assuming one is encoded)",
      "createdAt": "2021-05-24T19:32:01Z",
      "updatedAt": "2021-10-04T18:21:29Z",
      "closedAt": "2021-10-04T18:21:29Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Upon further reflection, there's no reason for this. The only way the CID could be meaningful is if it came from a Retry -- in which case, there can't be another Retry.\r\n\r\nTo have any purpose at all, we have to imagine some future version or extension of QUIC where the server provides CIDs for subsequent connections. A little too speculative, I think.",
          "createdAt": "2021-10-04T18:21:29Z",
          "updatedAt": "2021-10-04T18:21:29Z"
        }
      ]
    },
    {
      "number": 124,
      "id": "MDU6SXNzdWU5MDEzMzk0MjE=",
      "title": "Server resource exhaustion attack with dynamic allocation",
      "url": "https://github.com/quicwg/load-balancers/issues/124",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "With dynamic allocation, the server obtains a new server ID each time it receives a packet with an unknown CID, if the CID passes some minimal checks. This can be easily exploited if an adversary can direct packets to individual servers. Each acceptable CID in incoming packet will be added to the table of server ID, either table pollution, resource exhaustion, or exclusion of valid values.",
      "createdAt": "2021-05-25T20:37:51Z",
      "updatedAt": "2021-10-04T16:47:00Z",
      "closedAt": "2021-10-04T16:47:00Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for filing this issue. #101 is in this space as well.",
          "createdAt": "2021-06-01T16:48:26Z",
          "updatedAt": "2021-06-01T16:48:26Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "closed by #104 ",
          "createdAt": "2021-10-04T16:46:59Z",
          "updatedAt": "2021-10-04T16:46:59Z"
        }
      ]
    },
    {
      "number": 125,
      "id": "MDU6SXNzdWU5NTE5Nzc1MDQ=",
      "title": "Retry Source Connection ID included in token",
      "url": "https://github.com/quicwg/load-balancers/issues/125",
      "state": "CLOSED",
      "author": "nqv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "> Retry Source Connection ID: The server or Retry service copies this from the Source Connection ID of the Retry packet.\r\n\r\nI have read https://github.com/quicwg/load-balancers/issues/31 but still don't understand why we need to include it again in token. I'd thought that that server or retry service can read it from the Initial packet (invariant long header packet).\r\n\r\nWhat happen if they are different? Which one server should take to initiate the connection?\r\n\r\n\r\n",
      "createdAt": "2021-07-24T01:48:57Z",
      "updatedAt": "2021-08-27T20:58:01Z",
      "closedAt": "2021-08-27T20:58:01Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I recommend Section 7.3 of RFC 9000 to understand this:\r\n\r\n\"The values provided by a peer for these transport parameters MUST match the values that an endpoint used in the Destination and Source Connection ID fields of Initial packets that it sent (and received, for servers). Endpoints MUST validate that received transport parameters match received connection ID values.\"\r\n\r\nThe connection IDs in Retry and Initial packets are not effectively authenticated unless they are included in transport parameters, which are included in key computation. If the server doesn't have a trustworthy record of the CID it picked (this token), it has no way of confirming that the Retry's SCID wasn't modified in flight.",
          "createdAt": "2021-07-26T16:14:29Z",
          "updatedAt": "2021-07-26T16:14:29Z"
        },
        {
          "author": "nqv",
          "authorAssociation": "CONTRIBUTOR",
          "body": "yeah, I get that server needs to verify SCID in Retry packet. I still do not get why we need to include Retry SCID again in the token.",
          "createdAt": "2021-07-27T02:42:05Z",
          "updatedAt": "2021-07-27T02:42:05Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "How would it verify the SCID was unchanged if it wasn't in the token?",
          "createdAt": "2021-07-27T17:44:26Z",
          "updatedAt": "2021-07-27T17:44:26Z"
        },
        {
          "author": "nqv",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it'd be authenticated by including in the associated data, i.e\r\n```\r\nShared-State Retry Service Token Pseudoheader {\r\n  IP Address (128),\r\n  Unique Token Number (96),\r\n  Key Sequence (8),\r\n  Retry Source Connection ID (0..160),\r\n}\r\n```",
          "createdAt": "2021-07-29T21:45:07Z",
          "updatedAt": "2021-07-29T21:45:07Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hmm, this is a clever proposal. I'll reopen to reconsider properly.",
          "createdAt": "2021-07-30T01:15:19Z",
          "updatedAt": "2021-07-30T01:15:19Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Trying to wrap my head around this. The server wants to verify that the RSCID is correct, so the current solution is to copy that in the token. If the client messes up, the server compares the value in the token to the value sent by the client.\r\n\r\nYes, putting that in the pseudo header will mostly work. If the client does not use the specified RSCID, the token will just not decode. But there are two potential issues:\r\n\r\n1) Debugging is harder. For example, there will not be any way to differentiate between wrong RSCID and wrong IP\r\n2) If the token came as \"NEW TOKEN\", there is no RSCID specified. There will need to be a special case for constructing the pseudo header, but that means exposing the difference between Retry Token and New Token in clear text.\r\n\r\nIn any case, we would need additional text for the New Token case.\r\n",
          "createdAt": "2021-07-30T19:35:15Z",
          "updatedAt": "2021-07-30T19:35:15Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Christian, good point on (2). The NSS Token already distinguishes the types in cleartext, so perhaps that's not such a big deal. But yes, we'd need to take a bit from the key sequence to indicate the token type.",
          "createdAt": "2021-07-30T21:37:41Z",
          "updatedAt": "2021-07-30T21:37:41Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I filed #128, please take a look.",
          "createdAt": "2021-08-18T21:35:02Z",
          "updatedAt": "2021-08-18T21:35:02Z"
        }
      ]
    },
    {
      "number": 126,
      "id": "MDU6SXNzdWU5NTE5Nzk5OTA=",
      "title": "Same token body structure for Non-Shared-State and Shared-State",
      "url": "https://github.com/quicwg/load-balancers/issues/126",
      "state": "CLOSED",
      "author": "nqv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "At the moment, the token body of those are a bit different:\r\n```\r\nNon-Shared-State Retry Service Token {\r\n  Token Type (1) = 0,\r\n  ODCIL (7) = 8..20,\r\n  RSCIL (8) = 0..20,\r\n  Original Destination Connection ID (64..160),\r\n  Retry Source Connection ID (0..160),\r\n  Opaque Data (..),\r\n}\r\n\r\nShared-State Retry Service Token Body {\r\n   ODCIL (8) = 0..20,\r\n   RSCIL (8) = 0..20,\r\n   [Port (16)],\r\n   Original Destination Connection ID (0..160),\r\n   Retry Source Connection ID (0..160),\r\n   Timestamp (64),\r\n   Opaque Data (..),\r\n}\r\n```\r\nI wonder if we can unify them into one, something like\r\n```\r\nToken Body {\r\n   Token Type (1) = 0,\r\n   ODCIL (7) = 8..20,\r\n   RSCIL (8) = 0..20,\r\n   Original Destination Connection ID (0..160),\r\n   Retry Source Connection ID (0..160),\r\n   Timestamp (64),\r\n   Opaque Data (..),\r\n}\r\n```\r\nI think timestamp should be included for both and Port can be included in Opaque Data if needed?",
      "createdAt": "2021-07-24T02:07:11Z",
      "updatedAt": "2021-07-26T16:19:35Z",
      "closedAt": "2021-07-26T16:19:34Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The timestamp is not needed for non-shared state; the server is not doing any validation, and only needs the fields that it has to put in transport parameters.\r\n\r\nThe port is part of the validation process; for shared-state, both the Retry Service and the server need access to it. It therefore can't be opaque data.",
          "createdAt": "2021-07-26T16:19:34Z",
          "updatedAt": "2021-07-26T16:19:34Z"
        }
      ]
    },
    {
      "number": 127,
      "id": "MDU6SXNzdWU5NTE5ODI0ODY=",
      "title": "Using AEAD IV to build nonce ",
      "url": "https://github.com/quicwg/load-balancers/issues/127",
      "state": "CLOSED",
      "author": "nqv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "> The AEAD nonce, N, is formed by combining the AEAD IV with the 96 bit unique token number. The 96 bits of the unique token number are left-padded with zeros to the size of the IV. The exclusive OR of the padded unique token number and the AEAD IV forms the AEAD nonce.\r\n\r\nWhy do we need to XOR IV to build nonce? I'd thought a nonce ideally would be used only once and having XOR operator here reduce the confidence? I haven't found where suggesting that using IV to build nonce so including a reference here would be great. ",
      "createdAt": "2021-07-24T02:25:09Z",
      "updatedAt": "2021-07-30T01:03:23Z",
      "closedAt": "2021-07-26T16:22:23Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The properties of XOR are such that two unique numbers XORed by the same IV will produce unique results.\r\n\r\nMore importantly, the unique number is transmitted in cleartext. Without a secure component, the IV, the encryption is less secure.",
          "createdAt": "2021-07-26T16:22:23Z",
          "updatedAt": "2021-07-26T16:22:23Z"
        },
        {
          "author": "nqv",
          "authorAssociation": "CONTRIBUTOR",
          "body": "But isn't the IV already used for decrypting/authenticating with AEAD? My question is why is it different to AEAD in QUIC packets which nonce is purely packet number?",
          "createdAt": "2021-07-27T02:33:18Z",
          "updatedAt": "2021-07-27T02:33:18Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the questions!\r\n\r\nThe token key/IV are different from the QUIC packet key/IV, since we don't want the Retry service to read the packets.\r\n\r\nQUIC AEAD does not simply use the packet number. Sec 5.3 of RFC 9001:\r\nThe nonce, N, is formed by combining the packet protection IV with the packet number.",
          "createdAt": "2021-07-27T17:43:16Z",
          "updatedAt": "2021-07-27T17:43:16Z"
        },
        {
          "author": "nqv",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you.",
          "createdAt": "2021-07-30T01:03:23Z",
          "updatedAt": "2021-07-30T01:03:23Z"
        }
      ]
    },
    {
      "number": 129,
      "id": "I_kwDODoD6yc478pYy",
      "title": "Shorten nonce length for SCID",
      "url": "https://github.com/quicwg/load-balancers/issues/129",
      "state": "CLOSED",
      "author": null,
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Way back in #33 , @huitema said that his three-pass algorithm meant that\r\n\r\n> ...it should also be possible to make the nonce bit shorter than the original spec, because we are no more relying on the randomness of the nonce value. Each server could set the nonce to some kind of sequence number, incremented at each CID allocation. The size of the number should be enough to cover all allocations during a CID encryption key epoch, instead of twice that to cover the birthday paradox if using random allocations.\r\n\r\nBut we never really did that: the nonce is in the range 8..16 octets, which is inherited from the original single-pass algorithm.\r\n\r\n@ianswett asked if we could shorten the minimum nonce to 32 bits to reduce overall CID length; if it were, we could support 2^24 servers with an 8-byte CID!\r\n\r\nThis is compelling and we should definitely shorten the nonce to some value. But 32 bits means you need to roll over the keys for every 4 billion CIDs a server issues; given that some QUIC implementations are quite profligate issuing CIDs, is that enough?\r\n\r\nEven another byte would get us to a trillion CIDs while supporting up to 2^16 servers in 8 octets. On the other hand, the config agent can always pick a longer nonce length if the key lifetime is too short. This is how much we want to allow people to do something potentially dumb, so it's a good spot for discussion.",
      "createdAt": "2021-09-23T19:03:30Z",
      "updatedAt": "2021-09-27T19:34:58Z",
      "closedAt": "2021-09-27T19:34:58Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think some flexibility and discussion of the pros and cons here would be very useful.  I think 32 bits is a reasonable min for our use cases, but maybe there's a reason that would cause issues I'm not aware of?\r\n\r\nWe are not profligate issuers of connection IDs and I think we just issue one extra one at any given point in time.",
          "createdAt": "2021-09-23T19:06:36Z",
          "updatedAt": "2021-09-23T19:06:36Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mdukef5 wrote: \"This is compelling and we should definitely shorten the nonce to some value. But 32 bits means you need to roll over the keys for every 4 billion CIDs a server issues; given that some QUIC implementations are quite profligate issuing CIDs, is that enough?\"\r\n\r\nShort answer: yes. Assume a server handles 2,048 connections per second, and allocates 16 CID per connection. That leaves 17 bits, 128K connections, 64K seconds, about 18 hours. \r\n\r\nLong answer: to make that really work, you need a good rollover mechanism. Something like, if the load balancer observes that one server has rolled over, it triggers rollover for all other servers in the pool. ",
          "createdAt": "2021-09-23T21:47:49Z",
          "updatedAt": "2021-09-23T21:47:49Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Most connections need 1 or 2 CIDs, so I think the practical bounds are higher.\r\n\r\nAlso, 2048 connections isn't that much, but 2048 per second is quite a bit based on my experience.",
          "createdAt": "2021-09-23T21:56:49Z",
          "updatedAt": "2021-09-23T21:56:49Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So I wonder if there's an attack that continually changes the DCID it uses, which will cause some servers to issue way more CIDs than usual, thus forcing a rollover inside the normal key management cycle.\r\n\r\nTwo countermeasures: servers SHOULD limit CID issuance to a sensible limit, and (as @huitema says) do a good rollover mechanism.",
          "createdAt": "2021-09-23T22:02:40Z",
          "updatedAt": "2021-09-23T22:02:40Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@huitema on a separate note, are there security implications for (nonce_len < sid_len)? I can't see any, but you would know better than I.",
          "createdAt": "2021-09-23T22:03:20Z",
          "updatedAt": "2021-09-23T22:03:20Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Perhaps I'm over-thinking this, because I'm not sure nonce re-use actually matters here. Assuming that a single server isn't using multiple server IDs, we are essentially encrypting the same plaintext over and over again. So even if the nonce is re-used, that is only amounting to the *exact same* CID being issued again (modulo random bits in the server use field or where the length would go). While this isn't great, as long as it's not done in the same connection, it doesn't provide any useful information to the observer to correlate clients.\r\n\r\nIf the observer is positioned to see all CIDs in use for the server pool, then over long time scales it may observer that two CIDs match, which for QUIC-LB means they were issued by the same server. Thanks to the config rotation bits, it can likely infer that the keys haven't rotated. But that has very little to do with correlating clients, which is the whole point of the document.\r\n\r\nA server that rolls over its connection IDs is going to have to generate new Stateless Reset keys, but this is a totally local operation.\r\n\r\nAm I not thinking about this correctly?",
          "createdAt": "2021-09-23T22:59:05Z",
          "updatedAt": "2021-09-23T22:59:05Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Encryption performs a bijection from the space of tuples <sid_len, nonce> to the space of numbers of size nb_sid*nb_nonce.\r\nI don't see a particular risk in having nonce_len smaller or larger than sid_len.\r\n\r\nThere is a risk in densely using the space of encrypted numbers. look at the decryption size. If an adversary picks a number at random, that number will decrypt to <sid=s, nonce=n>. The shorter the ID, the denser your utilization of the space, the larger the likelihood that the randomly picked \"s\" will correspond to a valid server, and thus the adversary's message hitting a server instead of being dropped at the LB.\r\n\r\nSame goes for the nonce, the adversary has more chances to get lucky if the space of nonces is densely used. But then, decryption will fail and the message will be ignored.\r\n\r\nSo the main issue I see is that randomly creating SID might yield slightly more effective resource-consumption attacks.",
          "createdAt": "2021-09-23T22:59:09Z",
          "updatedAt": "2021-09-23T22:59:09Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Put another way, maybe Sec 11.6 is wrong for QUIC-LB: https://quicwg.org/load-balancers/draft-ietf-quic-load-balancers.html#name-connection-id-entropy\r\n\r\n",
          "createdAt": "2021-09-23T23:01:06Z",
          "updatedAt": "2021-09-23T23:01:06Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The attacker will not be able to directly correlate cid values and servers. Changing one bit in the nonce statistically changes half the bits in the encrypted sid+nonce.",
          "createdAt": "2021-09-23T23:02:51Z",
          "updatedAt": "2021-09-23T23:02:51Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks, can we change to a 32 bit nonce and add some more text about the risks and trade-offs of shorter vs longer nonces?  I feel someone else might be better at the risks/trade-offs bit, but I'll write a PR to change the value.",
          "createdAt": "2021-09-26T09:00:18Z",
          "updatedAt": "2021-09-26T09:00:18Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I already have one to go up on monday\n\nOn Sun, Sep 26, 2021, 02:00 ianswett ***@***.***> wrote:\n\n> Thanks, can we change to a 32 bit nonce and add some more text about the\n> risks and trade-offs of shorter vs longer nonces? I feel someone else might\n> be better at the risks/trade-offs bit, but I'll write a PR to change the\n> value.\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/quicwg/load-balancers/issues/129#issuecomment-927263789>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AF2EYEJ323UT3YFGZJ353D3UD3OK5ANCNFSM5EULESXQ>\n> .\n> Triage notifications on the go with GitHub Mobile for iOS\n> <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>\n> or Android\n> <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.\n>\n>\n",
          "createdAt": "2021-09-26T14:17:19Z",
          "updatedAt": "2021-09-26T14:17:19Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "SG, I'll drop mine then.\n\nOn Sun, Sep 26, 2021 at 10:17 AM martinduke ***@***.***>\nwrote:\n\n> I already have one to go up on monday\n>\n> On Sun, Sep 26, 2021, 02:00 ianswett ***@***.***> wrote:\n>\n> > Thanks, can we change to a 32 bit nonce and add some more text about the\n> > risks and trade-offs of shorter vs longer nonces? I feel someone else\n> might\n> > be better at the risks/trade-offs bit, but I'll write a PR to change the\n> > value.\n> >\n> > \u2014\n> > You are receiving this because you commented.\n> > Reply to this email directly, view it on GitHub\n> > <\n> https://github.com/quicwg/load-balancers/issues/129#issuecomment-927263789\n> >,\n> > or unsubscribe\n> > <\n> https://github.com/notifications/unsubscribe-auth/AF2EYEJ323UT3YFGZJ353D3UD3OK5ANCNFSM5EULESXQ\n> >\n> > .\n> > Triage notifications on the go with GitHub Mobile for iOS\n> > <\n> https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675\n> >\n> > or Android\n> > <\n> https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub\n> >.\n> >\n> >\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/quicwg/load-balancers/issues/129#issuecomment-927313690>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AEZES4PEWYY64CY2ZPAWKWDUD4TPVANCNFSM5EULESXQ>\n> .\n> Triage notifications on the go with GitHub Mobile for iOS\n> <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>\n> or Android\n> <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.\n>\n>\n",
          "createdAt": "2021-09-27T12:44:48Z",
          "updatedAt": "2021-09-27T12:44:48Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On the issue of nonce reuse: I toyed with idea of being permissive about this, but for the record here's why there's a problem:\r\n\r\nAt the extreme, say a server uses an independent nonce counter for each of its connections, so the encrypted bits follow a predictable pattern for CIDs 1..n issued over the life of the connection.\r\n\r\nFirst, if the plaintext bits (first octet and server-use) are the same, we can't demultiplex connections, and everyone will have everyone else's stateless reset tokens. So at a minimum, the server has to keep the overall CID unique.\r\n\r\nBut even it's unique, if the encrypted bits follow this pattern, then a client connected to that server can identify other clients linked to that server.",
          "createdAt": "2021-09-27T16:45:13Z",
          "updatedAt": "2021-09-27T16:45:13Z"
        }
      ]
    },
    {
      "number": 130,
      "id": "I_kwDODoD6yc479KUu",
      "title": "\"server use\" length should be consistent",
      "url": "https://github.com/quicwg/load-balancers/issues/130",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In any given deployment, the server use length should be consistent. \r\n\r\nThe load balancer doesn't strictly need to know what it is, but obviously not doing this will lead to observable correlations.",
      "createdAt": "2021-09-23T22:11:17Z",
      "updatedAt": "2021-10-05T16:52:10Z",
      "closedAt": "2021-10-05T16:52:10Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As we've generalized the concept of a nonce, we should abolish the concept of \"server use\" and make it all a nonce. If the servers need to use the same length to prevent linkability, best to make it part of the configuration.",
          "createdAt": "2021-10-04T19:02:33Z",
          "updatedAt": "2021-10-04T19:02:33Z"
        }
      ]
    },
    {
      "number": 133,
      "id": "I_kwDODoD6yc48G0pv",
      "title": "Fixing Dynamic Allocation once and for all",
      "url": "https://github.com/quicwg/load-balancers/issues/133",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Maybe there's a way to fix all the concern with dynamic allocation (#101, #103, #124) in one fell swoop.\r\n\r\n1. Leverage the much shorter SCCIDs (thanks Ian) to end the goofy way of extracting a server ID from a 8B CID (i.e. pretending it's plaintext)\r\n2. Simply forbid dynamic SIDs with BCCID (as a precursor to eliminating BCCID altogether -- but that's a different issue)\r\n3. Instead of LBs \"learning\" SIDs as we go, just require the LB to have some sort of consistent hashing of server ID -> server. There are lots of ways to do this and it doesn't have to be standardized. \r\n4. Servers continue to learn SIDs as previously. We need to add some language about nonce management -- there is some annoyance associated with incoming random CIDs \"using up\" nonces, but I feel confident there's a way to scale this.\r\n\r\nThis solves both issues:\r\nA. The LB has much less state, just a lightweight, purely internal mapping that the server learns over time through the mechanism.\r\nB. There is no high-availability issue: the backup LB just needs to have the same consistent hash",
      "createdAt": "2021-09-27T17:45:09Z",
      "updatedAt": "2021-09-27T21:34:48Z",
      "closedAt": "2021-09-27T21:34:47Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Nonce management:\r\n1. when learning a new SID, there will be a nonce associated with that CID (even if the nonce is too short, we can just pad it with zeros). This is the start nonce S for that SID.\r\n2. the server keeps track of next nonce N, initialized to S + 1. When N = S, retire the SID for that config\r\n3. If a new client-generated CID comes in with the same SID, there will be a random nonce R. There are two possibilities:\r\n(a) if S < R < N, this has no effect on nonce state variables. Carry on!\r\n(b) otherwise, this a nonce we have to take care not to reuse. Servers may do any of the following:\r\n(i) Set S = R\r\n(ii) Set N = R+1\r\n(iii) Add to a list of unusable nonces",
          "createdAt": "2021-09-27T17:50:49Z",
          "updatedAt": "2021-09-27T17:50:49Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ugh, this doesn't work. When we add a server, or if one goes down and then up again, then there's ambiguity on where to route an SID. The LB can know this and route short headers to both, but that will lead to a storm of stateless resets.\r\n\r\nThe server could use a storm of garbage packets with a given CID to mean that it should retire that SID, as it's a sign there's a double allocation. That is not elegant. Furthermore, there is no real time limit on how long the server would have to double-route, except retiring the config.",
          "createdAt": "2021-09-27T21:34:47Z",
          "updatedAt": "2021-09-27T21:34:47Z"
        }
      ]
    },
    {
      "number": 135,
      "id": "I_kwDODoD6yc48h7i-",
      "title": "Eliminate Dynamic Allocation",
      "url": "https://github.com/quicwg/load-balancers/issues/135",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In light of #103, @huitema's concerns about the framework, and @ianswett's declining interest in implementing, I think it's time to simply eliminate this from the document.",
      "createdAt": "2021-10-04T19:04:20Z",
      "updatedAt": "2021-10-05T17:05:44Z",
      "closedAt": "2021-10-05T17:05:43Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for all the hard work, but sorry to be the cause of it.",
          "createdAt": "2021-10-04T19:06:25Z",
          "updatedAt": "2021-10-04T19:06:25Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed by #139 ",
          "createdAt": "2021-10-05T17:05:43Z",
          "updatedAt": "2021-10-05T17:05:43Z"
        }
      ]
    },
    {
      "number": 138,
      "id": "I_kwDODoD6yc48iK6b",
      "title": "Get rid of Block Cipher CIDs",
      "url": "https://github.com/quicwg/load-balancers/issues/138",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There has quietly been some work on tightening up the QUIC-LB specification. At the moment, we are still short on implementations but I am hearing something might happen soon.\r\n\r\nAnyway, Christian Huitema has made substantial contributions to the security properties of Stream Cipher CID, which allows smallish CIDs, by making it a three-pass algorithm. We still have the \"Block Cipher CID option\" which requires CIDs of at least 17 bytes; AFAICT the only advantage at this point is that it can be decoded with 1 block encryption operation instead of three.\r\n\r\nIn principle, QUIC-LB load balancers can be run with no per-connection state, in which case this would be a per-packet operation. I strongly suspect that real LBs will keep some per-4tuple state, as they do today; if so, this crypto operation only needs to occur once per packet where the 4-tuple is new. If so, the CPU impact is vanishingly small except in a storm of garbage packets.\r\n\r\nSo AFAICT, the use case for Block Cipher is as follows:\r\n- Willing to run one crypto operation per packet/new 4-tuple\r\n- Not OK with doing three crypto operations\r\n- satisfied with 17B + CIDs\r\n\r\nI strongly suspect this does not describe a real implementer, and am inclined to simply delete this in my effort to simplify the design. Nevertheless, I'm taking this to the list in case someone thinks this is an important use case.",
      "createdAt": "2021-10-04T20:15:07Z",
      "updatedAt": "2022-07-06T15:04:04Z",
      "closedAt": "2022-07-06T15:04:04Z",
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am pretty confident about the properties of the stream cipher, but I am not a *cryptographer \u2122*\r\nShould we ask a review from the CFRG?",
          "createdAt": "2021-10-04T21:34:53Z",
          "updatedAt": "2021-10-04T21:34:53Z"
        },
        {
          "author": "tatsuhiro-t",
          "authorAssociation": "NONE",
          "body": "I implemented block cipher cid in my proxy server.  It is a bit sad to hear that it is going to be removed from the spec, but I have no strong opinion to against that.  If it is removed I'll just remove the reference to quic lb spec and call it our own.\r\nThe good thing of block cipher cid is that its implementation is quite easy.  17 bytes cid has good entropy for random bits to manage several cid per connection.",
          "createdAt": "2021-10-05T03:05:24Z",
          "updatedAt": "2021-10-05T03:05:24Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tatsuhiro-t It's not gone yet! At the very least, we're going to do the crypto review.",
          "createdAt": "2021-10-05T04:08:42Z",
          "updatedAt": "2021-10-05T04:08:42Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "FWIW, h2o also uses 17-byte CID backed by AES-ECB.\r\n\r\nOur server-id is 64-bit. While that might sound a bit large, it is good to have some additional space that can be used for detecting broken packets carrying bogus CIDs. Also, we do not retain 4-tuple state for each connection, because we do not want to retain connection state for all the server cluster. Instead, we decrypt CID of each packet.\r\n\r\nOur format is different from what is in QUIC-LB (our design predates the first revision of the draft), so we do not mind support for block ciphers getting removed from the document. I'm just pointing out that there are use cases where block ciphers are sufficient.",
          "createdAt": "2021-10-08T12:47:08Z",
          "updatedAt": "2021-10-08T12:47:08Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kazuho thanks for the field report. While you're not conforming to the standard today, I hope you'll consider h2o servers eventually supporting the standard (at last optionally) so they can be used with migration with commodity load balancers.\r\n\r\nWould the lack of a block cipher make a meaningful difference in your willingness to do so?",
          "createdAt": "2021-10-11T17:16:11Z",
          "updatedAt": "2021-10-11T17:16:11Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> \r\n> \r\n> I implemented block cipher cid in my proxy server. It is a bit sad to hear that it is going to be removed from the spec, but I have no strong opinion to against that. If it is removed I'll just remove the reference to quic lb spec and call it our own. The good thing of block cipher cid is that its implementation is quite easy. 17 bytes cid has good entropy for random bits to manage several cid per connection.\r\n\r\nif you've implemented this, please join the #quic-lb channel and we should do interop once the spec settles down\r\n",
          "createdAt": "2021-10-11T17:17:25Z",
          "updatedAt": "2021-10-11T17:17:25Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "@martinduke Implementing the Stream Cipher CID algorithm is easy for the backend servers.\r\n\r\nIMO the practical concerns are related to load balancers.\r\n\r\nEach of the three-pass AES-ECB operation has dependency on earlier passes. That means that it is impossible to run these passes in parallel. My napkin calculation tells me that the CPU cycles required for running Stream Cipher CID algorithm on each full-sized packet would cost like 30% of decrypting a full-sized packet.\r\n\r\nThere would be at least two ways to mitigate this problem. One is process multiple packets in parallel. The other is cache information, as you've suggested in this issue.\r\n\r\nIf the load balancer developers are happy to accept this complexity (for saving few bytes of CID), then I do not think I have a reason to argue against.",
          "createdAt": "2021-10-11T23:45:35Z",
          "updatedAt": "2021-10-11T23:45:35Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Please don't make decisions now about the cost of three passes. The CFRG review might very well ask us to increase the number of passes, especially if the nonce is something like a counter instead of a random number. Consider for example the usage pattern in which after a key rotation all servers in the cluster set their nonce to exactly 1. In effect, that means we are almost down to two passes, and that may arguably be too few. Or maybe not. Review will tell.\r\n\r\nIf I look at the literature, 3 passes is the absolute minimum for achieving an acceptable level of mixing, but there are papers recommending 5, 6 or even 12 passes.",
          "createdAt": "2021-10-12T00:08:16Z",
          "updatedAt": "2021-10-12T00:08:16Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "@huitema thank you for the caution.\r\n\r\nThen I wonder if we need to decide the fate of block cipher CIDs, before the design of stream cipher CIDs become more stable.",
          "createdAt": "2021-10-12T00:16:30Z",
          "updatedAt": "2021-10-12T00:16:30Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @huitema thank you for the caution.\r\n> \r\n> Then I wonder if we need to decide the fate of block cipher CIDs, before the design of stream cipher CIDs become more stable.\r\n\r\nI am not resolving this issue until the crypto review is complete.",
          "createdAt": "2021-10-12T01:52:53Z",
          "updatedAt": "2021-10-12T01:52:53Z"
        },
        {
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I strongly suspect that real LBs will keep some per-4tuple state, as they do today; if so, this crypto operation only needs to occur once per packet where the 4-tuple is new\r\n\r\nIt's unfortunately that routing by `per-4tuple state` will meet some problems, image this scenario: \r\n```\r\n1. client A setup a connection with quic-server through quic-lb, and a `4tuple state` was set up in quic-lb\r\n2. client A close connection, and `4tuple state` in quic-lb won't be remove immediately\r\n3. A connection migrate happens in client B, and client B use the same ip/port as clientA\r\n4. If quic-lb route packets of client B through `4tuple state`, then connection migration of client B would failed \r\n```\r\n\r\nThe right way SHOULD be that quic-lb route all packets through CID, then the cpu cost can't be avoid, but I still\r\napprove the usage of stream cipher, from a safety point of view.",
          "createdAt": "2021-10-28T08:23:05Z",
          "updatedAt": "2021-10-28T08:23:05Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good point, I'll consider this when I resolve #140.\r\n",
          "createdAt": "2021-10-28T22:01:10Z",
          "updatedAt": "2021-10-28T22:01:10Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "#155 reduced the Block CID (now \"single-pass encryption\") to the special case where nonce_len + sid_len == 16.",
          "createdAt": "2022-02-08T15:34:07Z",
          "updatedAt": "2022-02-08T15:34:07Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Given the work in #155, I'm disinclined to remove this special case. Closing.",
          "createdAt": "2022-07-06T15:04:04Z",
          "updatedAt": "2022-07-06T15:04:04Z"
        }
      ]
    },
    {
      "number": 140,
      "id": "I_kwDODoD6yc48vJ0f",
      "title": "Incoming Stateless Resets",
      "url": "https://github.com/quicwg/load-balancers/issues/140",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Definitely an edge case, but the LB will spray stateless resets everywhere because the CID is random. If the LB tracks fourtuples, though, it shouldn't be a problem.",
      "createdAt": "2021-10-06T18:59:46Z",
      "updatedAt": "2021-12-19T23:01:12Z",
      "closedAt": "2021-12-19T23:01:12Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe make this part of a thing about stateless LBs.",
          "createdAt": "2021-10-06T19:00:31Z",
          "updatedAt": "2021-10-06T19:00:31Z"
        },
        {
          "author": "Lingtaonju",
          "authorAssociation": "NONE",
          "body": "So, what's the plan ?",
          "createdAt": "2021-10-28T08:03:35Z",
          "updatedAt": "2021-10-28T08:03:35Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@william-zk raises an interesting point about stateless LBs in #138.",
          "createdAt": "2021-10-28T22:01:47Z",
          "updatedAt": "2021-10-28T22:01:47Z"
        }
      ]
    },
    {
      "number": 143,
      "id": "I_kwDODoD6yc490LTf",
      "title": "Mismatch the test vector of stream cipher",
      "url": "https://github.com/quicwg/load-balancers/issues/143",
      "state": "CLOSED",
      "author": "Neo-ZK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hi Duke:\r\n    I'm doing the implementation of stream cipher sid, unfortunately, I can't get the same result of the test vector.\r\n\r\nthe test vector I'm trying is shown below :\r\n```\r\nkey 4d9d0fd25a25e7f321ef464e13f9fa3d\r\ncid 1020607efbe82049ddbf3a7c3d9d32604d sid 3c su 32604d\r\n```\r\n\r\nand every step of my implementation is shown below:\r\n```\r\nstep1: server_id_intermediate = encrypted_server_id ^ AES-ECB(key, padded-encrypted-nonce)\r\nencrypted_server_id: 20\r\npadded-encrypted-nonce: 607efbe82049ddbf3a7c3d9d00000000\r\nAES-ECB(key, padded-encrypted-nonce): 25dbfabb48e6b97ad6d90bd0429c8f51\r\nserver_id_intermediate: 05\r\n\r\nstep2: nonce = encrypted_nonce ^ AES-ECB(key, padded-server_id_intermediate)\r\nencrypted_nonce: 607efbe82049ddbf3a7c3d9d\r\npadded-server_id_intermediate: 05000000000000000000000000000000\r\nAES-ECB(key, padded-server_id_intermediate): 5be0397463a73760a01733b18a046c2e\r\nnonce: 3b9ec29c43eeeadf9a6b0e2c\r\n\r\nstep3: server_id = server_id_intermediate ^ AES-ECB(key, padded-nonce)\r\nserver_id_intermediate: 05\r\npadded-nonce: 3b9ec29c43eeeadf9a6b0e2c00000000\r\nAES-ECB(key, padded-nonce): e916401560d59bbdc4bd5d6e0d2e0098\r\nserver_id: ec\r\n```",
      "createdAt": "2021-10-27T07:49:13Z",
      "updatedAt": "2022-02-10T18:39:14Z",
      "closedAt": "2022-02-10T18:39:14Z",
      "comments": [
        {
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To avoid encryption library problem, I have tried c implementation with OpenSSL and python implementation with inner crypto library, all get the same result",
          "createdAt": "2021-10-27T07:51:18Z",
          "updatedAt": "2021-10-27T07:51:18Z"
        },
        {
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Actually, I strongly suggest that we should not use zero-padding, but use #PKCS7(see RFC2315) instead, for reasons below:\r\n1. Zero-padding has never been a standard way in crypto, only some test case will use this way.\r\n2. For some common crypto libraries(such as OpenSSL), #PKCS7 is the default padding mode of AES encryption, implementers have to explicitly disable the internal padding mechanism, and do zero-padding by themselves, which may bring puzzles to implementers",
          "createdAt": "2021-10-27T08:02:34Z",
          "updatedAt": "2021-10-27T08:02:34Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi William,\r\n\r\nPlease note that the latest version of the draft has removed the test vectors. I haven't yet coded the latest version of the algorithm, as I'm waiting for the crypto review to complete. Sorry to waste your time!",
          "createdAt": "2021-10-28T22:06:15Z",
          "updatedAt": "2021-10-28T22:06:15Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Regarding PKCS#7, can you file a PR? I'm open to moving away from zero-padding, especially if it makes it easier to implement.",
          "createdAt": "2021-10-28T22:08:41Z",
          "updatedAt": "2021-10-28T22:08:41Z"
        },
        {
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, I got it, pr is coming, moreover, I'd like to also give another pr about the test vector of stream cipher",
          "createdAt": "2021-10-29T02:23:58Z",
          "updatedAt": "2021-10-29T02:23:58Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Don't bother with test vectors; the Stream Cipher design is not locked right now",
          "createdAt": "2021-10-29T02:29:42Z",
          "updatedAt": "2021-10-29T02:29:42Z"
        },
        {
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Don't bother with test vectors; the Stream Cipher design is not locked right now\r\n\r\nOK",
          "createdAt": "2021-10-29T02:30:59Z",
          "updatedAt": "2021-10-29T02:30:59Z"
        },
        {
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have just make a pr, which almost renew the introduction of stream cipher, please have a look ;-)",
          "createdAt": "2021-10-29T09:59:07Z",
          "updatedAt": "2021-10-29T09:59:07Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks. The stream cipher design is undergoing crypto review, so I'm not taking any action on it until that is complete.",
          "createdAt": "2021-11-16T21:53:31Z",
          "updatedAt": "2021-11-16T21:53:31Z"
        }
      ]
    },
    {
      "number": 147,
      "id": "I_kwDODoD6yc5AATiO",
      "title": "SNI Routing",
      "url": "https://github.com/quicwg/load-balancers/issues/147",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "LBs that are doing SNI routing are a special case.\r\n\r\n(1) If the Initial CID is routable, they can't just take that as good; they have to assume that it was random and inspect the SNI to make a decision. Section 4.1 doesn't allow this, and it should.\r\n\r\n(2) that mode doesn't work for unknown QUIC versions, obviously.\r\n\r\n(3) For QUIC versions the SNI-LB doesn't understand, I think this is the best we can do:\r\na) For QUIC versions it understands, the LB MAY find the SNI. It MAY use the SNI for unroutable CIDs. If a routable CID, it may override the encoded SID if that SID does not correspond to the provided SNI.\r\nb) The QUIC-LB config explicitly states that the LB is doing SNI routing and the versions it supports\r\nc) The server MAY send a TP that means \"next time you connect with me, please use one of the connection IDs I provided in a NEW_CONNECTION_ID frame.\" This may also be useful for some persistence use cases.\r\n\r\nThe worst case is an unsupported version with a randomly generated CID. In this case, the LB will spray it and will only get lucky if it happens to get to the right tenant.\r\n\r\nSec 11.4 may also need a revision here.\r\n\r\nOr maybe SNI routing is just incompatible with version-independent QUIC-LB?",
      "createdAt": "2021-12-07T22:59:51Z",
      "updatedAt": "2021-12-19T23:01:37Z",
      "closedAt": "2021-12-19T23:01:37Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The down side of just saying \"don't do that' is that then SNI Load balancing can't work with version aliasing, which would be sad because VA helps hide the SNI.",
          "createdAt": "2021-12-07T23:50:44Z",
          "updatedAt": "2021-12-07T23:50:44Z"
        },
        {
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> (1) If the Initial CID is routable, they can't just take that as good; they have to assume that it was random and inspect the SNI to make a decision. Section 4.1 doesn't allow this, and it should.\r\n\r\nMaybe specify a unique quic transport param is a better choice?  For a web service, all requests just have same SNI,  help nothing for distinguishing the Initial CID\r\n\r\n",
          "createdAt": "2021-12-08T07:08:14Z",
          "updatedAt": "2021-12-08T07:08:14Z"
        },
        {
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Further more, there is a draft about encrypted client hello(https://datatracker.ietf.org/doc/html/draft-ietf-tls-esni-13)\uff0cif it becomes RFC, maybe LB cannot get information about clientHello or there must be some ways to synchronize the server private-key to LB",
          "createdAt": "2021-12-08T07:11:01Z",
          "updatedAt": "2021-12-08T07:11:01Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Further more, there is a draft about encrypted client hello([https://datatracker.ietf.org/doc/html/draft-ietf-tls-esni-13)\uff0cif](https://datatracker.ietf.org/doc/html/draft-ietf-tls-esni-13)%EF%BC%8Cif) it becomes RFC, maybe LB cannot get information about clientHello or there must be some ways to synchronize the server private-key to LB\r\n\r\nsynchronizing the server private-key is exactly what happens; that is what the \"client-facing server\" is in that draft.",
          "createdAt": "2021-12-08T16:24:24Z",
          "updatedAt": "2021-12-08T16:24:24Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > (1) If the Initial CID is routable, they can't just take that as good; they have to assume that it was random and inspect the SNI to make a decision. Section 4.1 doesn't allow this, and it should.\r\n> \r\n> Maybe specify a unique quic transport param is a better choice? For a web service, all requests just have same SNI, help nothing for distinguishing the Initial CID\r\n\r\nI'm not sure what you're proposing here. My hope is not introduce a regression relative to current capabilities, but it sounds like you're talking about an L7 load balancer that's doing deep packet inspection. If so, that's out of scope for this document.",
          "createdAt": "2021-12-08T16:26:02Z",
          "updatedAt": "2021-12-08T16:26:02Z"
        },
        {
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I'm not sure what you're proposing here. My hope is not introduce a regression relative to current capabilities, but it sounds like you're talking about an L7 load balancer that's doing deep packet inspection. If so, that's out of scope for this document.\r\n\r\nOK, I got it",
          "createdAt": "2021-12-09T02:21:51Z",
          "updatedAt": "2021-12-09T02:21:51Z"
        }
      ]
    },
    {
      "number": 148,
      "id": "I_kwDODoD6yc5ARToQ",
      "title": "Discuss about the linkability issue when using Plaintext CID algorithm.",
      "url": "https://github.com/quicwg/load-balancers/issues/148",
      "state": "CLOSED",
      "author": "Lingtaonju",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hello duke,\r\nIn this issue, I want to discuss whether the Plaintext CID algorithm will bring linkability problem as you described below:\r\n> QUIC-LB is intended to prevent linkability. Attacks would therefore\r\nattempt to subvert this purpose.\r\nNote that the Plaintext CID algorithm makes no attempt to obscure the\r\nserver mapping, and therefore does not address these concerns.\r\n\r\nIn my opinion,  as the host-id is mapped to the **quic server**   but not the  **quic session**, so even with the same host-id in the CID will not bring linkability problem when the cid is not the same except host-id part. \r\n\r\nAs described below in rfc9000, the linkability problem may become possible, as the same CID is used to map to the same **quic session**, so, two client address used the same CID  means that this is a quic migration, from one place to another. \r\n\r\n> Using a stable connection ID on multiple network paths would allow a passive observer to\r\ncorrelate activity between those paths. An endpoint that moves between networks might not\r\nwish to have their activity correlated by any entity other than their peer, so different connection\r\nIDs are used when sending from different local addresses, as discussed in Section 5.1. For this to\r\nbe effective, endpoints\r\n\r\nHowever, the scene described in rfc9000 is not the same with host-id in quic lb's description. Because with the same host id means two session connected to the same quic server, but not the same quic session.\r\n\r\nFor example, two quic connections use the same host-id: 1, but CID differs. And the 4 tuples are <11.0.0.1:123,  33.0.0.1:443> and <22.0.0.1:456,  33.0.0.1:443>,  we can't say that <11.0.0.1:123> and <22.0.0.1:456> come from the same quic client. \r\n\r\nIn other world, when client doing migration the host-ids in CIDs are the same, but the same host-id in CIDs  does not means this comes from the same client. So,  correlate activity does not work with host-id when there are many clients connected to the same server. In this case, plain text algorithm maybe enough.\r\n\r\nThe above are some of my thoughts , do you have some ideas about these? Waiting for your reply. \r\n\r\n\r\n\r\n\r\n",
      "createdAt": "2021-12-13T09:25:43Z",
      "updatedAt": "2021-12-22T16:41:38Z",
      "closedAt": "2021-12-15T20:31:59Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi Ling,\r\n\r\nThis is currently described in Section 2.2, though there's a major editorial rewrite coming that will probably move it into security considerations.\r\n\r\nYou're basically right. In the limit where there are many clients per server, and migrations happening all the time, a visible server ID is not a big deal and PCID would be fine.\r\n\r\nIn the opposite limit, where there is one client connected to the site, migration is very linkable no matter what algorithm you use.\r\n\r\nThe encrypted methods are for situations in between those two extremes. There are no true guarantees of unlinkability, which is how we justify having a plaintext method at all.",
          "createdAt": "2021-12-15T20:31:59Z",
          "updatedAt": "2021-12-15T20:31:59Z"
        }
      ]
    },
    {
      "number": 149,
      "id": "I_kwDODoD6yc5AXvbk",
      "title": "QUIC-LB assumes servers don't migrate",
      "url": "https://github.com/quicwg/load-balancers/issues/149",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "add it to version invariance section",
      "createdAt": "2021-12-14T16:28:18Z",
      "updatedAt": "2021-12-15T20:09:00Z",
      "closedAt": "2021-12-15T20:08:59Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Actually, it doesn't. If the client provides more CIDs, that has no effect on the server-side LB, particularly as it's likely the server has emerged from behind the LB infrastructure with the address change.\r\n",
          "createdAt": "2021-12-15T20:08:59Z",
          "updatedAt": "2021-12-15T20:08:59Z"
        }
      ]
    },
    {
      "number": 153,
      "id": "I_kwDODoD6yc5DCV0t",
      "title": "Short Encrypted CID does not envision plaintext > 15 bytes.",
      "url": "https://github.com/quicwg/load-balancers/issues/153",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The algorithm is clearly written under the assumption that these will add up less to 15; if it doesn't, padding it to 16 (with the index byte) doesn't make any sense.\r\n\r\nIf we're going to keep the Long CID algorithm, it might be easier just to say that for 16 bytes and more, you should just use Long CID. Why not? It would save encryption passes.\r\n\r\nIf we get rid of Long CID, then we'll probably have to rewrite that particular case.",
      "createdAt": "2022-02-04T22:51:58Z",
      "updatedAt": "2022-02-07T16:41:52Z",
      "closedAt": "2022-02-07T16:41:52Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I must have been tired when I filed this, because it's not true.",
          "createdAt": "2022-02-07T16:41:52Z",
          "updatedAt": "2022-02-07T16:41:52Z"
        }
      ]
    },
    {
      "number": 154,
      "id": "I_kwDODoD6yc5DCd78",
      "title": "Simplify Short Connection CID Algorithm",
      "url": "https://github.com/quicwg/load-balancers/issues/154",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There's a lot of needless bitshifting in the current algorithm. When reading from the right, each byte has to be shifted 4 bits and ORed with the neighboring byte, as currently written.\r\n\r\nThere's an easier way.\r\nWhen encrypting side X (= { left, right }) and XORing with side Y.\r\n\r\nSet Y to zero.\r\nSet the index value (= 1..4) in the furthest byte that has been zeroed.\r\nEncrypt to get ciphertext\r\nXOR Y with the bits in the same position as Y.",
      "createdAt": "2022-02-04T23:52:41Z",
      "updatedAt": "2022-02-08T15:31:59Z",
      "closedAt": "2022-02-08T15:31:59Z",
      "comments": []
    },
    {
      "number": 156,
      "id": "I_kwDODoD6yc5DMwX1",
      "title": "Refactor YANG model",
      "url": "https://github.com/quicwg/load-balancers/issues/156",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It would be much clearer if the load balancer and server had separate YANG models, as they have different requirements:\r\n\r\n- A server only needs to track one config at a time, and one server ID.\r\n- A load balancer might simultaneously support three different configs, and needs the entire server ID mapping.",
      "createdAt": "2022-02-08T15:37:14Z",
      "updatedAt": "2022-02-10T19:50:56Z",
      "closedAt": "2022-02-10T19:50:56Z",
      "comments": []
    },
    {
      "number": 157,
      "id": "I_kwDODoD6yc5DMwth",
      "title": "Split out Retry Services",
      "url": "https://github.com/quicwg/load-balancers/issues/157",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The Retry Service and CID encoding parts of this document have very little to do with each other. The only commonality is that they both mediate a relationship with middleboxes.\r\n\r\nSeparate them into two separate drafts.",
      "createdAt": "2022-02-08T15:38:21Z",
      "updatedAt": "2022-03-25T14:41:43Z",
      "closedAt": "2022-03-25T14:41:43Z",
      "comments": []
    },
    {
      "number": 160,
      "id": "I_kwDODoD6yc5DhCKu",
      "title": "All new test vector errors",
      "url": "https://github.com/quicwg/load-balancers/issues/160",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The code had some bugs. Fixing momentarily.",
      "createdAt": "2022-02-11T15:13:56Z",
      "updatedAt": "2022-02-11T19:23:27Z",
      "closedAt": "2022-02-11T19:23:27Z",
      "comments": []
    },
    {
      "number": 162,
      "id": "I_kwDODoD6yc5D0alV",
      "title": "Define minimum interoperability",
      "url": "https://github.com/quicwg/load-balancers/issues/162",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We should specify what subset of possible configurations must be necessary to be compliant. Lots of concerns here to think through and iron out:\r\n\r\nEncryption might be a tough one: given the constraints that lead to the decision whether or not to encrypt, it is easy to imagine encryption-only or plaintext-only devices.\r\n\r\nAs for nonce and SID lengths, a reasonable nominee would be [sid_len = 3; nonce_len = 4].\r\n\r\nIn particular, having nonce_len > 16 bytes is both excessive and inconvenient in terms of expressing the nonce as a 128 bit integer. It is likely that Google quiche will not support nonces that long, for instance.\r\n\r\nRelatedly, a load balancer very concerned about decrypt costs might force single-pass decryption by requiring sid_len + nonce_len = 16 bytes.",
      "createdAt": "2022-02-14T20:35:54Z",
      "updatedAt": "2022-07-11T15:29:04Z",
      "closedAt": "2022-07-11T15:29:04Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After reflection, I don't think there's anything useful to say here",
          "createdAt": "2022-07-11T15:29:04Z",
          "updatedAt": "2022-07-11T15:29:04Z"
        }
      ]
    },
    {
      "number": 164,
      "id": "I_kwDODoD6yc5GfiLR",
      "title": "Second Crypto Review",
      "url": "https://github.com/quicwg/load-balancers/issues/164",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The second crypto review has a lot of suggestions. Thanks to Ga\u00ebtan Leurent and Leo Perrin:\r\n\r\nWe (Ga\u00ebtan and L\u00e9o) have investigated the encryption algorithm used in QUIC to encrypt the connection ID's, namely the AES-based format-preserving encryption scheme in section 5.3.2.\r\n\r\nAs far as we understand, the use of a keyed permutation to encrypt the connection ID makes sense, but there are some issues with the design of the keyed permutation.\r\n\r\n\r\nA connection ID is the concatenation of a nonce and a server_id, each consisting of an integer number of bytes. The concatenation is split into two words of identical length (the length being a multiple of 4 bits but not necessarily of 8). These two halves, say X_L and X_R, are then encrypted using a 4-round Feistel network by repeating the following round function 4 times:\r\n\r\nX_L, X_R = X_R ^ F^K_i(X_L), X_L\r\n\r\nwhere F^K_i is obtained by:\r\n1. expanding its input to be a 128-bit block where the last bits encode the value of i,\r\n2. applying AES_K on the block obtained, and\r\n3. truncating the result to be the same length as X_R and X_L.\r\n\r\nThe latest draft (draft-ietf-quic-load-balancers-12) has two different function for even and odd round (expand_left/expand_right and truncate_left/truncate_right), but this seems unnecessary from a security perspective: the round index i is sufficient to make the functions independent.\r\n\r\nThis scheme can be seen as a simplified variant of FFX [2]. While the overall structure is similar, the QUIC short encryption algorithm has much fewer rounds (4 vs. at least 12), no tweak, and its round function is not explicitly dependent on the length of the input. This could lead to some problems outlined below.\r\n\r\nSuppose that an identical key K is used to encrypt two (server_id,nonce) pairs such that the first one is X_L || X_R and the second is the longer X_L || 0 || X_R || 0, where each 0 is the bit sequence 0000. The second sequence is one byte longer than the first and could correspond e.g. to an identical server_id but a different nonce. In this case, the encryption of the first pair will yield Y_L || Y_R. The encryption of the second pair will be equal to Y_L || 0 || Y_R || 0 provided that each AES encryption has a 0 nibble in the correct position in its output, an event that has probability (2^-4)^4 = 2^-16. Indeed, in both case, the inputs of F^K_i will be identical (see the process outlined above), and thus so will their outputs.\r\n\r\nThis problem is easily mitigated using either of the following approaches.\r\n1. As specified in FFX, have the round function be dependent on the length of X_L. For instance, instead of having an input of the shape X_L || 0^a || i, use X_L || 0^b || length(X_L) || i, where length(X_L) is bit-length of X_L.\r\n2. Use a simple domain separation between the two inputs of F^K_i, namely X_L and i. This can be done using a bit set to 1 in much the same way as what is done in the padding used for SHA-3, so that the input of F^K_i would be X_L || 1 || 0^c || i.\r\n\r\nNote also that a 4-round Feistel network with non-bijective round functions (as is used here) does not offer a very high security level against distinguishing attacks, as explained in [3]. This distinguisher relies on the fact that a 4-round Feistel network maps a difference of (0, d) to (0,d) with a probability higher than expected, which can be detected using about 2^{n/2} inputs with a given difference (where n is the bitlength of a branch, i.e. half of the block size). If the nonces are simply incremented counters, then the difference between two successive plaintexts is equal to (0,1) with probability 1/2, meaning that an attacker should be able to distinguish a set of 2^{n/2+1} connection identifiers corresponding to the same connection.\r\n\r\nThe countermeasure here is simple, and would be inline with using a cipher that is closer to the original FFX: simply use more than 4 rounds.  We suggest using the parameters A2 from the FFX specification, which would result in 12 rounds here (with inputs of at least 32 bits).\r\n\r\nWe also noticed that the definition of expand_left and expand_right are ambiguous: as written, they seem to take an integer as input and to strip the leading zeroes; they should rather take a bit vector of known length as input.\r\n",
      "createdAt": "2022-03-27T21:38:49Z",
      "updatedAt": "2022-07-07T01:11:12Z",
      "closedAt": "2022-04-05T20:54:54Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "#166, #168, and #169 have been filed as specific issues here. Closing with no further action.",
          "createdAt": "2022-04-05T20:54:54Z",
          "updatedAt": "2022-04-05T20:54:54Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A distinguishing attack is a way to say \"this string of bytes that looks random is not random, but is in fact the encryption of some unknown clear text data.\" My first suggestion is to acknowledge that in the security section: \"using only 4 passes does not protected against a distinguishing attack, in which attackers observing a sufficient number of CID can determine that they were encrypted using this scheme, instead of being drawn purely at random. Deployments that are concerned with this attack should use 12 passes.\"\r\n\r\nIn other words, I do not believe that this is a serious concern. Our main concern is, can attackers find out which server ID is encrypted inside the CID. The distinguishing attack does not do that. In fact, doing that would require breaking AES. But sure, we can specify a 12 passes algorithm. And, for the sake of simplicity, I would only specify 4 and 12.",
          "createdAt": "2022-07-07T01:08:07Z",
          "updatedAt": "2022-07-07T01:08:07Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also note that analyzing the first unencrypted first byte of the CID is also a way to determine that our scheme is used, regardless of the number of passes. The distinguishing attack is not all that interesting...",
          "createdAt": "2022-07-07T01:11:12Z",
          "updatedAt": "2022-07-07T01:11:12Z"
        }
      ]
    },
    {
      "number": 165,
      "id": "I_kwDODoD6yc5Gu8hv",
      "title": "Retry Offload might drop second initial",
      "url": "https://github.com/quicwg/load-balancers/issues/165",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There are cases where an offload might send Retry on the second initial but not the first:\r\n- it turns on between the two packets\r\n- it is in a stochastic mode where it doesn't always send Retry\r\n\r\nThere is one failure mode and one degraded performance issue:\r\n1) If the server sends HRR, if the client's response triggers Retry it is likely to blackhole the connection.\r\n2) Under certain conditions, dropping the client's second Initial packet will cause either a client or server PTO. (Specifically, there will be no penalty if the client's 2nd flight has a datagram that (a) does not contain an initial, and (b) contains a HS ACK.)\r\n\r\nWe ought to write this down in the draft. For #1, it might be good practice for servers to send CONNECTION_CLOSE instead of HRR under two conditions:\r\n1) There is no Retry token in the Initial, and\r\n2) Other recent initials contained Retry tokens.",
      "createdAt": "2022-03-30T16:31:37Z",
      "updatedAt": "2022-05-25T19:22:03Z",
      "closedAt": "2022-05-25T19:22:03Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The amplification limit is a problem here. If the client's second flight is one packet, including an Initial, which keeps getting dropped, and the server is at its amplification limit, there is no way for the connection to progress.",
          "createdAt": "2022-04-12T16:42:32Z",
          "updatedAt": "2022-04-12T16:42:32Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "As I mentioned in OR #170, I think we need to handle this via an extension to the QUIC protocol itself. I recommend we define an extension that does the following:\r\n\r\nThe server includes a new transport parameter `initial_token` that contains the value of the initial token that clients should use for any subsequent initial packets they send. If the client understands this extension/TP, it acts accordingly. If it does not, then it may hit the issues you describe in this PR and eventually time out.",
          "createdAt": "2022-05-11T12:46:12Z",
          "updatedAt": "2022-05-11T12:46:12Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So the problem with using a TP is that it isn't delivered until the Encrypted Extensions messages, which is far too late for most of the failure modes here.\r\n\r\nHowever, I've thought more carefully about this and have realized some things.\r\n\r\n1. Offload statefulness doesn't completely solve it, as you could have a shared-state retry where an anti-DDoS service turns on and suddenly has all packets route through it. \r\n\r\n2.  If an offload is going to randomly send Retry while being stateless, it really ought to be pseudorandom based on the address/port or whatever. Therefore, the two Initial packets will get the same treatment in the usual case. That reduces to the problem to \"service turns on mid-handshake\".\r\n\r\n3. Case 1 is where Retry offload breaks the Initial + Handshake flight. This isn't actually a black hole. The client will retransmit handshake packets and, per RFC9001 4.9.1, MUST NOT send Initial packets once it's sent a handshake. So there might be a PTO, which is not ideal, but not catastrophic. In the normal case, there are multiple server handshake packets, and if the client is following spec and not doing ack delay in the handshake, it is unlikely the entire Handshake ACK will be coalesced with Initial. **So let's forget about this \"problem\", and we don't need to do any weird packet truncation as in PR #170.**\r\n\r\n4. Case 2 is HRR or Multi-packet SHLO: this is the harder case as Initial ACKs are critical to progress. HRR is an edge case but post-quantum we may need multi-packet SHLO, and it would be good for this design to be robust to that. I don't see a realistic fix here right now but I'll think about it some more.",
          "createdAt": "2022-05-23T23:33:14Z",
          "updatedAt": "2022-05-23T23:33:40Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "> So the problem with using a TP is that it isn't delivered until the Encrypted Extensions messages, which is far too late for most of the failure modes here.\r\n\r\nCrap. You're obviously totally right. I don't know how I forgot. I still thing the right way to handle this is to somehow give the client the `initial_token` along with the server's initial payload. I might propose a slight modification of my original plan:\r\n\r\nThe client includes a new transport parameter `initial_token` (with no payload) that advertises support for this new extension. If the server supports this extension, it includes a `initial_token` **frame** in all its Initial packets, and then also includes the `initial_token` transport parameter that also contains the value of the initial token (so that it can be securely validated). Clients should use the `initial_token` frame value for any subsequent initial packets they send.",
          "createdAt": "2022-05-24T13:43:50Z",
          "updatedAt": "2022-05-24T13:43:50Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That will work, but I am very skeptical of client support, particularly in Chrome.\r\n\r\nI just reworked things completely with #172. Reasoning about the Handshake is hard, but I think this works pretty well unless the handshake is also suffering losses for reasons other than the Offload dropping stuff.\r\n\r\nBasically, there's a \"transition mode\" when going active where you send Retry and forward the packet to the server anyway. The handshake logic basically works out, which is surprising until you think it through.",
          "createdAt": "2022-05-24T18:16:39Z",
          "updatedAt": "2022-05-24T18:17:44Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "I'm very hesitant to push a solution that doesn't work in **all** scenarios. From some tests I've done in recent past, HRR is a lot more common in some scenarios. Also, post-quantum crypto is coming.",
          "createdAt": "2022-05-25T13:46:42Z",
          "updatedAt": "2022-05-25T13:46:42Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "But this works!",
          "createdAt": "2022-05-25T14:20:24Z",
          "updatedAt": "2022-05-25T14:20:24Z"
        }
      ]
    },
    {
      "number": 166,
      "id": "I_kwDODoD6yc5HJWqs",
      "title": "Index depends on length",
      "url": "https://github.com/quicwg/load-balancers/issues/166",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In the second crypto review (#164) there was a note that plaintexts of different lengths might end up with similar results, if the extra bits were zeros. The suggestion to fix this was to update the path index to also include the length.",
      "createdAt": "2022-04-05T19:37:11Z",
      "updatedAt": "2022-04-26T19:02:19Z",
      "closedAt": "2022-04-26T19:02:19Z",
      "comments": []
    },
    {
      "number": 168,
      "id": "I_kwDODoD6yc5HJn8W",
      "title": "Add crypto review discussion to security considerations",
      "url": "https://github.com/quicwg/load-balancers/issues/168",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "huitema"
      ],
      "labels": [],
      "body": "The analysis in the second crypto review should be in the security considerations.",
      "createdAt": "2022-04-05T20:52:18Z",
      "updatedAt": "2022-07-08T16:03:44Z",
      "closedAt": "2022-07-08T16:03:44Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe there is an edge case where a partially chosen plaintext is possible.\r\n\r\n1) The load balancer is supporting both an encrypted and unencrypted config, on different codepoints, that happen to use the same server ID mapping\r\n2) The server is generating encrypted CIDs.\r\n3) The attacker sends an initial packet sends an unencrypted CID.\r\n4) Any server generated CID is therefore using the unencrypted server ID as plaintext. The random nonce should generally protect us, but maybe not?\r\n\r\nAnyway, security considerations could say something like \"unencrypted and encrypted CIDs MUST NOT use the same server ID assignments because...\".",
          "createdAt": "2022-04-07T19:56:48Z",
          "updatedAt": "2022-04-07T19:56:48Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed by #176",
          "createdAt": "2022-07-08T16:03:44Z",
          "updatedAt": "2022-07-08T16:03:44Z"
        }
      ]
    },
    {
      "number": 169,
      "id": "I_kwDODoD6yc5HJoIS",
      "title": "Make #of passes a parameter",
      "url": "https://github.com/quicwg/load-balancers/issues/169",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "huitema"
      ],
      "labels": [],
      "body": "We're awaiting more data to fully understand this, but we may need to allow 4, 6, or 12 passes as configuration options.",
      "createdAt": "2022-04-05T20:53:11Z",
      "updatedAt": "2022-07-08T16:04:26Z",
      "closedAt": "2022-07-08T16:04:25Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed by #175, but we're instead going to go with #176 in lieu of doing this.",
          "createdAt": "2022-07-08T16:04:25Z",
          "updatedAt": "2022-07-08T16:04:25Z"
        }
      ]
    },
    {
      "number": 171,
      "id": "I_kwDODoD6yc5IbVM-",
      "title": "Rename 4-tuple routing?",
      "url": "https://github.com/quicwg/load-balancers/issues/171",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The '11' codepoint might be better defined. It would be good, for instance, if a stateful load balancer actually stored the observed CID so that the connection can survive a NAT rebinding.",
      "createdAt": "2022-04-25T22:45:20Z",
      "updatedAt": "2022-07-08T18:48:50Z",
      "closedAt": "2022-07-08T18:48:50Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Actually this is a bit harder than we'd like.\r\n\r\nIf the load balancer is stateless, then the short-header processing would have to be based on the destination connection ID to be robust to NAT rebinding. But then, as the connection ID will change mid-handshake, long-header processing needs a different approach. I don't see how, logically, a stateless LB can maintain consistency between these two results unless we force the unconfigured server to retain most of the client-generated CID.",
          "createdAt": "2022-07-06T22:09:36Z",
          "updatedAt": "2022-07-06T22:09:36Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Having reflected on this a bit more, this is what I think we should do:\r\nKeep 0b11 as 4-tuple routing. However Load Balancers MAY observe destination connection IDs and keep state on them, to later survive a NAT rebinding.\r\n\r\nI see two use cases for 0b11: \r\n(1) a general purpose server that always uses QUIC-LB, whether or not it's behind an LB, for simplicity. So when it's not behind a Layer 4 LB it just generates random CIDs except for the first byte. As an added bonus, if there *is* an unknown L4 LB in front of it the behavior will not be pathological, at least until there's a migration. But in general, the rebinding performance is not all that important.\r\n(2) As a panic mode when things are misconfigured or the server has run out of nonces. Again, I'm not sure rebinding performance is super-critical.\r\n\r\nIn other words, if a server is behind an L4 load balancer is and is using 0b11, something has gone very wrong.",
          "createdAt": "2022-07-06T23:09:02Z",
          "updatedAt": "2022-07-06T23:09:02Z"
        }
      ]
    },
    {
      "number": 177,
      "id": "I_kwDODoD6yc5Nc57f",
      "title": "Switching between Server processes",
      "url": "https://github.com/quicwg/load-balancers/issues/177",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Many server architectures have multiple processes. There are many ways to properly route packets between them, but many have severely limited capabilities.\r\n\r\nAdd some non-normative text about options here: run QUIC-LB at the demultiplexer, packet toss, register connection IDs at the demultiplexer, or rewrite the CID with the decrypted one at the LB (which has security limitations)",
      "createdAt": "2022-07-08T20:33:56Z",
      "updatedAt": "2022-07-11T15:32:27Z",
      "closedAt": "2022-07-11T15:32:27Z",
      "comments": []
    },
    {
      "number": 179,
      "id": "I_kwDODoD6yc5Nu-tP",
      "title": "Do you really need the notation extension?",
      "url": "https://github.com/quicwg/load-balancers/issues/179",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "> `x(A..B) y(C..B-len(x))` indicates that `x` can be of any length between `A` and `B`, and `y` can be of any length between `C` and `B` provided that `(len(x) + len(y))` does not exceed `B`.\r\n\r\nThis might be achieved as follows:\r\n\r\n```\r\nOuter {\r\n  Inner (\u03b1..B),  <-- \u03b1 = A + C\r\n}\r\nInner {\r\n  x(A..B),\r\n  y(C..B),\r\n}\r\n```",
      "createdAt": "2022-07-14T02:14:40Z",
      "updatedAt": "2022-10-14T23:11:55Z",
      "closedAt": "2022-10-14T23:11:55Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "I'll should also point out that `\u03b1` there is optional and you can also do:\r\n\r\n```\r\nOuter {\r\n  Inner (..\u03b2),\r\n}\r\nInner {\r\n  x(A..B),\r\n  y(C..D),\r\n}\r\n```\r\n\r\nFor any value of `\u03b2`, though presumably `\u03b2` is at least `max(B, D)`, it could reasonably be any value up to `B+D`.\r\n\r\n",
          "createdAt": "2022-07-14T02:19:14Z",
          "updatedAt": "2022-07-14T02:19:14Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "closed by #207",
          "createdAt": "2022-10-14T23:11:55Z",
          "updatedAt": "2022-10-14T23:11:55Z"
        }
      ]
    },
    {
      "number": 184,
      "id": "I_kwDODoD6yc5Nvjq8",
      "title": "Fallback CIDs",
      "url": "https://github.com/quicwg/load-balancers/issues/184",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "> When using codepoint 0b11, all bytes but the first SHOULD have no larger of a chance of collision as random bytes. The connection ID SHOULD be of at least length 8 to provide 7 bytes of entropy after the first octet with a low chance of collision. Furthermore, servers in a pool SHOULD also use a consistent connection ID length to simplify the load balancer's extraction of a connection ID from short headers.\r\n\r\nI think that I understand what the intent of the randomness text is, but this could be a lot clearer.  I can suggest words for this, but the next part is serious enough that I didn't want to touch this yet.\r\n\r\nIf the load balancer needs to extract the connection ID, then the length needs to be fixed.  Ideally in the specification.  However, the recommended handling for this (4-tuple routing) means that you don't need to make this fixed in a specification, only in a deployment.  You should explain that rather than do rapid arm-waving.\r\n\r\nFWIW, 62 bits of entropy is probably a little bit too light to be practical, but if this doesn't need to be fixed in a specification, then you only need to talk about the probability of collision and the birthday bound.  The number of random bits $|CID|$ determines the odds of collision which is about 0.5 (i.e., way too damned high) at $\\sqrt{|CID|}$.  That all means that you probably want to recommend more than twice as many bits as you would need to assign to the number of connections you might expect to see, plus some margin.  I don't think that 62 bits would be enough for a really big website.  Maybe it is enough to cover those occasional glitches in configuration distribution, but I wouldn't want to be the cause of an outage, so I'd probably add a few extra to be safe.",
      "createdAt": "2022-07-14T06:20:48Z",
      "updatedAt": "2022-10-24T17:25:55Z",
      "closedAt": "2022-10-24T17:25:54Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not quite sure we need to fix the length here. As you said, if it's straight 4-tuple routing the connection ID length doesn't matter at all. If it's storing observed connection IDs in a map, those are first arriving in long header packets that provide the length.\r\n\r\nAs written in the paragraph, having many different lengths in the deployment would be both inefficient and increase linkability, but what's important is that the server pool decides on a length, not that the length is communicated to the LB.\r\n\r\nI would imagine a \"really big website\" would understand the birthday problem and pick a bigger length. A smaller website is probably fine with 8B. I'm not sure I want to write up the birthday paradox in this section, but I'm certainly open to new text that indicates the tradeoffs more explicitly.\r\n\r\n",
          "createdAt": "2022-10-03T22:54:39Z",
          "updatedAt": "2022-10-03T22:54:39Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing, assuming this response was satisfactory?",
          "createdAt": "2022-10-24T17:25:54Z",
          "updatedAt": "2022-10-24T17:25:54Z"
        }
      ]
    },
    {
      "number": 188,
      "id": "I_kwDODoD6yc5Nvoe_",
      "title": "Define the fields in ",
      "url": "https://github.com/quicwg/load-balancers/issues/188",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "In (Section 4.1](https://quicwg.org/load-balancers/draft-ietf-quic-load-balancers.html#name-cid-format), these fields are not defined:\r\n```\r\nQUIC-LB Connection ID {\r\n    First Octet (8),\r\n    Server ID (8..152-len(Nonce)),\r\n    Nonce (32..152-len(Server ID)),\r\n}\r\n```\r\n\r\nThey probably should be.",
      "createdAt": "2022-07-14T06:42:56Z",
      "updatedAt": "2022-10-05T21:10:00Z",
      "closedAt": "2022-10-05T21:10:00Z",
      "comments": []
    },
    {
      "number": 189,
      "id": "I_kwDODoD6yc5NvoxF",
      "title": "Handover",
      "url": "https://github.com/quicwg/load-balancers/issues/189",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "> Alternately, if the old server is going offline, the load balancer could simply map its server ID to the new server's address.\r\n\r\nThis only works if the cutover is immediate.  \"going offline\" suggests something progressive, which means that this strategy only works if you suddenly start holding a bunch of state.  There a lots of caveats here, to the point that I'd probably just drop this whole paragraph.",
      "createdAt": "2022-07-14T06:44:17Z",
      "updatedAt": "2022-10-05T16:54:04Z",
      "closedAt": "2022-10-05T16:54:04Z",
      "comments": []
    },
    {
      "number": 192,
      "id": "I_kwDODoD6yc5NvvSL",
      "title": "\"appear to be random\"",
      "url": "https://github.com/quicwg/load-balancers/issues/192",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "https://xkcd.com/221/ is probably not your intent, but that is what you get with this phrasing.  I think that the point is that the values are not predictable to entities other than the one generating it.  This appears in several places in the document.",
      "createdAt": "2022-07-14T07:11:43Z",
      "updatedAt": "2022-10-05T20:05:02Z",
      "closedAt": "2022-10-05T20:05:02Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well https://www.rfc-editor.org/rfc/rfc9000.html#name-stateless-reset uses \"indistinguishable from random\" :-)\r\n\r\nBut OK, I'll seek a new formulation.",
          "createdAt": "2022-10-03T23:58:06Z",
          "updatedAt": "2022-10-03T23:58:06Z"
        }
      ]
    },
    {
      "number": 193,
      "id": "I_kwDODoD6yc5NvvlM",
      "title": "Is it really a nonce?",
      "url": "https://github.com/quicwg/load-balancers/issues/193",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The nonce part of the CID is really a server _endpoint_ identifier, isn't it?",
      "createdAt": "2022-07-14T07:12:53Z",
      "updatedAt": "2022-10-24T17:26:06Z",
      "closedAt": "2022-10-24T17:26:05Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It _can_ be, in part, an identifier, but I don't think that's a useful way to think about it.\r\n\r\nAn individual server thread will have, from its perspective, a server ID that is totally unique. The connection IDs generated by that thread are unique only because they have different nonce inputs. It's possible, I suppose, for individual connections to be allocated part of the nonce space and use the decrypted connection ID (and nonce) to deliver it to the correct context. But that seems unlikely when the server thread could just maintain a Connection ID map.\r\n\r\nFrom the load balancer's perspective, the server ID might be somewhat shorter (not encompassing any server ID bits related to threads, etc and irrelevant to the LB's routing decision). In this case, part of the nonce is indeed identifying these later parts of the routing hierarchy.\r\n\r\nSo in my conception of this, the decrypted nonce contains no usable information. Its only purpose is to ensure that each ciphertext is unique.\r\n\r\ndoes that help?",
          "createdAt": "2022-10-03T20:48:45Z",
          "updatedAt": "2022-10-03T20:48:45Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing, assuming this response was satisfactory?",
          "createdAt": "2022-10-24T17:26:05Z",
          "updatedAt": "2022-10-24T17:26:05Z"
        }
      ]
    },
    {
      "number": 194,
      "id": "I_kwDODoD6yc5Nvw0d",
      "title": "Extra bytes",
      "url": "https://github.com/quicwg/load-balancers/issues/194",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "> The server MAY append additional bytes to the connection ID, up to the limit specified in that version of QUIC, for its own use. \r\n\r\nThis is not particularly clear.  If there is an encoded length, presumably this needs to fit within that.  Or does it?  I believe that as long as the length identifies the portion of the connection ID that the load balancer needs to look at (i.e., the server ID or the encrypted part that contains the server ID) the connection ID could be longer than the indicated length and this would still work.\r\n\r\n> These bytes MUST NOT provide observers with any information that could link two connection IDs to the same connection, client, or server. In particular, all servers using a configuration MUST consistently add the same length to each connection ID, to preserve the linkability objectives of QUIC-LB. \r\n\r\nI think that the reason you add the same length is because RFC 9000 requires it.  It does that because otherwise it would be impossible to know where the connection ID ends for a short header because it lacks a length field.  It has nothing to do with linkability.",
      "createdAt": "2022-07-14T07:17:54Z",
      "updatedAt": "2022-10-24T17:26:47Z",
      "closedAt": "2022-10-24T17:26:47Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If the LB is configured to look at, for example, the first 17 bytes of a connection ID, it really doesn't matter if the server chooses to use 17, 18, 19, or 20 byte connection IDs. As you say, in a short header the LB can't even discern that the later bytes are part of the connection ID.\r\n\r\nI don't see any point in RFC 9000 the prohibits a server sometimes issuing 17B CIDs on some connections and 18B connection IDs on some other ones. The only problem is if this differs by backend server, in which case it serves as a linkability vector.\r\n\r\nMaybe this is unclear and can be reworded?",
          "createdAt": "2022-10-03T20:53:04Z",
          "updatedAt": "2022-10-03T20:53:04Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing, assuming this response was satisfactory?",
          "createdAt": "2022-10-24T17:26:47Z",
          "updatedAt": "2022-10-24T17:26:47Z"
        }
      ]
    },
    {
      "number": 195,
      "id": "I_kwDODoD6yc5NvxCn",
      "title": "Citation for AES-128-ECB",
      "url": "https://github.com/quicwg/load-balancers/issues/195",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This needs a normative reference.  There is likely a NIST SP with a number you can use somewhere.",
      "createdAt": "2022-07-14T07:18:49Z",
      "updatedAt": "2022-10-05T20:09:05Z",
      "closedAt": "2022-10-05T20:09:05Z",
      "comments": []
    },
    {
      "number": 196,
      "id": "I_kwDODoD6yc5Nvxzn",
      "title": "The Feistel network would benefit from a picture",
      "url": "https://github.com/quicwg/load-balancers/issues/196",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "A lot.",
      "createdAt": "2022-07-14T07:21:45Z",
      "updatedAt": "2022-10-24T17:15:52Z",
      "closedAt": "2022-10-24T17:15:52Z",
      "comments": []
    },
    {
      "number": 197,
      "id": "I_kwDODoD6yc5Nv0fA",
      "title": "The description of encryption could be improved",
      "url": "https://github.com/quicwg/load-balancers/issues/197",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Several problems here:\r\n* A lot of the description relies on examples rather than normative language.\r\n* The split of a CID that has an odd length produces HEX sequences with an odd number of characters, which in many circumstances will be interpreted as being (left-)padded with 4 zero bits.  If that happened, then bad things would occur.  You really need to retain the number of bits.\r\n* Step 3 passes two arguments to `expand_left`, when it has three.\r\n* The encryption doesn't bind to the configuration that is in use; instead the high bits of the first octet are set to 0.\r\n* The formatting of the operations wraps awkwardly.\r\n* The operators that this uses (^ and || primarily) aren't defined.\r\n* The third input to `expand_{left|right}` seems to increment without explanation.\r\n\r\nGiven the examples, I could no doubt work this all out satisfactorily, but that shouldn't be necessary.",
      "createdAt": "2022-07-14T07:32:08Z",
      "updatedAt": "2022-10-24T17:16:10Z",
      "closedAt": "2022-10-24T17:16:10Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed by #208",
          "createdAt": "2022-10-24T17:16:10Z",
          "updatedAt": "2022-10-24T17:16:10Z"
        }
      ]
    },
    {
      "number": 198,
      "id": "I_kwDODoD6yc5Nv1vg",
      "title": "Server actions and load-balancer actions may not be right",
      "url": "https://github.com/quicwg/load-balancers/issues/198",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "When encrypting, you usually have an encryption routine and a decryption routine.  This doesn't.  The server apparently doesn't decrypt.  Maybe it just remembers the value it got, but you should say that.\r\n\r\nI would define encryption and decryption routines, then explain a few optimizations:\r\n\r\n1. The server can remember connection IDs (it has to remember lots of other stuff, so this is no big deal) so it doesn't need to do any decryption.\r\n2. The load balancer can stop one step short of the full decryption routine if it only needs what is in the left-hand piece.\r\n\r\nThis is probably a better basis then for talking about the extension stuff, like where the server ID is a process ID or there are multiple layers of routing going on. ",
      "createdAt": "2022-07-14T07:37:04Z",
      "updatedAt": "2022-10-06T00:48:35Z",
      "closedAt": "2022-10-06T00:48:35Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure I understand.\r\n\r\n1) Remembering issued connection IDs (or somehow recovering the context?) is already an RFC9000 requirement, so I'm not sure what else needs to be said here.\r\n\r\n2) This is already in Sec 4.4.2\r\n\r\nYou've put your finger on the fact that this is a one-way communication channel from server to load balancer. That's somewhat useful to understanding the security properties, but I'm not sure what kind of change would scratch your itch.\r\n\r\n",
          "createdAt": "2022-10-04T00:42:01Z",
          "updatedAt": "2022-10-04T00:42:01Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "Let me try again: you don't describe how a LB might recover the information that a server encrypts.  This might be OK (for the stated reasons), but not always.",
          "createdAt": "2022-10-05T02:16:48Z",
          "updatedAt": "2022-10-05T02:16:48Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "isn't this Section 4.4? I'm not sure what you're getting at.",
          "createdAt": "2022-10-05T20:10:46Z",
          "updatedAt": "2022-10-05T20:10:46Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "OK, I have no idea what I was originally thinking now.  There are routines in 4.4.x (maybe not very precise ones, but I can understand them).  Maybe just let this one go.",
          "createdAt": "2022-10-05T23:43:21Z",
          "updatedAt": "2022-10-05T23:43:21Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": ":-)",
          "createdAt": "2022-10-06T00:48:35Z",
          "updatedAt": "2022-10-06T00:48:35Z"
        }
      ]
    },
    {
      "number": 199,
      "id": "I_kwDODoD6yc5Nv2Sg",
      "title": "What is \"reasonable\" here?",
      "url": "https://github.com/quicwg/load-balancers/issues/199",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "> The QUIC-LB algorithms do prevent the linkage of two connection IDs to the same individual connection if servers make reasonable selections when generating new IDs for that connection.\r\n\r\nI would think that you instead want to say if the nonce part is chosen in a manner that is unpredictable to the adversary, or encrypted.",
      "createdAt": "2022-07-14T07:39:12Z",
      "updatedAt": "2022-10-18T20:10:23Z",
      "closedAt": "2022-10-18T20:10:23Z",
      "comments": []
    },
    {
      "number": 200,
      "id": "I_kwDODoD6yc5Q644T",
      "title": "Using expand-left and expand-right has undesirable properties",
      "url": "https://github.com/quicwg/load-balancers/issues/200",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Stefan Kolbl points out this problem with the 4-pass method:\r\n\r\n> The algorithm computes expand_left(left_0, cid_len, 1) and in the next round expand_right(right_1, cid_len, 2). Now, (especially for smaller domains) it can happen that the two round functions in the Feistel encrypt the same block:\r\n> If left_0 = 0x0202 this would give you expand_left(0x0202, 0x02, 0x01) = 0x02020000000000000000000000000102\r\n> Now in the next round, if right_1 = 0x0102, you would get expand_right(0x0102, 0x02, 0x02) = 0x02020000000000000000000000000102, encrypting the same block.\r\n> This seems like a quite bad property to have.\r\n\r\nIndeed, there are ways to avoid ugly and error-prone bit shifting while avoiding this property. In particular, we can always use expand-left, but just padding odd-bytes with zeros to preserve byte boundaries and avoid bit-shifting.",
      "createdAt": "2022-08-31T16:57:50Z",
      "updatedAt": "2022-10-24T17:16:25Z",
      "closedAt": "2022-10-24T17:16:25Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed by #208 ",
          "createdAt": "2022-10-24T17:16:24Z",
          "updatedAt": "2022-10-24T17:16:24Z"
        }
      ]
    },
    {
      "number": 201,
      "id": "I_kwDODoD6yc5SfRfP",
      "title": "Inconsistent use of DCID and Server ID",
      "url": "https://github.com/quicwg/load-balancers/issues/201",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The current draft uses DCID half the time and Server ID the other half the time.\r\nIt should pick one and be consistent.  (It would also help to have some introduction\r\nearly on that explains the three components of the CID:  the first octet, the Server ID, and the nonce.)",
      "createdAt": "2022-09-23T14:55:53Z",
      "updatedAt": "2022-10-14T23:10:11Z",
      "closedAt": "2022-10-14T23:10:11Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "DCID and Server ID are different concepts!\r\n\r\nThe Destination Connection ID is the full connection ID addressed to the server.\r\n\r\nThe Server ID, as you state, is a part of that connection ID",
          "createdAt": "2022-10-03T20:57:48Z",
          "updatedAt": "2022-10-03T20:57:48Z"
        }
      ]
    },
    {
      "number": 209,
      "id": "I_kwDODoD6yc5UjeLl",
      "title": "Thread Demultiplexing with keyed hash",
      "url": "https://github.com/quicwg/load-balancers/issues/209",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Add this to the list of suggestions",
      "createdAt": "2022-10-21T16:27:13Z",
      "updatedAt": "2022-10-24T17:25:28Z",
      "closedAt": "2022-10-24T17:25:28Z",
      "comments": []
    },
    {
      "number": 211,
      "id": "I_kwDODoD6yc5Uk02e",
      "title": "Restore text about the continuum of privacy",
      "url": "https://github.com/quicwg/load-balancers/issues/211",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There used to be text about the limits of fighting linkability at the QUIC layer. Restore it.",
      "createdAt": "2022-10-21T22:59:34Z",
      "updatedAt": "2022-10-21T23:40:29Z",
      "closedAt": "2022-10-21T23:40:29Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed by https://github.com/quicwg/load-balancers/commit/3acd8181c3a983f5e95fce075f0a234915b17b05",
          "createdAt": "2022-10-21T23:40:29Z",
          "updatedAt": "2022-10-21T23:40:29Z"
        }
      ]
    },
    {
      "number": 215,
      "id": "I_kwDODoD6yc5p2T-W",
      "title": "Expand to 3 Config ID bits",
      "url": "https://github.com/quicwg/load-balancers/issues/215",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Today, the draft has two bits reserved to identify the config (usually just the specific key) used to encrypt the routing information, with one codepoint reserved for 5-tuple routing (i.e. the connection ID was generated without an active config). This leaves 3 codepoints to support key rotation.\r\n\r\nAfter a long discussion with people running a very large fleet of servers, there is concern that 3 codepoints are not enough, and that there should be seven (3 bits) instead. In a large deployment, some servers being badly out of sync is rare but not unheard of. Worse yet, this likely results in a black hole.\r\n1) Client first flight has random CID1, which is unroutable, so the load balancer uses some arbitrary f(CID1).\r\n2) Server generates a CID2 with an badly outdated config, which is used in the client's second flight\r\n3) The Load Balancer uses the correct key for the codepoint, which is not the key the server used. It is likely unroutable, so the load balancer applies f(CID2) and almost certainly gets a different result.\r\n4) The new server sees an undecryptable long header packet. At best, it can send a stateless reset and the client already received the stateless reset token. If the client does not have the token, or the server does not send stateless reset, the client will black hole: it has received a first flight from the server, and no further packets.\r\n\r\nGoing to three bits has a couple of downsides:\r\n1) Length self-encoding is limited to 32 byte connection IDs instead of 64. This is not an issue with existing QUIC (limited to 20 bytes) but if some future version has larger connection IDs with post-quantum keys, this is a problem, if a highly speculative one.\r\n2) Having more codepoints can encourage insecure behavior. In particular, a CDN with multiple customers behind an IP address can assign different codepoints and keys to each customer's servers. This would easily identify the target customer of any packet and largely neuter the benefits of ECH.",
      "createdAt": "2023-06-26T23:41:45Z",
      "updatedAt": "2023-08-02T20:15:53Z",
      "closedAt": "2023-08-02T20:15:53Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "Regarding the concern I do no think they are significant, due to the following reasons:\r\n* I do not expect CDNs to implement capabilities for supporting just 7 customers.\r\n* ECH is about hiding a tree in the forest, difference of 1 bit should not cause problems. If it does, that is either a problem of ECH or the deployment being too small.",
          "createdAt": "2023-07-25T18:12:48Z",
          "updatedAt": "2023-07-25T18:12:48Z"
        }
      ]
    },
    {
      "number": 221,
      "id": "I_kwDODoD6yc55tGah",
      "title": "Version 17 on datatracker.ietf.org seems old",
      "url": "https://github.com/quicwg/load-balancers/issues/221",
      "state": "CLOSED",
      "author": "nemethf",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Looking at https://datatracker.ietf.org/doc/html/draft-ietf-quic-load-balancers it seems the current version (draft-ietf-quic-load-balancers-17) is old.  I.e., the [Change Log](https://datatracker.ietf.org/doc/html/draft-ietf-quic-load-balancers#name-change-log) of  [Appendix E. ](https://datatracker.ietf.org/doc/html/draft-ietf-quic-load-balancers#appendix-E)  lists changes only from  v13, whereas v16 lists changes compared to v15 and v14 as well.   V17 does not contain the ascii figure either.  \r\n\r\nThanks",
      "createdAt": "2023-12-14T14:51:58Z",
      "updatedAt": "2024-01-19T18:02:08Z",
      "closedAt": "2024-01-19T18:02:08Z",
      "comments": []
    },
    {
      "number": 222,
      "id": "I_kwDODoD6yc57tLjv",
      "title": "Tweak the expand() function again to reduce copying",
      "url": "https://github.com/quicwg/load-balancers/issues/222",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I've discovered that the copying involved in the 4-pass algorithm may be a non-negligible part of the total decrypt time.\r\n\r\nWe can eliminate some of the copying in 4 pass by putting the length and index fields at the end of the output of expand, e.g.\r\n\r\nOLD\r\nexpand(0x484848, 7, 1) = (0x07, 0x01, 0x48, 0x48, 0x48, ....)\r\nNEW\r\nexpand(0x484848, 7, 1) = (0x48, 0x48, 0x48, .... 0x07, 0x01)\r\n\r\nin the likely case where server_id_len < nonce_len, this means that the decoder can just pass server_id_len bytes of left_1 to the caller, rather then copying it into a new buffer.",
      "createdAt": "2024-01-11T00:11:30Z",
      "updatedAt": "2024-02-05T20:30:32Z",
      "closedAt": "2024-02-05T20:30:32Z",
      "comments": []
    },
    {
      "number": 227,
      "id": "I_kwDODoD6yc6C8xCQ",
      "title": "There is an error in the encryption example .",
      "url": "https://github.com/quicwg/load-balancers/issues/227",
      "state": "CLOSED",
      "author": "nandsky",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "detail: #226 ",
      "createdAt": "2024-03-20T08:45:15Z",
      "updatedAt": "2024-03-26T18:20:24Z",
      "closedAt": "2024-03-26T18:20:24Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed via #226 and #228",
          "createdAt": "2024-03-26T18:20:21Z",
          "updatedAt": "2024-03-26T18:20:21Z"
        }
      ]
    },
    {
      "number": 229,
      "id": "I_kwDODoD6yc6KtgA_",
      "title": "DCID defintion",
      "url": "https://github.com/quicwg/load-balancers/issues/229",
      "state": "CLOSED",
      "author": "zaheduzzaman",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/quicwg/load-balancers/blob/cd03bab419f180a3d287aec85b82ce03ef24d471/draft-ietf-quic-load-balancers.md?plain=1#L254-L256\r\n\r\nDCID need to be defined. Also the use of first 2 bits to multiplex DCIDs is not explaied in section 2.1.",
      "createdAt": "2024-05-31T07:51:18Z",
      "updatedAt": "2025-02-28T22:06:58Z",
      "closedAt": "2025-02-28T22:06:58Z",
      "comments": []
    },
    {
      "number": 230,
      "id": "I_kwDODoD6yc6MmomS",
      "title": "Allow fallback algorithms to parse known QUIC versions ",
      "url": "https://github.com/quicwg/load-balancers/issues/230",
      "state": "CLOSED",
      "author": "thynson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Usually, the DCID in the Initial Packet is chosen by the clients with a random value, the current QUIC-LB draft does not mention much about it.\r\n\r\nIt would be great if the final RFC allowed that, in certain deployments, the clients and the load balancers may assume the DCID of Initial Packets are in a particular format so that some routing strategy can be applied, as long as the DCID is unpredictable with at least 64 bits random entropy, thus not weaken the requirements in section 7.2 of RFC9000.\r\n\r\nFor example, the client may construct the DCID of the initial packet with a hashed client identifier and a random nonce of 8 bytes, and the load balancers will route the initial packets based on the hashed client identifier if the DCID is in a recognized format, otherwise fallback to the way how the unroutable CID is handled. Of course, such construct comes with security concerns, and probably should be encrypted, e.g. in the same way as how the routable CID is encrypted, with a key that needs to be exchanged/negotiated out of bands.",
      "createdAt": "2024-06-18T05:25:41Z",
      "updatedAt": "2025-02-28T22:03:42Z",
      "closedAt": "2025-02-28T22:03:42Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for filing the issue!\n\nThe spec assumes that client-generated connection IDs are random, and Section 3.1 is all about how to handle it.\n\nAdding client coordination to the operating model is a major expansion of scope. Allowing clients to control backend routing introduces security concerns well beyond what can be resolved with encryption.\n\nFurthermore, special rules for Initial Packets introduces version dependence in a way that is unsatisfactory (See Sec. 7).\n\nAdding new rules for unroutable DCIDs due to an alternate structure to client-generated connection IDs requires only modest changes to QUIC-LB, and I would very much prefer that they go in a separate draft that modifies the sections about unroutable DCID handling.\n\nI'm closing this with no action. If there is significant interest on the mailing list to make this happen, I'd be willing to reconsider.",
          "createdAt": "2025-02-11T19:10:18Z",
          "updatedAt": "2025-02-11T19:10:18Z"
        },
        {
          "author": "thynson",
          "authorAssociation": "NONE",
          "body": "Thanks for the reply. \n\nWe're fine with this decision, as in our deployment, both client, server and balancer are under controlled. \n\nAnd it seems to me that [Section 3.2. Fallback Algorithms] already allowed us to do so, except there is something we violate but, and as a feedback, we would like to propose to change/fix. \n\nSince in our implementation we treat Initial Packet differently, effectively it violates\n\n> A fallback algorithm MUST NOT make the routing behavior dependent on\n   any bits in the first octet of the QUIC packet header, except the\n   first bit, which indicates a long header.\n\nwhile the type of packets is something version specific. \n\nMeanwhile, In [7.  Version Invariance of QUIC-LB], \n\n> Some load balancers might inspect version-specific elements of\n   packets to make a routing decision.  This might include the Server\n   Name Indication (SNI) extension in the TLS Client Hello.\n\nSo I think Section 3.2 should be fixed to make it consist.",
          "createdAt": "2025-02-12T10:27:13Z",
          "updatedAt": "2025-02-12T10:29:01Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that this could be better written. Reopening.",
          "createdAt": "2025-02-12T17:19:35Z",
          "updatedAt": "2025-02-12T17:19:35Z"
        }
      ]
    },
    {
      "number": 231,
      "id": "I_kwDODoD6yc6ppDe2",
      "title": "Add more considerations for server processes/threads.",
      "url": "https://github.com/quicwg/load-balancers/issues/231",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In Sec 6.2 \n \n- First, replace \"processes\" with \"processes or threads\".\n\n- Second, the secure hash method really needs to have the thread ID appended to the server ID. Otherwise, different processes/threads will generate the same cipher text.",
      "createdAt": "2025-02-11T17:59:13Z",
      "updatedAt": "2025-02-28T22:07:17Z",
      "closedAt": "2025-02-28T22:07:17Z",
      "comments": []
    },
    {
      "number": 235,
      "id": "I_kwDODoD6yc6sI-vS",
      "title": "Tensions between Fallback algorithms and 0b111 routing.",
      "url": "https://github.com/quicwg/load-balancers/issues/235",
      "state": "OPEN",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "When LBs are missing config that servers are using, connections will drop. Sec 2.1 says LBs SHOULD have a superset of active server configs; consider escalating this to a MUST (or have a SHOULD with strong warnings).\n\nAssume that everyone has config. Sec 2.2 says that 0b111 CIDs are always routable and MUST be routed by 4-tuple. Thus, for the 1/8 of connections where the client happens to pick a 0b111 CID, any SNI-based routing will fail. This is suboptimal, especially since it applies to the main case where everyone has config.\n\n**Recommendation**: Update 2.2 to add an exception for the SNI thing.\n\nIf the server doesn't have a config, 0b111 CIDs are going to work less well:\n\n1) If the fallback algorithm is purely 4-tuple based, things will work fine (until there is a NAT rebinding or migration, which is expected). The 0b111 codepoint will cause the LB to pass later packets consistently.\n\n2) If the fallback algorithm uses any other information, the 0b111 CID will be misrouted, as different logic is being applied to both.\n\nIt's not clear what to do about this. Some observations:\n\na) If the LB doesn't have config, the servers don't either. In Sec 2, it should say that LBs with no config should just 4-tuple route.\n\nb) If the LB has config, it has no way of knowing that the server it routes to is going to generate 0b111, putting us in the dilemma above.\n\nc) If the server keeps a table of 4-tuple mappings to servers, this is likely to work.\n\nIf we were optimizing for the no-config case, we'd just force fallback algorithms to be 4-tuple based. But that would make the happy path worse (by disallowing SNI routing).\n\n",
      "createdAt": "2025-02-28T20:47:53Z",
      "updatedAt": "2025-03-03T17:22:52Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ggreenway",
          "authorAssociation": "COLLABORATOR",
          "body": "> When LBs are missing config that servers are using, connections will drop. Sec 2.1 says LBs SHOULD have a superset of active server configs; consider escalating this to a MUST (or have a SHOULD with strong warnings).\n\nI think if the LB doesn't have a matching configuration of what the server generated (regardless of the reason) the only thing it can really do is use it's fallback routing, and treat it the same way it treats an initial client-specified CID.\n\n> Sec 2.2 says that 0b111 CIDs are always routable and MUST be routed by 4-tuple.\n\nAs you noted, 1/8 of random CIDs will have this set. Because of this, I don't think there can be any special requirement on 0b111 other than \"use whatever fallback routing you'd use for an unroutable CID\", because there's no way to tell if this is a server-generated 0b111 or if it's a random/client-generated CID. I suppose for short-headers you could always assume it's generated by the server, but during the initial handshake the initial long-header packet will have a random CID, and subsequent hong-header handshake packets may have a server-generated CID. The only indication of which type may be the length, but the client might by chance choose an initial CID that is the same length as server CIDs, so that's an unreliable heuristic.",
          "createdAt": "2025-02-28T21:45:49Z",
          "updatedAt": "2025-02-28T21:45:49Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One problem is that if the fallback uses the CID, and the server replaces the CID, it breaks the fallback.\n\nSimilarly, with SNI routing, 0-RTT and multi-packet CHLOs will break.\n\nI'm starting to think the way out is LB state -- track the routing decisions for all 4-tuples for which no routable CID has been observed. This can obviously be overwhelmed, but I can't see another way to resolve the tradeoffs except to not have SNI routing (which is how Google avoids it right now).\n\nSo,\n(1) 0b111 fits the definition of \"unroutable\".\n(2a) LBs MUST keep a listing of all 4-tuples that have not had a routable CID yet, and the server mapping, OR\n(2b) All unroutable CIDs are routed by 4-tuple.\n",
          "createdAt": "2025-02-28T22:02:40Z",
          "updatedAt": "2025-02-28T22:02:40Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A corollary to (2a) -- the LB MAY also map observed unroutable CIDs to servers, so that it can be robust to NAT rebinding.",
          "createdAt": "2025-02-28T22:09:29Z",
          "updatedAt": "2025-02-28T22:09:29Z"
        },
        {
          "author": "ggreenway",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'm starting to think the way out is LB state\n\nI think it depends on the behavior of the LB.\n\nThe requirement is that the LB must be able to send subsequent packets for the same quic connection to the same host, if no routable CID is found.\n\nIf the LB uses a 4-tuple hash for the initial packet routing, it would not need state to continue doing a 4-tuple hash on subsequent packets.\n\nIf the LB did SNI routing, it would require state for this case.\n\nI think it's also an option (with tradeoffs) for a user/operator to assume that there will not be a case where either the LB or the server does not have valid and correct configuration (due to robust control plane systems, etc), and to accept the tradeoff that if this condition is violated they choose to have traffic not function correctly at all (and in common scenarios, clients may fallback to http/2 over TCP, as many clients do).\n\nSo then it may be appropriate for the RFC to offer some guidance on these tradeoffs, without requiring which tradeoff is chosen.",
          "createdAt": "2025-02-28T22:11:17Z",
          "updatedAt": "2025-02-28T22:11:17Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Here's some pseudo code for the load balancer:\n\nServerMappingOrDrop Route packet(PacketInfo info) {\n   if (IsRoutable(info.cid))  return GetServerMapping(info.cid);\n   if (info.short_header && !info.cid.config_id = 0b111) return Drop;\n   if (CidTableExists && CidTable[info.cid].exists()) return CidTable[info.cid];\n   if (FallbackAlgorithmOnlyUses4Tuple) return Fallback(info.4tuple);\n   // the 4tuple table exists iff the FallbackAlgorithm uses inputs besides the 4tuple.\n   if (4tupleTable[info.4tuple].exists()) return 4tuple[info.4table];\n   result = Fallback(info);\n   4tupleTable[info.4tuple] = result;\n   if (CidTableExists) CidTable[info.cid] = result;\n   return result;\n}\n\nUnless you see a problem here, or a better way, I'll figure out a way to put this in words.",
          "createdAt": "2025-02-28T22:27:30Z",
          "updatedAt": "2025-02-28T22:27:30Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\n> I think it's also an option (with tradeoffs) for a user/operator to assume that there will not be a case where either the LB or the server does not have valid and correct configuration (due to robust control plane systems, etc), and to accept the tradeoff that if this condition is violated they choose to have traffic not function correctly at all (and in common scenarios, clients may fallback to http/2 over TCP, as many clients do).\n> \n> So then it may be appropriate for the RFC to offer some guidance on these tradeoffs, without requiring which tradeoff is chosen.\n\nSounds reasonable to me.\n",
          "createdAt": "2025-02-28T22:29:21Z",
          "updatedAt": "2025-02-28T22:29:21Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Here's some pseudo code for the load balancer:\n> \n\nAlso, this way easier if 0b111 CIDs self-encode the length, since they can be in short headers.\n\n",
          "createdAt": "2025-02-28T22:30:07Z",
          "updatedAt": "2025-02-28T22:30:07Z"
        },
        {
          "author": "ggreenway",
          "authorAssociation": "COLLABORATOR",
          "body": "Copied into a md code-block for readability\n\n```\nServerMappingOrDrop Route packet(PacketInfo info) {\n  if (IsRoutable(info.cid)) return GetServerMapping(info.cid);\n  if (info.short_header && !info.cid.config_id = 0b111) return Drop;\n  if (CidTableExists && CidTable[info.cid].exists()) return CidTable[info.cid];\n  if (FallbackAlgorithmOnlyUses4Tuple) return Fallback(info.4tuple);\n  // the 4tuple table exists iff the FallbackAlgorithm uses inputs besides the 4tuple.\n  if (4tupleTable[info.4tuple].exists()) return 4tuple[info.4table];\n  result = Fallback(info);\n  4tupleTable[info.4tuple] = result;\n  if (CidTableExists) CidTable[info.cid] = result;\n  return result;\n}\n```\n\nFor the 2nd condition `if (info.short_header && !info.cid.config_id = 0b111) return Drop;`, it depends on whether the LB MUST or SHOULD have all the configs a server could have. If it only SHOULD, then it should fallback to 4-tuple routing in this case I think.",
          "createdAt": "2025-02-28T23:07:55Z",
          "updatedAt": "2025-02-28T23:07:55Z"
        },
        {
          "author": "thynson",
          "authorAssociation": "NONE",
          "body": "> As you noted, 1/8 of random CIDs will have this set. Because of this, I don't think there can be any special requirement on 0b111 other than \"use whatever fallback routing you'd use for an unroutable CID\", because there's no way to tell if this is a server-generated 0b111 or if it's a random/client-generated CID.\n\nI think it\u2018s worth to expand the unroutable cid definition to \"if the load balancer is willing to parse the packet, it MAY treat DCID in a InitialPacket as unroutable DCID,  regardless of whether it's 0b111 DCID or not.\"",
          "createdAt": "2025-03-02T11:02:45Z",
          "updatedAt": "2025-03-02T11:05:03Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The PR makes 0b111 unroutable, period.\n\nIf we allow other routable CIDs to be treated as unroutable, that makes the logic really complex, and I fear that things won't be deterministic. In a well-designed architecture, it will be basically impossible for clients to accidentally choose a routable CID.\n\nA client could purposely and maliciously choose one, but I don't see what the benefit of that is.\n\nFinally, I think there are extensions (like Version Aliasing) that could suggest future CIDs to reconnect with the same server.",
          "createdAt": "2025-03-03T17:22:51Z",
          "updatedAt": "2025-03-03T17:22:51Z"
        }
      ]
    },
    {
      "number": 237,
      "id": "I_kwDODoD6yc6sYq0n",
      "title": "Should CID length always be self-encoded?",
      "url": "https://github.com/quicwg/load-balancers/issues/237",
      "state": "OPEN",
      "author": "ggreenway",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Why is it an option to not self-encode the CID length? It would (slightly) simplify the RFC to remove this option entirely. Reasons:\n\n* length-encoded CIDs are compatible with systems that don't require them, but the opposite is not true\n* Very little additional randomness is added by randomizing the 5 bits that are for this use. The ciphertext portion of the CID is already required to be unique\n* Removing this option is one fewer detail that needs to be kept in sync between server and LB configuration\n\nWhat is the argument for not always requiring length encoding?",
      "createdAt": "2025-03-03T19:40:34Z",
      "updatedAt": "2025-03-03T21:37:09Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "the bits can be used for thread encoding, or other server-specific things. It's not something specifically necessary for LB/server interop, except for the 0b111 case, which the PR addresses.",
          "createdAt": "2025-03-03T21:37:08Z",
          "updatedAt": "2025-03-03T21:37:08Z"
        }
      ]
    },
    {
      "number": 238,
      "id": "I_kwDODoD6yc6sl697",
      "title": "Text About Dropping Packets is Confusing and Not That Useful",
      "url": "https://github.com/quicwg/load-balancers/issues/238",
      "state": "OPEN",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Dropping some packets with unroutable CIDS is an optimization to avoid useless traffic. It doesn't really guard against DoS attacks because an attacker can simply generate Initial packets with unroutable CIDs and force them to be delivered.\n\nThere are tons of conditions and assumptions baked in:\n- The CID is unroutable\n- The CID does not begin with 0b111 (or we know for sure that all servers have valid config)\n- The packet could not contain a client-generated CID (which involves many assumptions about the QUIC version, which it turn leads to discussion of keeping state for a flow's QUIC versions to handle short headers, etc)\n\nThis capability also adds to the conditions where QUIC-LB is not robust to new QUIC versions.\n\nWe should simply delete all of these provisions. The benefits are small and the complexity is great.",
      "createdAt": "2025-03-04T22:45:49Z",
      "updatedAt": "2025-03-04T22:45:49Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 239,
      "id": "I_kwDODoD6yc6swk4X",
      "title": "Rewrite Version Invariance Section",
      "url": "https://github.com/quicwg/load-balancers/issues/239",
      "state": "OPEN",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "A solution for #238 can significantly reduce version dependence. However, the following assumptions still apply:\n\n* Short headers always contain server-generated CIDs -- there is no way to obtain the CID length if not.\n\n* Packets that do not contain server-generated CIDs are consistent in 4-tuple and DCID. Fallback algorithms for unknown versions will fail otherwise.\n\n* There is a mechanism for servers to provide a CID.\n\nNote also that the reference to NEW_CONNECTION_ID frames is version-specific and should be generalized.",
      "createdAt": "2025-03-05T20:30:09Z",
      "updatedAt": "2025-03-05T22:52:26Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The advanced fallback algorithm is not robust to new versions and is unlikely to produce satisfactory results.",
          "createdAt": "2025-03-05T22:31:09Z",
          "updatedAt": "2025-03-05T22:31:09Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "connection IDs cannot be more than 32 bytes and use length-self-encoding.",
          "createdAt": "2025-03-05T22:52:25Z",
          "updatedAt": "2025-03-05T22:52:25Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgwNTMzMjM2",
      "title": "Deleted leftover reference to config method",
      "url": "https://github.com/quicwg/load-balancers/pull/1",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This fixes an issue from the private repo:\r\nhttps://github.com/martinduke/draft-duke-quic-load-balancers/issues/63\r\n",
      "createdAt": "2020-02-26T22:11:23Z",
      "updatedAt": "2020-02-28T20:30:42Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "568bfa12852a731f9c757ec6878f52e2c8319774",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "mduke-cleanup-config-method",
      "headRefOid": "c4292b9a5a13b4474678860eb24c30bc7c6b0bea",
      "closedAt": "2020-02-28T20:30:41Z",
      "mergedAt": "2020-02-28T20:30:41Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "ee1de5bcac2628e6bef279e0cfff5475f6d6a39f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1Mzg0NzA3",
          "commit": {
            "abbreviatedOid": "c4292b9"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-27T02:52:35Z",
          "updatedAt": "2020-02-27T02:52:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 2,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgwNTk0ODc0",
      "title": "Light edit of Retry Services section",
      "url": "https://github.com/quicwg/load-balancers/pull/2",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes https://github.com/martinduke/draft-duke-quic-load-balancers/issues/60",
      "createdAt": "2020-02-27T01:49:16Z",
      "updatedAt": "2020-03-02T16:01:06Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "568bfa12852a731f9c757ec6878f52e2c8319774",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "mduke-new-retry-format",
      "headRefOid": "7a5babfd370bba3bb55be009e9a1384cd4293ea6",
      "closedAt": "2020-03-02T16:01:05Z",
      "mergedAt": "2020-03-02T16:01:04Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "589d0a45e47f1bc49a67742e6ead64f3fd58d2bf"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1Mzg1MjU2",
          "commit": {
            "abbreviatedOid": "a46ef71"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-27T02:54:35Z",
          "updatedAt": "2020-02-27T02:56:33Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Maybe something more like \"may lead to increased load on the server\".",
              "createdAt": "2020-02-27T02:54:36Z",
              "updatedAt": "2020-02-28T23:11:39Z"
            },
            {
              "originalPosition": 4,
              "body": "Why was this removed?",
              "createdAt": "2020-02-27T02:56:26Z",
              "updatedAt": "2020-02-28T23:11:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NzM1NzY2",
          "commit": {
            "abbreviatedOid": "a46ef71"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T23:05:26Z",
          "updatedAt": "2020-02-28T23:05:26Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I prefer the more concise sentence.",
              "createdAt": "2020-02-28T23:05:26Z",
              "updatedAt": "2020-02-28T23:11:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NzM2OTgw",
          "commit": {
            "abbreviatedOid": "a46ef71"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T23:09:20Z",
          "updatedAt": "2020-02-28T23:09:21Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I was going to rewrite this to allow Retry services to drop 0RTT too, and then realized that this line allows unlimited packets from attackers if they are non-initial, non-0RTT.\r\n\r\nThis seemed bad, but now I see that because short packets could very easily involve a CID or IP address change, there is no way for the service to filter them effectively. I'll restore it.",
              "createdAt": "2020-02-28T23:09:20Z",
              "updatedAt": "2020-02-28T23:11:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2OTQ3MjQz",
          "commit": {
            "abbreviatedOid": "7a5babf"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-02T04:39:49Z",
          "updatedAt": "2020-03-02T04:39:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 3,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgwNjAyNTM3",
      "title": "Explain how load balancer chains might work",
      "url": "https://github.com/quicwg/load-balancers/pull/3",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "resolves https://github.com/martinduke/draft-duke-quic-load-balancers/issues/61\r\n\r\n(also added the changelog for this draft version)",
      "createdAt": "2020-02-27T02:22:25Z",
      "updatedAt": "2020-02-28T23:03:13Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "568bfa12852a731f9c757ec6878f52e2c8319774",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "mduke-multi-tier",
      "headRefOid": "ff56b1cc73c8db1cb98d4007e0adf6bf75e20a52",
      "closedAt": "2020-02-28T23:03:12Z",
      "mergedAt": "2020-02-28T23:03:12Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "bc77d7d6891cc91c53a76b102dab739cf62cd5f1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1Mzg1OTM0",
          "commit": {
            "abbreviatedOid": "ff56b1c"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-27T02:57:14Z",
          "updatedAt": "2020-02-27T02:57:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 4,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgwNjEwODM3",
      "title": "Update readme title",
      "url": "https://github.com/quicwg/load-balancers/pull/4",
      "state": "CLOSED",
      "author": "nibanks",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-02-27T02:59:28Z",
      "updatedAt": "2020-03-02T04:40:06Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "568bfa12852a731f9c757ec6878f52e2c8319774",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "nibanks/update-readme",
      "headRefOid": "1ebc02923d300893d672b4bed87835f2fd37ea53",
      "closedAt": "2020-03-01T16:49:00Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "#5 is a broader fix to conform to the new format.",
          "createdAt": "2020-02-28T23:46:08Z",
          "updatedAt": "2020-02-28T23:46:08Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 5,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgxNjQ4ODM0",
      "title": "Conform README and CONTRIBUTING to WG standard",
      "url": "https://github.com/quicwg/load-balancers/pull/5",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-02-28T23:43:59Z",
      "updatedAt": "2020-03-01T16:48:35Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "bc77d7d6891cc91c53a76b102dab739cf62cd5f1",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "mduke-fix-readme",
      "headRefOid": "1a3b46205dc5bb05d9d9a3deb71cbb758b51e295",
      "closedAt": "2020-03-01T16:48:34Z",
      "mergedAt": "2020-03-01T16:48:34Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "37d829da4b7f99bfabe89c75432016065af9abda"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NzU0NzAx",
          "commit": {
            "abbreviatedOid": "1a3b462"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-29T00:20:33Z",
          "updatedAt": "2020-02-29T00:20:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 11,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgyNTk2ODE3",
      "title": "Import circle config from base-drafts",
      "url": "https://github.com/quicwg/load-balancers/pull/11",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I copied over the circle .yaml file from base-drafts, then commented out the \"push to datatracker\" bit because I'm afraid I'll do it by accident, and am happy to do that part manually.",
      "createdAt": "2020-03-02T20:40:11Z",
      "updatedAt": "2020-03-03T00:46:48Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "589d0a45e47f1bc49a67742e6ead64f3fd58d2bf",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "fix-circle-config",
      "headRefOid": "51766b0ac942c74206310bebbc57d67ad6f93a41",
      "closedAt": "2020-03-03T00:46:47Z",
      "mergedAt": "2020-03-03T00:46:47Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "20f2e030b00b6be05b416135e52e38afe18fae36"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NjIzNjI3",
          "commit": {
            "abbreviatedOid": "0edcc9d"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "This is fine, but you should just copy directly from the template with no changes.",
          "createdAt": "2020-03-03T00:18:04Z",
          "updatedAt": "2020-03-03T00:18:32Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Why comment this out?",
              "createdAt": "2020-03-03T00:18:04Z",
              "updatedAt": "2020-03-03T00:45:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 13,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0NjU2MzI0",
      "title": "Test vectors",
      "url": "https://github.com/quicwg/load-balancers/pull/13",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I wrote some code to generate these CIDs and then extract the SID back. It's self-consistent, at least.",
      "createdAt": "2020-03-06T06:28:38Z",
      "updatedAt": "2020-03-09T14:58:49Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "42ad253c3f510a555b1c8d9b71342748c78dee8b",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "test-vectors",
      "headRefOid": "302b1ae86f97faa3227832676ac524ebf243fe34",
      "closedAt": "2020-03-09T14:58:48Z",
      "mergedAt": "2020-03-09T14:58:48Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "359dcc9d819c90277123262b33a9ab2a117829c9"
      },
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Resolves https://github.com/martinduke/draft-duke-quic-load-balancers/issues/62\r\n",
          "createdAt": "2020-03-06T06:29:22Z",
          "updatedAt": "2020-03-06T06:29:22Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I goofed with git, which created the \"revert.\" But I assure you the changes are still in there.",
          "createdAt": "2020-03-06T06:31:08Z",
          "updatedAt": "2020-03-06T06:31:08Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 14,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg1MDQ4MzIz",
      "title": "added language about server connection migration",
      "url": "https://github.com/quicwg/load-balancers/pull/14",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Intended to resolve #10.",
      "createdAt": "2020-03-06T22:25:03Z",
      "updatedAt": "2020-03-09T15:18:45Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "42ad253c3f510a555b1c8d9b71342748c78dee8b",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "edge-cases",
      "headRefOid": "532dd1adfd11dde3fc4749aca9f2ce3d9ade9ad7",
      "closedAt": "2020-03-09T15:18:44Z",
      "mergedAt": "2020-03-09T15:18:44Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "a03dbcc7f0040b32bfbe0a757400fdf88fd37a45"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNjgwMzAy",
          "commit": {
            "abbreviatedOid": "3e3bf5c"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-06T23:09:50Z",
          "updatedAt": "2020-03-06T23:10:35Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Mention that the Retire Prior To field would be set to retire the previous CIDs.",
              "createdAt": "2020-03-06T23:09:51Z",
              "updatedAt": "2020-03-09T15:16:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwOTI1NDcy",
          "commit": {
            "abbreviatedOid": "3e3bf5c"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Seems fine.",
          "createdAt": "2020-03-09T05:36:32Z",
          "updatedAt": "2020-03-09T05:36:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 15,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg1NzA3ODI2",
      "title": "Fix obsolete references/terminology",
      "url": "https://github.com/quicwg/load-balancers/pull/15",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I found some text that still references the in-band protocol mechanisms.\r\n\r\nI tried to update terminology here (and in Security Considerations) without changing any design decisions, so that we can bracket those discussions.\r\n\r\nIn particular, #12 would change the intent of the config-rotation bits that we are trying to enforce here. This also touches the normative text about PCID that is the subject of #8, though I believe this PR  doesn't apply any change to the status quo.",
      "createdAt": "2020-03-09T17:06:02Z",
      "updatedAt": "2020-03-12T14:20:10Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "a03dbcc7f0040b32bfbe0a757400fdf88fd37a45",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "mduke-nits",
      "headRefOid": "bb9956293162aa250a8d872e43acacf70d20ecfa",
      "closedAt": "2020-03-12T14:20:09Z",
      "mergedAt": "2020-03-12T14:20:09Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "4a6936b1faf9de4af6a6fc62257d64ce92a13c12"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 17,
      "id": "MDExOlB1bGxSZXF1ZXN0NDExNzMyODU5",
      "title": "Fixed text vector line breaks",
      "url": "https://github.com/quicwg/load-balancers/pull/17",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-04-30T17:29:45Z",
      "updatedAt": "2020-04-30T18:47:27Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "4a6936b1faf9de4af6a6fc62257d64ce92a13c12",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "vector-line-breaks",
      "headRefOid": "2d751c57c91fd45be789cb524047bf1e2f7adfd3",
      "closedAt": "2020-04-30T18:47:25Z",
      "mergedAt": "2020-04-30T18:47:25Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "98fe4b33b709f24b57b882ef1e2438bffaa8c47e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzNzQ0NTk5",
          "commit": {
            "abbreviatedOid": "d528354"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM \ud83d\udc4d",
          "createdAt": "2020-04-30T17:48:08Z",
          "updatedAt": "2020-04-30T17:48:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 18,
      "id": "MDExOlB1bGxSZXF1ZXN0NDExNzc5MzI1",
      "title": "different line breaks",
      "url": "https://github.com/quicwg/load-balancers/pull/18",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-04-30T19:04:09Z",
      "updatedAt": "2020-04-30T19:04:39Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "98fe4b33b709f24b57b882ef1e2438bffaa8c47e",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "line-break-2",
      "headRefOid": "c430fe0be5e81804377f41b8ff2927557d301bb7",
      "closedAt": "2020-04-30T19:04:38Z",
      "mergedAt": "2020-04-30T19:04:38Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "85e0cbaa5d4749596d185c6b3e2a65230c726c04"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 19,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEyMzg0NzE5",
      "title": "chose a different word",
      "url": "https://github.com/quicwg/load-balancers/pull/19",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "this is mostly to test I've fixed some integration issues.",
      "createdAt": "2020-05-02T02:06:27Z",
      "updatedAt": "2020-05-02T02:06:40Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "85e0cbaa5d4749596d185c6b3e2a65230c726c04",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "nit",
      "headRefOid": "ab696021278a487e9520f0b330ae6d79d4ec67df",
      "closedAt": "2020-05-02T02:06:39Z",
      "mergedAt": "2020-05-02T02:06:39Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "38132cf34147a0aa66b0b462f935317b5cb289f1"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 21,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE0OTE0OTg1",
      "title": "Add discussion of QUIC invariants",
      "url": "https://github.com/quicwg/load-balancers/pull/21",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Somewhat obliquely, this addresses #20.\r\n\r\n",
      "createdAt": "2020-05-07T20:55:43Z",
      "updatedAt": "2020-05-14T02:26:46Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "38132cf34147a0aa66b0b462f935317b5cb289f1",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "invariants",
      "headRefOid": "4e3d9c0ad9086dacf6d58854e9e3aa595e8a28b4",
      "closedAt": "2020-05-14T02:26:45Z",
      "mergedAt": "2020-05-14T02:26:45Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "09a09252204907901f4fdb8b8055dfb091bab5e2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3ODM3Mjk4",
          "commit": {
            "abbreviatedOid": "4e3d9c0"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM \ud83d\udc4d",
          "createdAt": "2020-05-07T21:06:52Z",
          "updatedAt": "2020-05-07T21:06:52Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3OTAzMDg0",
          "commit": {
            "abbreviatedOid": "4e3d9c0"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-07T23:27:36Z",
          "updatedAt": "2020-05-08T02:14:52Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "We might be able to move this into invariants, as I mentioned on the issue.  WDYT?",
              "createdAt": "2020-05-07T23:27:36Z",
              "updatedAt": "2020-05-08T02:14:52Z"
            },
            {
              "originalPosition": 74,
              "body": "I think that this is really the one point.  If we move the first point to the invariants doc (and I think we should), then you can just talk about the one assumption: that addressing information doesn't change until after the server is able to give the client a connection ID that works for proper routing.\r\n\r\nHowever, this isn't completely sufficient.  If your load balancer is stateless and performs address-tuple routing on long headers and connection ID routing on short headers, you are relying on a different assumption:  that long headers are only used prior for that period the address is stable during setup.  If we ever found a use for a long header long after connection establishment, the load balancer wouldn't know that and it might route things differently.\r\n\r\nThat's not a great situation to be in.",
              "createdAt": "2020-05-07T23:31:33Z",
              "updatedAt": "2020-05-08T02:14:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3OTUzOTcz",
          "commit": {
            "abbreviatedOid": "4e3d9c0"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-08T02:17:24Z",
          "updatedAt": "2020-05-08T02:17:25Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "That would be fine; LBs could safely drop short headers with non compliant DCIDs.",
              "createdAt": "2020-05-08T02:17:25Z",
              "updatedAt": "2020-05-08T02:17:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3OTU1NTcy",
          "commit": {
            "abbreviatedOid": "4e3d9c0"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-08T02:23:11Z",
          "updatedAt": "2020-05-08T02:23:12Z",
          "comments": [
            {
              "originalPosition": 74,
              "body": "Not quite. Let's say the invariants specify that the server generated CID will be in place within one (lossless) RTT. (The first assumption)\r\n\r\nThen we are still hosed if, for some reason, v2 has clients use different CIDs for each initial and 0rtt packet. Why would v2 do that! I have no idea!\r\n\r\nUltimately, if the invariants can promise that some part of the long header will be consistent and connection unique until we have a server generated CID, we'll update the LB guidance to hash off that.\r\n\r\nLate long headers are not a problem as long as they have a server generated DCID. The LB is always supposed to trial decode the DCID to see if it is compliant.",
              "createdAt": "2020-05-08T02:23:12Z",
              "updatedAt": "2020-05-08T02:23:12Z"
            }
          ]
        }
      ]
    },
    {
      "number": 24,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIzMzQ5Mzgx",
      "title": "fix figures",
      "url": "https://github.com/quicwg/load-balancers/pull/24",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #23",
      "createdAt": "2020-05-26T17:34:10Z",
      "updatedAt": "2020-05-26T18:14:15Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "6b5ff625a09407fc4afe7c772c439fe5078ec8ac",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "fig3-4",
      "headRefOid": "97382eaae28603339133f6169aab9f40356f03e9",
      "closedAt": "2020-05-26T18:14:13Z",
      "mergedAt": "2020-05-26T18:14:13Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "5b6034235feebcf92c64c8aef1a56760f5329996"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NTI2MDYw",
          "commit": {
            "abbreviatedOid": "97382ea"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-26T17:35:39Z",
          "updatedAt": "2020-05-26T17:35:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 25,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIzMzY1Mzgw",
      "title": "Update text on Version Independence",
      "url": "https://github.com/quicwg/load-balancers/pull/25",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Carefully phrased language that considers @martinthomson 's suggestion that SCID may not be stable across versions, and tries to suggest (IP, port, DCID) as a suitable long header hash without making promises on behalf of quic-invariants.\r\n\r\nFixes #22.",
      "createdAt": "2020-05-26T18:01:03Z",
      "updatedAt": "2020-07-01T00:47:55Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "1033d06b11f1fffcde778b40a0eed67748e6da6e",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "noncompliant",
      "headRefOid": "e17243ad2971011250aface9268d82a4750c0984",
      "closedAt": "2020-07-01T00:47:53Z",
      "mergedAt": "2020-07-01T00:47:53Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "1db2dd1ac29a04eb368a82cfbb7e662999fdfb46"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4ODAyMTY0",
          "commit": {
            "abbreviatedOid": "bc1b638"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-27T01:44:04Z",
          "updatedAt": "2020-05-27T01:45:24Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "What interval?\r\n\r\n (I think that the list structure is working against you here.)",
              "createdAt": "2020-05-27T01:44:04Z",
              "updatedAt": "2020-07-01T00:47:26Z"
            },
            {
              "originalPosition": 9,
              "body": "Don't use \"for example\" here.  You want to be precise.",
              "createdAt": "2020-05-27T01:44:41Z",
              "updatedAt": "2020-07-01T00:47:26Z"
            },
            {
              "originalPosition": 10,
              "body": "for all packets sent on the same connection.",
              "createdAt": "2020-05-27T01:45:10Z",
              "updatedAt": "2020-07-01T00:47:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5NjQ5ODA4",
          "commit": {
            "abbreviatedOid": "3188d36"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-30T03:48:18Z",
          "updatedAt": "2020-06-30T03:48:19Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "As this aims to represent IETF consensus, we should be able to say something more concrete about this than \"the authors believe\" implies.\r\n\r\nI think that what can be said is that these assumption are made by this document and while it is not guaranteed that *every* QUIC version will conform to these assumptions, they are minimal and narrowly scoped.  This means that it is likely - and indeed desirable - for new versions of QUIC to conform to these expectations.  By doing so, a new version of QUIC will be able to use load balancers that conform to the design in this document.\r\n\r\nThat's a fairly compelling trade: make a small additional allowance to get all this stuff.  But it also means that you aren't constraining the design of QUIC versions that might not need or want involvement by a load balancer.",
              "createdAt": "2020-06-30T03:48:18Z",
              "updatedAt": "2020-07-01T00:47:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNDMwMDEy",
          "commit": {
            "abbreviatedOid": "aec1a54"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-30T22:30:00Z",
          "updatedAt": "2020-06-30T22:30:00Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "OK, have another look.",
              "createdAt": "2020-06-30T22:30:00Z",
              "updatedAt": "2020-07-01T00:47:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNDMxMDA0",
          "commit": {
            "abbreviatedOid": "aec1a54"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-30T22:32:21Z",
          "updatedAt": "2020-06-30T22:32:21Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNDc0NjAy",
          "commit": {
            "abbreviatedOid": "aec1a54"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-01T00:39:15Z",
          "updatedAt": "2020-07-01T00:39:24Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "```suggestion\r\npackets sent on the same connection.\r\n\r\nWhile this document does not update the\r\n```\r\n\r\nI say that because I think that this statement applies to the entire list.",
              "createdAt": "2020-07-01T00:39:15Z",
              "updatedAt": "2020-07-01T00:47:26Z"
            }
          ]
        }
      ]
    },
    {
      "number": 26,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIzMzY4NjU4",
      "title": "Get rid of SCID acronym",
      "url": "https://github.com/quicwg/load-balancers/pull/26",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Server CID will collide with Source CID.\r\n\r\nFixes #7",
      "createdAt": "2020-05-26T18:07:59Z",
      "updatedAt": "2020-06-16T22:00:23Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "6b5ff625a09407fc4afe7c772c439fe5078ec8ac",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "new-acronym",
      "headRefOid": "a257b65356790128948bccbb26496d6dc7be33be",
      "closedAt": "2020-06-16T22:00:22Z",
      "mergedAt": "2020-06-16T22:00:22Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "1033d06b11f1fffcde778b40a0eed67748e6da6e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NTgwMDY4",
          "commit": {
            "abbreviatedOid": "a257b65"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-26T18:47:23Z",
          "updatedAt": "2020-05-26T18:47:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 29,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM1NTA4MTg1",
      "title": "New Security Considerations",
      "url": "https://github.com/quicwg/load-balancers/pull/29",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Added two sections to Security Considerations (Stateless Reset Oracle and Local Configurations Only). Fixes #9 and #27.",
      "createdAt": "2020-06-16T22:53:50Z",
      "updatedAt": "2020-07-06T19:17:22Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "1033d06b11f1fffcde778b40a0eed67748e6da6e",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "more-security",
      "headRefOid": "60dc0918a7fd69517a1ba90fe5a73ad91ebfcdbf",
      "closedAt": "2020-07-06T19:17:21Z",
      "mergedAt": "2020-07-06T19:17:21Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "d8055db4a9a50a5b39ee0146adabed5441376ee6"
      },
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "Can you speak a little about your reasoning for the recent changes?  If this attack is limited to extracting the identity of server instances for other co-hosted entities, that's probably OK, but I'm having trouble connecting the SHOULD here with the preceding text.",
          "createdAt": "2020-07-01T00:42:46Z",
          "updatedAt": "2020-07-01T00:42:46Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sure. If an attacker has the same QUIC-LB config as the victim, then it can extract the server mapping, which defeats the whole point of the spec. Obviously, an LB must have the QUIC-LB config for servers it routes to. If I'm an attacker within that group of servers I may already see the packet headers that give away the server mapping, so there's little added linkability here (though there is a little).\r\n\r\nThe moment I share configuration among multiple server pools, I'm expanding the number of entities with access to the config, for no operational benefit except to make the administrator's life easier. In the absurd limit, all of AWS has the same QUIC-LB config, and essentially everyone can extract the server mapping from any CID that goes to AWS.",
          "createdAt": "2020-07-01T02:07:58Z",
          "updatedAt": "2020-07-01T02:07:58Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyMDA2MTAw",
          "commit": {
            "abbreviatedOid": "7578c37"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Not sure about the first, but the oracle bit is good, assuming that the mechanisms in the draft actually provide for deterministic routing of the same DCID over the life of a connection.\r\n\r\nThe nuanced point here is that you sometimes end up in a state where a DCID no longer routes to the node that holds the connection, but it is OK if that is the result of an event that also caused the connection to become invalid.  The typical example here is that the node died.  In that case, a stateless reset is OK, because the connection cannot continue.\r\n\r\nI'll leave it to you as to whether you think that mentioning this case is worth doing.",
          "createdAt": "2020-06-17T01:56:54Z",
          "updatedAt": "2020-06-17T01:59:32Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I don't think that the scope of this is very clear.  If the idea is that the cloud provider - the one who provides the load balancer - provides the same configuration to mutually distrustful customers, then there is a very important point to make.  But I'm not sure that this is clear from the text here.  \"enterprise\" isn't well connected to \"cloud provider\".",
              "createdAt": "2020-06-17T01:56:54Z",
              "updatedAt": "2020-07-06T19:16:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNTg1Mjc0",
          "commit": {
            "abbreviatedOid": "7578c37"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-17T16:44:53Z",
          "updatedAt": "2020-06-17T16:44:53Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "OK, I got rid of the word 'enterprise' and I think it's clearer now.",
              "createdAt": "2020-06-17T16:44:53Z",
              "updatedAt": "2020-07-06T19:16:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5NTk5Mjg2",
          "commit": {
            "abbreviatedOid": "de42903"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-30T01:03:12Z",
          "updatedAt": "2020-06-30T03:48:36Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "\"as narrow as possible\" is not really going to achieve our security goals.  The requirement (and it's a requirement not merely a desideratum) is that mutually distrustful entities cannot acquire information that might be used to mount denial of service on each other.",
              "createdAt": "2020-06-30T01:03:12Z",
              "updatedAt": "2020-07-06T19:16:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNDIyODMz",
          "commit": {
            "abbreviatedOid": "e530316"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-30T22:13:26Z",
          "updatedAt": "2020-06-30T22:13:27Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "OK, I've rephrased it to be a bit more restrictive. How do you like it?",
              "createdAt": "2020-06-30T22:13:26Z",
              "updatedAt": "2020-07-06T19:16:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNDMxODYw",
          "commit": {
            "abbreviatedOid": "e530316"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-30T22:34:21Z",
          "updatedAt": "2020-06-30T22:34:21Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMzA3MjAz",
          "commit": {
            "abbreviatedOid": "50c9731"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Better, though I think that the new SHOULD NOT is toothless.\r\n\r\nIn my view, the recommendation should be that entities that might be mutually distrustful SHOULD be given different load balancer configurations.",
          "createdAt": "2020-07-02T02:22:57Z",
          "updatedAt": "2020-07-02T02:22:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 30,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM1NTI0NTI5",
      "title": "ICMP Packet routing",
      "url": "https://github.com/quicwg/load-balancers/pull/30",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Added language about ICMP packets. Fixes #28.",
      "createdAt": "2020-06-16T23:52:12Z",
      "updatedAt": "2020-06-19T19:07:02Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "1033d06b11f1fffcde778b40a0eed67748e6da6e",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "icmp",
      "headRefOid": "c20d3c29dcde8a4067a0f381444ff8fa13b98756",
      "closedAt": "2020-06-19T19:07:01Z",
      "mergedAt": "2020-06-19T19:07:01Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "9ae14595a863b0c41b5a72925a5b791091c60321"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0Mjg0NzU2",
          "commit": {
            "abbreviatedOid": "982dbcf"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Looks good to me. One minor suggestion on text change, but feel free to ignore it.",
          "createdAt": "2020-06-19T18:57:42Z",
          "updatedAt": "2020-06-19T18:58:47Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nto deliver ICMP packets from the network to the correct server, by\r\n```",
              "createdAt": "2020-06-19T18:57:42Z",
              "updatedAt": "2020-06-19T19:05:50Z"
            }
          ]
        }
      ]
    },
    {
      "number": 32,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM3MzQyNzI1",
      "title": "Add retry_source_connection_id to tokens",
      "url": "https://github.com/quicwg/load-balancers/pull/32",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "After thinking it through, various XOR schemes were extremely vulnerable to manipulation, so I went with a brute force approach. Fixes #31.",
      "createdAt": "2020-06-20T00:52:39Z",
      "updatedAt": "2020-06-29T19:11:45Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "9ae14595a863b0c41b5a72925a5b791091c60321",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "retry-source-cid",
      "headRefOid": "765f829f2d011aecaece012818cc969996b548af",
      "closedAt": "2020-06-29T19:11:44Z",
      "mergedAt": "2020-06-29T19:11:43Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "702833e7259b6e936492fa656b69115185beb560"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5NDI2MDUw",
          "commit": {
            "abbreviatedOid": "765f829"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-29T19:11:11Z",
          "updatedAt": "2020-06-29T19:11:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 33,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQyOTU2Mjc1",
      "title": "Describe 3 pass stream cipher.",
      "url": "https://github.com/quicwg/load-balancers/pull/33",
      "state": "MERGED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR describes a three pass stream cipher option. The three passes are:\r\n\r\n1) Encrypt the server-id bytes using the nonce bytes\r\n\r\n2) Encrypt the nonce bytes using the server-id bytes\r\n\r\n3) Encrypt the server-id bytes using the nonce bytes\r\n\r\nThis is effectively a much simplified version of the FFX algorithm. The effect is complete encryption of server-id and nonce, and thus resiliency against bit flipping attacks. With the simple stream cipher, and attacker can flip bits in the server ID, resulting in a different decrypted value which could be used in attacks. With the triple stream cipher, flipping any bit will result in random flips of every other bits, which would be easy for servers or load balancers to detect.\r\n\r\nOf course, full encryption also has these properties. But full encryption requires fairly long CID, while stream encryption works reasonably with small CID.",
      "createdAt": "2020-07-01T19:57:52Z",
      "updatedAt": "2025-03-05T18:55:19Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "1db2dd1ac29a04eb368a82cfbb7e662999fdfb46",
      "headRepository": "huitema/load-balancers",
      "headRefName": "better-obfuscate",
      "headRefOid": "693877d12810d7b371e12ee37ae26247ce54fed2",
      "closedAt": "2020-07-09T01:16:05Z",
      "mergedAt": "2020-07-09T01:16:05Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "d997d798f17e034ae35f27778a366451d3cf6964"
      },
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for writing this. If I can get clarity on the threat model, I would see no reason to retain the original algorithm, and would simply replace it with this one.\r\n\r\nBut I don't quite understand the bit flipping attack against the old algorithm. I can certainly flip the server ID bits to cause the LB to send it to a different server. But I can also do this by generating random CIDs -- only the addition of zero padding, or unallocated server ID space, gives the LB a chance of detecting invalid CIDs.\r\n\r\nHow would LBs detect tampering using the 3 pass technique?",
          "createdAt": "2020-07-02T19:36:21Z",
          "updatedAt": "2020-07-02T19:36:38Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would detect LB tampering by making the server ID bit longer than strictly necessary. With the three pass method, tampering or random generation will cause every server ID bit to have a random value. Forgeries will statistically be detected as out of range, with probability `1- sizeof(range) / sizeof(id)`.\r\n\r\nNote that it should also be possible to make the nonce bit shorter than the original spec, because we are no more relying on the randomness of the nonce value. Each server could set the nonce to some kind of sequence number, incremented at each CID allocation. The size of the number should be enough to cover all allocations during a CID encryption key epoch, instead of twice that to cover the birthday paradox if using random allocations.",
          "createdAt": "2020-07-03T00:56:50Z",
          "updatedAt": "2020-07-03T00:56:50Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The bit flipping attack against the old algorithm involves using a side channel to obtain the server ID in existing CID, then flipping selected bits to target a specific server.",
          "createdAt": "2020-07-03T01:00:29Z",
          "updatedAt": "2020-07-03T01:00:29Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Another point about stream ciphers. Since we are using an algorithm similar to PN encryption, it is possible to \"mask\" some bits -- such as for example the two topmost bits. That means it is possible to use 6 bits of the \"first octet\" as part of the server-id.\r\n\r\nThis is also possible for the clear method, and for the divider method.",
          "createdAt": "2020-07-03T01:03:12Z",
          "updatedAt": "2020-07-03T01:03:12Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> That means it is possible to use 6 bits of the \"first octet\"\r\n\r\nI don't think this is correct. What is not clear in the current language is that the server may choose to use these 6 (5 given an outstanding PR) for length encoding, independent of what the LB wants. This is for crypto offload purposes. Encrypting the length bits would create problems.",
          "createdAt": "2020-07-03T17:51:29Z",
          "updatedAt": "2020-07-03T17:51:29Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@huitema  Sorry to be obtuse, but I'm still not following the threat model that the 3-pass algorithm addresses.\r\n\r\nI agree that avoiding the birthday problem is a nice result of your proposal.\r\n\r\n**LB tampering detection**: Yes, with stream cipher the only way to detect a randomly generated CID is for the server ID space to be >>> than the number of servers. The LB can then simply discard any packet that maps to an invalid server (unless it has a long header). But this true of the existing design, and isn't unique to 3-pass.\r\n\r\n> The bit flipping attack against the old algorithm involves using a side channel to obtain the server ID in existing CID, then flipping selected bits to target a specific server.\r\n\r\nFor the whole time I've worked on this, I've dealt with people very concerned about DoS vs. a single server in the pool, and people who don't think this is a problem at all. I (weakly) tend toward the latter camp. (Also, if it _is_ a problem, the plaintext algorithm is a walking DoS vector, but that's a different issue).\r\n\r\nNevertheless, let's assume that it's a problem, and that the attacker has obtained both the positions of the server ID bytes and the server ID for two servers in the pool via a side-channel. Then I guess the attack is to connect to server A, gather a number valid CIDs via NCID frames that have different nonces, and then xor the SID field to route to server B. Is that accurate? If so, do you find that compelling? It seems strictly limited to the number of CIDs I can get from a valid server, so why not just DoS those CIDs to that server instead?",
          "createdAt": "2020-07-03T18:09:38Z",
          "updatedAt": "2020-07-03T18:09:38Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The current stream cipher proposal can only detect tampering if the server-id space is sparse, for a very specific definition of sparse. The property you want is, \"if you pick at random a number of the same size as the server ID, there is a fixed probability X that this this a valid number\". A linear numbering of the servers will not achieve that, even if you prepend a bunch of zeroes in front of the serial number. \r\n\r\nThe three-pass proposal detects tampering even if the server ID space is used linearly, e.g. even if only numbers lower than N are valid, with N much smaller than the maximum number allowed by the size of the field. This is because the CID is effectively encrypted.\r\n\r\nIn the absence of effective detection of tampering, the malleability of the stream cipher is dangerous. Suppose an attacker does a valid connection, and obtains a series of CID. Suppose the attacker also knows that there are 1024 servers in your pool. For each CID, it can flip the bottom 10 bits of the stream-ID and obtain 1023 new CID, which will all be recognized as valid by the load-balancer or by the firewall. Are you really sure that attackers cannot put that to good use? (Good for them, of course, not so good for the defender.)",
          "createdAt": "2020-07-03T21:46:24Z",
          "updatedAt": "2020-07-03T21:46:24Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for clarifying. I increasingly favor this change. \r\n\r\nThe alternative would be that configuration agents SHOULD disperse server IDs over the available space, but that could be difficult if the server ID is an IPv4 address or something. I'll sleep on it, but I think I'll accept this PR next week.",
          "createdAt": "2020-07-03T22:11:07Z",
          "updatedAt": "2020-07-03T22:11:07Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 36,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQzNzY3MDU2",
      "title": "Remove version-specific text",
      "url": "https://github.com/quicwg/load-balancers/pull/36",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-07-02T22:24:24Z",
      "updatedAt": "2020-07-02T22:24:44Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "1db2dd1ac29a04eb368a82cfbb7e662999fdfb46",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "fix-typo",
      "headRefOid": "a6932ad03c2d2d7bca36879024ff6e9d69682eb8",
      "closedAt": "2020-07-02T22:24:43Z",
      "mergedAt": "2020-07-02T22:24:43Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "267ac4ad19c5326373311640e90a5c8d0ecfaad0"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 37,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQzNzcxNzIw",
      "title": "One more config rotation bit.",
      "url": "https://github.com/quicwg/load-balancers/pull/37",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #12.\r\n\r\nAlso addresses another version assumption and deletes a reference to the in-band protocol.",
      "createdAt": "2020-07-02T22:41:50Z",
      "updatedAt": "2021-07-09T18:57:59Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "267ac4ad19c5326373311640e90a5c8d0ecfaad0",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "more-configs",
      "headRefOid": "40320c1c6ab0b8bc0910764b97ab67398058622b",
      "closedAt": "2020-12-12T00:06:47Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Shouldn't the CID length be implicit, or maybe part of the configuration?",
          "createdAt": "2020-07-03T01:05:47Z",
          "updatedAt": "2020-07-03T01:05:47Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It often is, but we specifically added an optional self-encoded length to assist with hardware crypto offload.",
          "createdAt": "2020-07-03T01:12:59Z",
          "updatedAt": "2020-07-03T01:12:59Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson \r\n\r\n>My original thought here was that the configuration could indicate how many bits were spent on this vs. server ID.\r\n\r\nI don't think this will work in practice. The self-encoded length bit is mostly there for crypto offload devices on the server. So it's entirely possible (likely, even) that the LB doesn't care about the self-encoded length, but the server absolutely needs to use the 5 bits in that way.\r\n\r\nI see other problems, but this is the most important one.",
          "createdAt": "2020-07-03T17:46:06Z",
          "updatedAt": "2020-07-03T17:46:06Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You are placing server specific bits in the CID: an identifier of the class of servers served by a load-balancer, but I am worried about privacy issues. If I understand the intent, you want to partition the set of servers behind the load-balancer based on some level of trust. But doing that creates a privacy issue. When using ESNI/ECH, the privacy of client and services relies on hiding within the \"anonymity set\" of all services behind the load balancer. Having multiple classes partitions that set. (Allowing multiple CID lengths has the same effect.)",
          "createdAt": "2020-07-03T20:18:36Z",
          "updatedAt": "2020-07-03T20:18:36Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good point, @huitema. Would you prefer we stick with two bits and have some other way of solving the issue of mutually mistrustful servers, or would you be satisfied if we just added this privacy concern to the security considerations?",
          "createdAt": "2020-07-03T22:03:47Z",
          "updatedAt": "2020-07-03T22:03:47Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We need privacy considerations in any case. If you are concerned about privacy, you probably should not use the clear text and obfuscated method, and you also want to make sure that all servers in the anonymity set use the same CID length. (If you are serious about privacy or security, you should probably never use the clear text or obfuscated methods anyhow; maybe they should not make it to the final draft; but that's a different issue.)\r\n\r\nOn the specific case of the third bit, the effect on privacy is not good. You could say that \"if you are serious about privacy, all servers in the same anonymity set must use the same 3 bits pattern\". Or the same 2 bits pattern, for that matter. I do think sticking with 2 bits would be better, but I am not sure that I understand the use case for three bits. Is there that much of a security difference between \"the CID key is shared by 2000 servers\" and \"the CID key is shared by only 1000 servers\"? Are you not just hitting the practical deployment consideration that widely shared secrets are not going to stay secret for long?",
          "createdAt": "2020-07-03T22:17:14Z",
          "updatedAt": "2020-07-03T22:17:14Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Are you not just hitting the practical deployment consideration that widely shared secrets are not going to stay secret for long?\r\n\r\nThat's not the concern. The issue is that some of the servers behind the LB might not be trustworthy in terms of being able to link your clients. (e.g. a hosting service with multiple customers.)",
          "createdAt": "2020-07-03T23:05:07Z",
          "updatedAt": "2020-07-03T23:05:07Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">> That's not the concern. The issue is that some of the servers behind the LB might not be trustworthy in terms of being able to link your clients. (e.g. a hosting service with multiple customers.)\r\n\r\nCare to explain a bit more? You are maybe pointing here at deployment considerations. There seems to be several deployment cases:\r\n\r\n1) The \"example.com\" company manages its own pool of servers, \r\n\r\n2) The content delivery company \"example.net\" manages a bunch of edge servers that serve content for a variety of customers\r\n\r\n3) The hosting company \"example.example\" provides virtual machines to a bunch of customers with additional services like load balancing, firewall or DDoS protection.\r\n\r\nIn all these cases, there are different trust levels. It seems that the draft is making hidden assumptions about these levels. You may want to add something like \"deployment considerations\".\r\n",
          "createdAt": "2020-07-03T23:39:06Z",
          "updatedAt": "2020-07-03T23:39:06Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closed #12 with no action, so closing this too.",
          "createdAt": "2020-12-12T00:06:47Z",
          "updatedAt": "2020-12-12T00:06:47Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMTY3MjYx",
          "commit": {
            "abbreviatedOid": "8e719c5"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Of course you could get even more space here if you were willing to impose constraints on length.  You don't lose that many options if you do that either.  You just have to choose which options don't get to play.  I recommend everything from 0 (which you can't not have) to 4.  But that's just me, I'm sure.\r\n\r\nMy original thought here was that the *configuration* could indicate how many bits were spent on this vs. server ID.  Then you don't have any problems that might arise from constrained space.  Nor do you need to have a server ID length either.\r\n\r\nBut of course that moves the complexity into implementations.  For that, it's not much, and I would say that implementations are free to limit the range of values they support (probably more so for the load balancer than the more-flexible server).  And there is nothing wrong with making a suggestion either.",
          "createdAt": "2020-07-03T06:11:11Z",
          "updatedAt": "2020-07-03T06:19:34Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "```suggestion\r\nthese three bits allow four mutually exclusive server pools to coexist, and for\r\n```\r\n\r\nThat assumes of course that you need two keys per server pool, as opposed to rotating each pool one by one, in which case you can have seven (assuming excellent, though probably unrealistically difficult, coordination).\r\n\r\nI don't think that you need to be so definitive about this.  Say that you might use this to create 4 distinct pools that are able to independently use two distinct configurations (and therefore keys), or other arrangements.",
              "createdAt": "2020-07-03T06:11:11Z",
              "updatedAt": "2020-07-06T19:34:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyNTIwNzcz",
          "commit": {
            "abbreviatedOid": "8e719c5"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-03T17:43:47Z",
          "updatedAt": "2020-07-03T17:43:47Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Since '111' is reserved for 5-tuple routing, there are 7 codepoints. I believe 3 is the correct number. But I should say \"at least\" three.",
              "createdAt": "2020-07-03T17:43:47Z",
              "updatedAt": "2020-07-06T19:34:20Z"
            }
          ]
        }
      ]
    },
    {
      "number": 39,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ2NTY2MTAy",
      "title": "Editorial Pass on Triple Stream Cipher",
      "url": "https://github.com/quicwg/load-balancers/pull/39",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I will probably delete the Stream Cipher algorithm entirely, but consider this an intermediate step.",
      "createdAt": "2020-07-09T01:35:10Z",
      "updatedAt": "2020-07-09T20:33:06Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "d997d798f17e034ae35f27778a366451d3cf6964",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "new-stream-cipher-editorial",
      "headRefOid": "e060b07c46bc3223b32e1856552d8344b052c7f2",
      "closedAt": "2020-07-09T20:32:48Z",
      "mergedAt": "2020-07-09T20:33:05Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "d17b7d0d30bd1e6b9ff54b63c323e7a33f64b3b1"
      },
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Merging to enable the next round of edits",
          "createdAt": "2020-07-09T20:32:48Z",
          "updatedAt": "2020-07-09T20:32:48Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 40,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3MTE2NjM3",
      "title": "Down to one stream cipher algorithm",
      "url": "https://github.com/quicwg/load-balancers/pull/40",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Although more complex, the three-pass algorithm seems strictly better.",
      "createdAt": "2020-07-09T22:03:53Z",
      "updatedAt": "2020-07-10T15:48:25Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "8162de17bcb9d36ce6afbc13ce800693b0f9cd44",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "one-stream-cipher",
      "headRefOid": "2e946ea6749d3197bf56bfeeac186ba2bf1bc00e",
      "closedAt": "2020-07-10T15:48:23Z",
      "mergedAt": "2020-07-10T15:48:23Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "98a171f7c0c1cec2af30cbf80ec24073ce3e38ca"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MTIxMTU5",
          "commit": {
            "abbreviatedOid": "4a26156"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I like it, but there is some imprecision in the text. I would like to see something about detecting corruption, probably in the load balancer actions.",
          "createdAt": "2020-07-10T04:56:37Z",
          "updatedAt": "2020-07-10T05:05:11Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Do you need to say triple in the anchor?",
              "createdAt": "2020-07-10T04:56:37Z",
              "updatedAt": "2020-07-10T14:41:26Z"
            },
            {
              "originalPosition": 21,
              "body": "If you want to detect corruption, you need more than \"sufficiently large\". You need extra bits, and the more you have the more corruption you can detect.",
              "createdAt": "2020-07-10T04:58:39Z",
              "updatedAt": "2020-07-10T14:41:26Z"
            },
            {
              "originalPosition": 111,
              "body": "Check the anchor. It probably does not compile.",
              "createdAt": "2020-07-10T05:03:46Z",
              "updatedAt": "2020-07-10T14:41:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NDU4NjE0",
          "commit": {
            "abbreviatedOid": "2e946ea"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-10T14:41:57Z",
          "updatedAt": "2020-07-10T14:41:57Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "I added some text that applies to all the algorithms.",
              "createdAt": "2020-07-10T14:41:57Z",
              "updatedAt": "2020-07-10T14:41:57Z"
            }
          ]
        }
      ]
    },
    {
      "number": 43,
      "id": "MDExOlB1bGxSZXF1ZXN0NDUxNDMyODQ1",
      "title": "new stream test vectors",
      "url": "https://github.com/quicwg/load-balancers/pull/43",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Updated for the new three-pass algorithm.",
      "createdAt": "2020-07-17T20:22:35Z",
      "updatedAt": "2020-07-17T20:29:58Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "737b3ed5980745caa2a32ba9bfe64875121ddc4e",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "stream-test-vector",
      "headRefOid": "31a3d11b4f4e94b67cf72e3c4c0f741e819c84cb",
      "closedAt": "2020-07-17T20:29:56Z",
      "mergedAt": "2020-07-17T20:29:56Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "8b83ace66bf3291fabd06b48179edecf2e3bb1fe"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 44,
      "id": "MDExOlB1bGxSZXF1ZXN0NDUxNDc0MTQ1",
      "title": "Remove zero padding field",
      "url": "https://github.com/quicwg/load-balancers/pull/44",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Resolves #41",
      "createdAt": "2020-07-17T21:29:18Z",
      "updatedAt": "2020-07-20T18:39:55Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "8b83ace66bf3291fabd06b48179edecf2e3bb1fe",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "no-zero-padding",
      "headRefOid": "5058051d8b44a5b13042c57ddf0de240da796c84",
      "closedAt": "2020-07-20T18:39:51Z",
      "mergedAt": "2020-07-20T18:39:51Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "c2ba946f4d2c48d5817b5ef4f9ed438245b17b28"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMDM3OTIx",
          "commit": {
            "abbreviatedOid": "5058051"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I would like to see some text about the sparse encoding of the server id, i.e., using enough bit to ensure error detection after de-obfuscation or decryption. Probably in or near ## Security.\r\n",
          "createdAt": "2020-07-18T07:09:07Z",
          "updatedAt": "2020-07-18T07:13:04Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "There should be some text about the *minimal* length -- long enough to encode all servers, but also long enough to detect errors. Here is probably not the place, it belongs in some common text.",
              "createdAt": "2020-07-18T07:09:07Z",
              "updatedAt": "2020-07-18T07:13:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxODUyODU4",
          "commit": {
            "abbreviatedOid": "5058051"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-20T18:24:45Z",
          "updatedAt": "2020-07-20T18:24:45Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "In {{routing-algorithms}} it says:\r\n\r\nA QUIC-LB configuration MAY significantly over-provision the server ID space\r\n(i.e., provide far more codepoints than there are servers) to increase the\r\nprobability that a randomly generated Destination Connection ID is non-\r\ncompliant.\r\n\r\nI am not particularly convinced this is an important feature, so it's just a MAY. But it's there.",
              "createdAt": "2020-07-20T18:24:45Z",
              "updatedAt": "2020-07-20T18:24:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxODYzNDg4",
          "commit": {
            "abbreviatedOid": "5058051"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-20T18:39:55Z",
          "updatedAt": "2020-07-20T18:39:55Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "OK then. If we have common text that's fine.",
              "createdAt": "2020-07-20T18:39:55Z",
              "updatedAt": "2020-07-20T18:39:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 45,
      "id": "MDExOlB1bGxSZXF1ZXN0NDUxNTAwNjA4",
      "title": "Rewrite config rotation",
      "url": "https://github.com/quicwg/load-balancers/pull/45",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #42",
      "createdAt": "2020-07-17T22:13:51Z",
      "updatedAt": "2020-07-17T22:15:09Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "8b83ace66bf3291fabd06b48179edecf2e3bb1fe",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "config-rotation-terms",
      "headRefOid": "4a70f7dbb4aea251c6cd2e64b09ace56308596b3",
      "closedAt": "2020-07-17T22:15:08Z",
      "mergedAt": "2020-07-17T22:15:08Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "956b0a3644382c41362f2a8fd7a8055081492050"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 48,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU4NjY2Mjc0",
      "title": "Deleted OCID",
      "url": "https://github.com/quicwg/load-balancers/pull/48",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "by popular demand in #47.",
      "createdAt": "2020-07-29T20:09:37Z",
      "updatedAt": "2020-08-13T19:34:43Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "b6126ba11dad17b160407a10ee48dedef0b0558b",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "delete-ocid",
      "headRefOid": "bfc9c0607e9000075eb000f5447ecc45051b4099",
      "closedAt": "2020-08-13T19:34:41Z",
      "mergedAt": "2020-08-13T19:34:41Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "385254d4ae8c9233c97195e3f99fc68b352a13f9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3ODYwMzIz",
          "commit": {
            "abbreviatedOid": "b544436"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-29T20:11:21Z",
          "updatedAt": "2020-07-29T20:11:21Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3OTQxMTI2",
          "commit": {
            "abbreviatedOid": "b544436"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Yes, that works. Minor comment.",
          "createdAt": "2020-07-29T22:26:09Z",
          "updatedAt": "2020-07-29T22:27:07Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "Are you sure that \"provide robust entropy to making any sort of linkage\" is a valid English sentence? Would it be better to say \"provide robust entropy to defend against any sort of linkage\", or something like that?",
              "createdAt": "2020-07-29T22:26:09Z",
              "updatedAt": "2020-07-29T23:10:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 49,
      "id": "MDExOlB1bGxSZXF1ZXN0NDcxMjM1Mzgx",
      "title": "New test vectors",
      "url": "https://github.com/quicwg/load-balancers/pull/49",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Updated the test vectors for the latest version of the spec, added PCID, and made them usable to test server implementations.",
      "createdAt": "2020-08-20T20:52:34Z",
      "updatedAt": "2020-08-31T16:12:54Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "ca952dcf4a973c8df3c2efb9bcdfcbf8676bc581",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "new-test-vectors",
      "headRefOid": "9f81662060ce61175903dd989e0cae35e5d35d75",
      "closedAt": "2020-08-31T16:12:53Z",
      "mergedAt": "2020-08-31T16:12:53Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "1dc88e31f72c4ddeff2a7cc20e69d4034cb31201"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 52,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc2MzkzOTc5",
      "title": "Update Noncompliant DCID text",
      "url": "https://github.com/quicwg/load-balancers/pull/52",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Make it clear that the server has to provide the client with a compliant DCID if the client isn't already using one.",
      "createdAt": "2020-08-31T16:11:30Z",
      "updatedAt": "2020-10-28T22:44:30Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "ca952dcf4a973c8df3c2efb9bcdfcbf8676bc581",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "server-must-change",
      "headRefOid": "c340a6f63e1e957953ab3acd3b629d238d60a416",
      "closedAt": "2020-10-28T22:44:29Z",
      "mergedAt": "2020-10-28T22:44:29Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "1196006bfb6b239817fa528319f1f87f282500a8"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 56,
      "id": "MDExOlB1bGxSZXF1ZXN0NTEyNTc2MTk4",
      "title": "Use POSIX timestamp",
      "url": "https://github.com/quicwg/load-balancers/pull/56",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #55.",
      "createdAt": "2020-10-29T21:20:06Z",
      "updatedAt": "2020-10-30T13:56:12Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "d12573bacd05591bd4b6a4f650d563f383aea111",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "small-timestamp",
      "headRefOid": "117fa3bc3b890e6a8db835c7ac9d13819f1c1866",
      "closedAt": "2020-10-30T13:56:11Z",
      "mergedAt": "2020-10-30T13:56:11Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "a884d3d0bdf9567fb583427a1b1f4e18077aec44"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMTQ4MzAz",
          "commit": {
            "abbreviatedOid": "117fa3b"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-29T23:03:06Z",
          "updatedAt": "2020-10-29T23:03:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 58,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE1MDI3NTEy",
      "title": "Added transport parameter",
      "url": "https://github.com/quicwg/load-balancers/pull/58",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #8 and #16.",
      "createdAt": "2020-11-03T22:34:37Z",
      "updatedAt": "2021-03-18T19:19:27Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "5d17ce83c507dd6c7d2a12308fba6f129a7b7e0d",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "add-transport-parameter",
      "headRefOid": "772bf1e435171bf96bd2c9438135a45abb56a973",
      "closedAt": "2020-12-11T23:31:39Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Due to total lack of enthusiasm at IETF 109, closing this PR.",
          "createdAt": "2020-12-11T23:31:39Z",
          "updatedAt": "2020-12-11T23:31:39Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 59,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE1MDk1MzE2",
      "title": "Aead retry token",
      "url": "https://github.com/quicwg/load-balancers/pull/59",
      "state": "MERGED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Close #35 \r\n\r\nThis PR specifies how the retry token should be encoded using AEAD. This replaces the current method that uses AES ECB, and has potential vulnerabilities since encrypted addresses and encrypted ODCID might be encrypted independently. There are differences between the two solutions:\r\n\r\n* AEAD requires key and IV, not just key. The IV will have to be provisioned with the key.\r\n\r\n* AEAD requires a nonce. The proposed format defines a 64 bit \"token sequence number\". We may want to discuss this further, and specify how exactly this is generated.\r\n\r\n* The client address is not encrypted as part of the token, but is verified through AEAD\r\n\r\n* The AEAD protected token may end up 8 bytes longer than the ECB protected token: remove IP address (-16), add a nonce (+8), add the AEAD checksum (+16). On the other hand, the ECB must be padded to the nearest 16 bytes, while AEAD does not require that. Probably not very important.\r\n\r\n* I assume we are using AES128-GCM, but I suppose the specific algorithm could be provisioned with the key.\r\n\r\n\r\n",
      "createdAt": "2020-11-04T02:30:35Z",
      "updatedAt": "2025-03-05T18:55:17Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "5d17ce83c507dd6c7d2a12308fba6f129a7b7e0d",
      "headRepository": "huitema/load-balancers",
      "headRefName": "aead-retry-token",
      "headRefOid": "a926e3cf8c71c394a9c5020460ab2719657a07c3",
      "closedAt": "2020-12-18T16:38:02Z",
      "mergedAt": "2020-12-18T16:38:02Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "596688a9c0a8ca414c3d83570f197994e6db5c93"
      },
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Waiting for the resolution of the Token Sequence Number issue before updating the PR. I am tempted to just make that field 96 bits, and specify randomness.",
          "createdAt": "2020-11-04T20:02:02Z",
          "updatedAt": "2020-11-04T20:02:02Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@huitema I think we have five options:\r\n(1) A 96-bit random number for the sequence number, and just assume there are no collisions (you've computed the very low probability) -- this is wire inefficient but very easy\r\n(2) For the shared-state case, the service simply forwards packets with server-generated tokens rather than trying to validate them. Therefore this format is *only* generated by the retry service and it can use all the sequence numbers without fear of collision. -- this is very easy and wire-efficient, but slightly reduces the usefulness of the Retry Service.\r\n\r\nThen there are three variations of \"give each server some of the sequence number space\":\r\n(3a) Just put the whole (up to 18B server ID) in the token: easy, but makes big tokens. The retry service must be configured with at least 1 server ID it can use for its own tokens.\r\n(3b) Force the Retry Service to have the same QUIC-LB decoder as the load balancer, so it can extract the server ID from the CID and use that as part of the IV: most wire-efficient, but expensive for the Retry service.\r\n(3c) Assign each server a shorter ID for Retry purposes, and put in the token: medium token size, but involves the most configuration.\r\n\r\nI weakly prefer (2). if you have a different preference, I'm willing to go along with it; or we could take it to the list.\r\n",
          "createdAt": "2020-12-12T00:06:03Z",
          "updatedAt": "2020-12-12T00:06:03Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I just did a PR in Picotls to make sure that the API can let us set a 96 bit \"sequence number\". Turns out that this is also required for handling multipath.\r\n\r\nPutting the whole server ID in the token really means \"putting the whole server ID in the sequence number. If you do not do that, you risk AEAD collisions, and that's not too good. Putting the server ID in the token but not in the sequence number does not rid you of AEAD collisions, so 3a is not really an option. 3c can work if the server ID is < 32 bit. You would construct the 96 bit \"sequence number\" as 32 bits of \"short\" server ID and 64 bit of per server sequence number.\r\n\r\nI am not sure that I understand your option 2. There is no big issue for \"retry tokens\" sent through \"retry\" packets, since the protocol also indicates the CID to be used by the client. The LB can route based on the CID. There is only an issue for \"new tokens\" used in conjunction with a random IDCID.",
          "createdAt": "2020-12-12T01:54:26Z",
          "updatedAt": "2020-12-12T01:54:26Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A fuller explanation of option 2:\r\nThis design is for the shared-state Retry token, which is for cases where the Retry Service is not guaranteed to be on the path, and therefore both the server and service have to be able to generate (and validate) their own tokens.\r\n\r\nThe current design has both server and service generate tokens according to the same format. Therefore, if a service generates a token, the server can validate it; if the server generates a token, the service can validate it. Obviously, this saves the server from processing invalid tokens if the service can handle it.\r\n\r\nThe problem, of course, is if we increment sequence numbers there will be collisions between server- and service-generated sequence numbers. Option 2 would make the following changes:\r\n- Services produce a fixed-length token, in accordance with the standard format\r\n- Servers MUST NOT generate tokens of this length, but need not follow any format\r\n- Services MUST NOT process or filter Initial Packets with tokens that are not of the fixed length.\r\n\r\nThis entirely solves the sequence number problem, but it also means the server has to do a bit more work. Thus the Retry Service is offloading some of the Token generation, but not any of the token processing.\r\n\r\nWriting it carefully out like this, I don't like Option 2 as much anymore.",
          "createdAt": "2020-12-12T04:03:39Z",
          "updatedAt": "2020-12-12T04:03:39Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\"Putting the server ID in the token but not in the sequence number does not rid you of AEAD collisions, so 3a is not really an option\"\r\n\r\nto be clear, it would be in the sequence number. The point of putting it in the token is to allow the decoder to reconstruct the IV.\r\n\r\nI imagine that 32 bits would be plenty of server IDs if it doesn't need to be sparsely populated.\r\n",
          "createdAt": "2020-12-12T04:05:12Z",
          "updatedAt": "2020-12-12T04:05:12Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To sum up, I think we only have the following 2 options:\r\n\r\n(1) A 96-bit random number for the sequence number, and just assume there are no collisions (you've computed the very low probability) -- this is wire inefficient but very easy\r\n\r\n(3c) Assign each server a shorter ID for Retry purposes, and put in the token: medium token size, but involves the most configuration. For AEAD, compose the 96 bit sequence as \"(up to) 32 bit server ID\" + \"(up to) 64 bit server-chosen token ID\".\r\n\r\nThe advantage of (3c) over (1) it potentially reduced transmission overhead. For example, the server ID might well be just 16 bits, the token ID might be just 32 bits. If we have a server ID, the LB can use it to direct the incoming Initial to the server that allocated the token, which may or may not be useful. The drawback of (3c) is more configuration, and also exposing the server ID in cleartext. If server ID privacy is an issue, we need something like header protection as part of the token protection.\r\n\r\nIn both cases, we need some kind of key phase bit in the token to understand which key to use.",
          "createdAt": "2020-12-12T23:37:01Z",
          "updatedAt": "2020-12-12T23:37:01Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have tried to elaborate the two options for either random generation or server ID.",
          "createdAt": "2020-12-13T01:14:48Z",
          "updatedAt": "2020-12-13T01:14:48Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "BTW I am happy to commit if you resolve the nits and we can have a longer discussion on your DISCUSS points.",
          "createdAt": "2020-12-16T22:10:12Z",
          "updatedAt": "2020-12-16T22:10:12Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinduke I think this is ready now, but you may want to review.",
          "createdAt": "2020-12-17T04:40:27Z",
          "updatedAt": "2020-12-17T04:40:27Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinduke I think the last commit fixes the last comments.",
          "createdAt": "2020-12-18T04:37:15Z",
          "updatedAt": "2020-12-18T04:37:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNTU5NDk5",
          "commit": {
            "abbreviatedOid": "8476890"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thank you for this PR. I think this design is the way to go, modulo the open questions you've posed.",
          "createdAt": "2020-11-04T17:01:20Z",
          "updatedAt": "2020-11-04T17:18:32Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "I like the ID of prepending the server ID to the sequence number and assigning the Retry Service one or more \"server IDs\" that keep the sequence number spaces separate, but one problem is that the server ID can be as much as 18 Bytes.\r\n\r\nI see three ways forward:\r\n- assign each server a second server ID for these purposes, (blecch)\r\n- just use random numbers\r\n- eliminate the (already very weak) ability of Shared State Retry Services to validate incoming tokens -- they only generate them. Then, each server can do whatever it wants with its self-generated tokens, which should easily be distinguishable by token length or whatever, and the service can use the entire sequence number space without fear of collision.\r\n\r\nI'm leaning towards the third.",
              "createdAt": "2020-11-04T17:01:20Z",
              "updatedAt": "2020-12-18T16:37:14Z"
            },
            {
              "originalPosition": 28,
              "body": "Can you file a separate issue for that? It applies to both types of Retry Service and we should address it consistently for both.\r\n\r\nI don't feel strongly one way or the other. I believe the point of that check is so that *some* servers enforce compliance to encourage good behavior, and I don't think Retry Services need to be part of that effort.",
              "createdAt": "2020-11-04T17:10:37Z",
              "updatedAt": "2020-12-18T16:37:14Z"
            },
            {
              "originalPosition": 101,
              "body": "Should this make clear that the authentication tag is appended to the end of the token (assuming it is)?",
              "createdAt": "2020-11-04T17:12:06Z",
              "updatedAt": "2020-12-18T16:37:14Z"
            },
            {
              "originalPosition": 48,
              "body": "s/follow/follows",
              "createdAt": "2020-11-04T17:12:33Z",
              "updatedAt": "2020-12-18T16:37:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNjkwMTI1",
          "commit": {
            "abbreviatedOid": "8476890"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-04T19:57:03Z",
          "updatedAt": "2020-11-04T19:57:04Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "Birthday paradox says with a 64 bit random field you will expect collisions after 2^32 tokens -- and that you have to change the key sooner than that if you want to minimize the risk. If you want the risk of collision below 10E-5 (five nines...) then you should not use the key more than 19 million times.\r\n\r\nI should be technically possible to make the identifier 12 bytes long -- that's the normal size of the IV for AES GCM. The same reasoning says that the key should not be use more that 4.0 E+14 times -- 400 trillion times. That may be the way to go. Better than trying to squeeze an 18 bytes ID there.\r\n\r\nOr we would have to use something a bit more exotic than AES GCM, but I would rather not go there.",
              "createdAt": "2020-11-04T19:57:04Z",
              "updatedAt": "2020-12-18T16:37:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNjkyMDAy",
          "commit": {
            "abbreviatedOid": "8476890"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-04T19:59:50Z",
          "updatedAt": "2020-11-04T19:59:50Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "The PN s only used with the RETRY TOKEN format, which is server specific. So it fits naturally in the server specific part.",
              "createdAt": "2020-11-04T19:59:50Z",
              "updatedAt": "2020-12-18T16:37:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNjkyNDQz",
          "commit": {
            "abbreviatedOid": "8476890"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-04T20:00:26Z",
          "updatedAt": "2020-11-04T20:00:26Z",
          "comments": [
            {
              "originalPosition": 101,
              "body": "Yes it is. I copied the text from the QUIC-TLS draft, the tag is considered part of the encrypted data.",
              "createdAt": "2020-11-04T20:00:26Z",
              "updatedAt": "2020-12-18T16:37:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNjkyNjQx",
          "commit": {
            "abbreviatedOid": "8476890"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-04T20:00:43Z",
          "updatedAt": "2020-11-04T20:00:44Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "OK, will fix.",
              "createdAt": "2020-11-04T20:00:44Z",
              "updatedAt": "2020-12-18T16:37:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNjk4NjU1",
          "commit": {
            "abbreviatedOid": "8476890"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-04T20:09:57Z",
          "updatedAt": "2020-11-04T20:09:58Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Yes, but a non-shared-state retry service might be required to include the initial packet number so that the server can do the validation.\r\n\r\nThat said, making the retry service do initial header decryption is a terrible idea. So let's rule out having any type of retry service encode the packet number.",
              "createdAt": "2020-11-04T20:09:57Z",
              "updatedAt": "2020-12-18T16:37:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNzAxODI3",
          "commit": {
            "abbreviatedOid": "8476890"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-04T20:14:57Z",
          "updatedAt": "2020-11-04T20:14:57Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "One way to manage the key rotation would be to actually configure both entities with a secret and make the retry service and server derive the key from that, so that it can be rotated using some signal that the retry service puts in the token?",
              "createdAt": "2020-11-04T20:14:57Z",
              "updatedAt": "2020-12-18T16:37:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNzAyMDU4",
          "commit": {
            "abbreviatedOid": "8476890"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-04T20:15:17Z",
          "updatedAt": "2020-11-04T20:15:17Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "Or we could just do my third option...",
              "createdAt": "2020-11-04T20:15:17Z",
              "updatedAt": "2020-12-18T16:37:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNzAyNjk0",
          "commit": {
            "abbreviatedOid": "8476890"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-04T20:16:13Z",
          "updatedAt": "2020-11-04T20:16:14Z",
          "comments": [
            {
              "originalPosition": 101,
              "body": "With the \"opaque\" data and so on it would be helpful to show exactly where the tag goes, so as to leave no ambiguity.",
              "createdAt": "2020-11-04T20:16:13Z",
              "updatedAt": "2020-12-18T16:37:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MTEyODk3",
          "commit": {
            "abbreviatedOid": "12b9c64"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-12-16T21:50:15Z",
          "updatedAt": "2020-12-16T22:08:37Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Can we call this a \"generator ID\", in order to (1) not confuse it with the load balancing server ID, and (2) to make clear that the retry service will need at least one too?",
              "createdAt": "2020-12-16T21:50:15Z",
              "updatedAt": "2020-12-18T16:37:14Z"
            },
            {
              "originalPosition": 40,
              "body": "s/keyand/key and",
              "createdAt": "2020-12-16T21:51:17Z",
              "updatedAt": "2020-12-18T16:37:14Z"
            },
            {
              "originalPosition": 94,
              "body": "If it's the expiration time, then each token generator can specify its own token expiration time; it it's the start time, than the token consumer is always in control of the expiration. The difference is not huge. Consumer decisions happen later, and therefore have (slightly) more information. This is related to your DISCUSS point at Line 871; if the Retry service isn't checking timestamps, than it seems easier to configure if only the servers need to worry about the proper expiration interval.\r\n\r\nI don't feel strongly either way.",
              "createdAt": "2020-12-16T22:02:32Z",
              "updatedAt": "2020-12-18T16:37:14Z"
            },
            {
              "originalPosition": 193,
              "body": "Why wouldn't it? As there are multiple token generators in this model, the time thresholds are going to have be forgiving about clock skew anyway.",
              "createdAt": "2020-12-16T22:05:56Z",
              "updatedAt": "2020-12-18T16:37:14Z"
            },
            {
              "originalPosition": 176,
              "body": "The Retry Service also needs a \"generator ID\". Arguably, it would make sense to have more than one (it presumably will generate tokens in much higher volume).",
              "createdAt": "2020-12-16T22:07:45Z",
              "updatedAt": "2020-12-18T16:37:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MTg3NjM4",
          "commit": {
            "abbreviatedOid": "12b9c64"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-17T00:16:40Z",
          "updatedAt": "2020-12-17T00:16:40Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "We agreed over the phone not to have a \"controlled\" configuration, so we'll just consolidate these two fields into a 96-bit nonce.",
              "createdAt": "2020-12-17T00:16:40Z",
              "updatedAt": "2020-12-18T16:37:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MTg4MTY1",
          "commit": {
            "abbreviatedOid": "12b9c64"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-17T00:17:56Z",
          "updatedAt": "2020-12-17T00:17:57Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "We talked and realized that as the NEW_TOKEN is also following this format, it is far better for the token to encode the expiration time so as not to force the Service to implement multiple policies and disambiguate the two types.",
              "createdAt": "2020-12-17T00:17:57Z",
              "updatedAt": "2020-12-18T16:37:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MTg4MjU2",
          "commit": {
            "abbreviatedOid": "12b9c64"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-17T00:18:13Z",
          "updatedAt": "2020-12-17T00:18:14Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "Disregard, no server IDs anymore",
              "createdAt": "2020-12-17T00:18:14Z",
              "updatedAt": "2020-12-18T16:37:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MTg4NDA0",
          "commit": {
            "abbreviatedOid": "12b9c64"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-17T00:18:36Z",
          "updatedAt": "2020-12-17T00:18:36Z",
          "comments": [
            {
              "originalPosition": 193,
              "body": "Result of call: yes, the service should look at the timestamp (with allowances for clock skew)",
              "createdAt": "2020-12-17T00:18:36Z",
              "updatedAt": "2020-12-18T16:37:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1MDgwOTY0",
          "commit": {
            "abbreviatedOid": "1547d4b"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks great! If my proposed nits seem reasonable to you, hit commit on each of them and then I'll merge this.",
          "createdAt": "2020-12-17T23:57:35Z",
          "updatedAt": "2020-12-18T00:32:49Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "```suggestion\r\nAEAD key and AEAD IV are provisioned by the configuration agent. \r\n```",
              "createdAt": "2020-12-18T00:02:09Z",
              "updatedAt": "2020-12-18T16:37:14Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\n```",
              "createdAt": "2020-12-18T00:02:20Z",
              "updatedAt": "2020-12-18T16:37:14Z"
            },
            {
              "originalPosition": 112,
              "body": "```suggestion\r\nThe tokens are protected using AES128-GCM as follows:\r\n```",
              "createdAt": "2020-12-18T00:16:03Z",
              "updatedAt": "2020-12-18T16:37:14Z"
            },
            {
              "originalPosition": 117,
              "body": "```suggestion\r\n```",
              "createdAt": "2020-12-18T00:17:40Z",
              "updatedAt": "2020-12-18T16:37:14Z"
            },
            {
              "originalPosition": 116,
              "body": "```suggestion\r\n*\r\n```",
              "createdAt": "2020-12-18T00:18:04Z",
              "updatedAt": "2020-12-18T16:37:14Z"
            },
            {
              "originalPosition": 118,
              "body": "```suggestion\r\n\r\n```",
              "createdAt": "2020-12-18T00:19:04Z",
              "updatedAt": "2020-12-18T16:37:14Z"
            },
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n- A 96 bit unique token number transmitted in clear text, but\r\n```",
              "createdAt": "2020-12-18T00:19:21Z",
              "updatedAt": "2020-12-18T16:37:14Z"
            },
            {
              "originalPosition": 27,
              "body": "```suggestion\r\nThe 96 bit unique token number is set to a random value\r\n```",
              "createdAt": "2020-12-18T00:19:40Z",
              "updatedAt": "2020-12-18T16:37:14Z"
            },
            {
              "originalPosition": 120,
              "body": "```suggestion\r\nwith zeros to the size of the IV. The exclusive OR of the padded unique token\r\n```",
              "createdAt": "2020-12-18T00:20:39Z",
              "updatedAt": "2020-12-18T16:37:14Z"
            },
            {
              "originalPosition": 148,
              "body": "```suggestion\r\nof the AEAD is transmitted in place of the token body.\r\n```",
              "createdAt": "2020-12-18T00:21:07Z",
              "updatedAt": "2020-12-18T16:37:14Z"
            }
          ]
        }
      ]
    },
    {
      "number": 61,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIyOTExOTQw",
      "title": "Add ECMP CID algorithm",
      "url": "https://github.com/quicwg/load-balancers/pull/61",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I tried to make this a subset of the plaintext algorithm, but the differences were substantial enough(ie: there are no server IDs) that I created a new algorithm.",
      "createdAt": "2020-11-18T04:57:47Z",
      "updatedAt": "2021-01-07T18:39:05Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "5d17ce83c507dd6c7d2a12308fba6f129a7b7e0d",
      "headRepository": "ianswett/load-balancers",
      "headRefName": "patch-1",
      "headRefOid": "253862be2093406f455ee2216aa268fb23b2cfe0",
      "closedAt": "2021-01-07T18:39:05Z",
      "mergedAt": "2021-01-07T18:39:05Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "2b85fff869682105a96b97ae539b119192bceb5c"
      },
      "comments": [
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "@ianswett I'm a bit confused on the difference here with the vanilla plaintext algorithm. Is the only difference that the LB routes initial packets specially? Does the existing plaintext algorithm preclude that behavior?",
          "createdAt": "2020-11-18T07:35:53Z",
          "updatedAt": "2020-11-18T07:35:53Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think it's precluded, but I do think it's different enough it's worth documenting, but I realize the difference is subtle.  @martinduke had the same thought, so I'll try to further clarify this PR.\r\n\r\nThis is a way to adapt existing stateful flow-tracking ECMP L4 load-balancers to QUIC with almost no server coordination.  The plaintext requires substantially more coordination and requires leaving some areas of the connection ID space unusable in order to allow for adding servers.  When each new flow comes in, the L4 load-balancer can decide where to send it, increasing the evenness of traffic.",
          "createdAt": "2020-11-18T15:41:43Z",
          "updatedAt": "2020-11-18T15:41:43Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the PR. There are definite simplicity benefits to not having explicitly assigned server IDs; if we can work through the issues here, I'd just as soon use this framework to *replace* PCID.\r\n\r\nPresumably the LB is maintaining a table of its SID assignments, and the servers are maintaining lists of all SIDs they've observed.\r\n\r\nAlso, if a server goes down, it seems straightforward that the LB would delete its entry and those SIDs would be free to reallocation to other servers.\r\n\r\nWe would rewrite the non-compliant DCID section a bit, but that seems simple enough.\r\n\r\nSo here are some issues:\r\n- If the clients always initiate with a DCID that is shorter than the minimum, then there is no way for the server to obtain its first server ID. So there would appear to be a strict limit of 7 byte SIDs as v1 specifies a minimum CIDL of 8.\r\n- I think the SID space has to be pretty big because this approach will be profligate with SIDs. Most new connections will consume a new SID codepoint for the existing pool of servers. This is going to be a pretty memory-intensive table! You will probably needs hundreds of thousands (?) of times more entries than you would have for PCID.\r\n- Profligate assignment of SIDs will eventually crowd out the space to bring any new servers on unless other servers die and release their SIDs. Unless there's some kind of timeout mechanism? [1] [2]\r\n\r\n[1] This mechanism could be something like, \"If a server hasn't received a packet in X minutes for a certain SID, it MUST retire that CID with that SID on any connection still in use\" coupled with a load balancer timeout on its mapping after X minutes.\r\n[2] Alternatively, we could do something clever with config rotation where, when the table gets full, or there's a new server, the LB wakes up the config agent to give everyone new CR bits, and this is a cue to flush the SID table.",
          "createdAt": "2020-12-12T01:18:47Z",
          "updatedAt": "2020-12-12T01:18:47Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Filed #64 as a tracking issue.",
          "createdAt": "2020-12-12T01:21:31Z",
          "updatedAt": "2020-12-12T01:21:31Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "I'm still not convinced we should have a separate algorithm for this. Instead, I'd argue we should ensure the existing plaintext algorithm is generic enough to handle all related scenarios.",
          "createdAt": "2020-12-22T17:05:45Z",
          "updatedAt": "2020-12-22T17:05:45Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ianswett and discussed this proposal. Google's operational experience is that the memory needs are not onerous. We agreed that this algorithm should have a \"LB Idle timeout\" parameter after which SID allocations will be freed. Also, server IDs must be no more 7 octets in length (or else 8B client-generated CIDs will not successfully populate the server's table).\r\n\r\nThe advantages of this with respect to PCID is that there is much less configuration and that it conforms more closely to some existing load balancers. The disadvantage is that it requires much more per-connection state at the load balancer.\r\n\r\n",
          "createdAt": "2020-12-22T19:19:25Z",
          "updatedAt": "2020-12-22T19:19:25Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am coming around on this design. When this PR is revised, we will go to the list with three options:\r\n\r\n1) Have two unencrypted algorithms\r\n2) Embrace low-state, high-configuration and stick with existing PCID\r\n3) Pick the opposite and replace PCID with this design",
          "createdAt": "2020-12-22T19:20:35Z",
          "updatedAt": "2020-12-22T19:20:35Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As @ianswett is inundated with IESG comments right now, I'm going to commit this PR, make some other edits along the lines of what we agreed, and then take the larger issue to the list.",
          "createdAt": "2021-01-07T18:38:41Z",
          "updatedAt": "2021-01-07T18:38:41Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzMTEwNTk0",
          "commit": {
            "abbreviatedOid": "7f02a62"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T05:17:21Z",
          "updatedAt": "2020-11-18T05:17:21Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "```suggestion\r\nbeginning with the second octet. If these octets match an existing server ID,\r\n```",
              "createdAt": "2020-11-18T05:17:21Z",
              "updatedAt": "2020-12-12T00:18:36Z"
            }
          ]
        }
      ]
    },
    {
      "number": 63,
      "id": "MDExOlB1bGxSZXF1ZXN0NTM3NTc4NjAy",
      "title": "Paragraph on SNI routing",
      "url": "https://github.com/quicwg/load-balancers/pull/63",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #60.",
      "createdAt": "2020-12-12T00:17:26Z",
      "updatedAt": "2020-12-16T00:02:37Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "a564b0c3cca21a0dea6a41488924dfdc49ce3b3a",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "sni-switching",
      "headRefOid": "d4234f6bbf9903e0cf3d4a79570426e7767a6b18",
      "closedAt": "2020-12-16T00:02:35Z",
      "mergedAt": "2020-12-16T00:02:35Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "847a6803277cf53b0f13d98b815d939bffca800b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 69,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQzNzk2Mzg1",
      "title": "Rewrite abstract",
      "url": "https://github.com/quicwg/load-balancers/pull/69",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Less emphasis on load balancers, more on the other stuff. More text on the use cases and less on \"how\".",
      "createdAt": "2020-12-22T00:23:58Z",
      "updatedAt": "2020-12-22T17:23:07Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "f45a900c9182a716d61ab2e540905444a13c6b7b",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "new-abstract",
      "headRefOid": "9a6748f5164f819c08e3e08503d9286c26166b19",
      "closedAt": "2020-12-22T17:23:06Z",
      "mergedAt": "2020-12-22T17:23:06Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "9c75632c7b24329254be88e602cc6b456338c7ed"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MjI4NzQx",
          "commit": {
            "abbreviatedOid": "c298464"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-22T17:03:40Z",
          "updatedAt": "2020-12-22T17:03:40Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "It's not necessarily just \"agreeing to certain conventions\" but also requires shared state sometime. I think that might be important to spell out, because it means there must some type of communication or shared configuration between the servers and infrastructure. I'm not quite sure how best to put that here though.",
              "createdAt": "2020-12-22T17:03:40Z",
              "updatedAt": "2020-12-22T17:22:20Z"
            }
          ]
        }
      ]
    },
    {
      "number": 70,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQzODAyNzcy",
      "title": "Crypto Agility",
      "url": "https://github.com/quicwg/load-balancers/pull/70",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #65",
      "createdAt": "2020-12-22T00:46:22Z",
      "updatedAt": "2020-12-23T02:44:40Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "f45a900c9182a716d61ab2e540905444a13c6b7b",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "crypto-agile",
      "headRefOid": "a0d48f95d40d58ed59188c6151eddfe1d0ea4795",
      "closedAt": "2020-12-23T02:44:39Z",
      "mergedAt": "2020-12-23T02:44:39Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "f1243d061fc5aaaeb763ea9e1d38a502c6cc6411"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3NDQzMDE1",
          "commit": {
            "abbreviatedOid": "0f00ed3"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM.  A suggestion, but I'm OK either way.",
          "createdAt": "2020-12-23T00:36:23Z",
          "updatedAt": "2020-12-23T00:36:36Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nEncryption in the algorithms below uses the AES-128-ECB cipher. Future standards\r\ncould add new algorithms that use other ciphers to provide cryptographic agility in\r\naccordance with {{?RFC7696}}. QUIC-LB implementations SHOULD be\r\n```\r\nNo need to mention deprecation; the important factor here is that you have a path to introducing new algorithms.",
              "createdAt": "2020-12-23T00:36:23Z",
              "updatedAt": "2020-12-23T02:43:28Z"
            }
          ]
        }
      ]
    },
    {
      "number": 71,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQzODA3ODIx",
      "title": "Clean up Retry Service Text",
      "url": "https://github.com/quicwg/load-balancers/pull/71",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fix #67 and #68",
      "createdAt": "2020-12-22T01:07:24Z",
      "updatedAt": "2021-01-08T19:15:55Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "f45a900c9182a716d61ab2e540905444a13c6b7b",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "retry-cleanup",
      "headRefOid": "30830a71f1cc5932027c662adcf46b7205c55cfa",
      "closedAt": "2021-01-07T17:41:22Z",
      "mergedAt": "2021-01-07T17:41:22Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "e356119aaeb61a79be9f592e450364328e69410e"
      },
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks Christian,\n\nYour comments ended up as an editorial rewrite of the section, with port\nverification added.\n\nOn Thu, Jan 7, 2021 at 6:05 PM Christian Huitema <notifications@github.com>\nwrote:\n\n> *@huitema* commented on this pull request.\n>\n> Most changes appear editorial, except for the addition of the port number\n> field. If you add that port, you need to also specify how it should be\n> processed!\n> ------------------------------\n>\n> In draft-ietf-quic-load-balancers.md\n> <https://github.com/quicwg/load-balancers/pull/71#discussion_r553692915>:\n>\n> > @@ -603,7 +603,7 @@ Retry tokens generated by the service MUST have the format below.\n>  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n>  |0| ODCIL (7) |   RSCIL (8)   |\n>  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n> -|        Original Destination Connection ID (0..160)            |\n> +|        Original Destination Connection ID (64..160)           |\n>  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n>\n> Yes, that's correct. AT least for QUIC V1.\n> ------------------------------\n>\n> In draft-ietf-quic-load-balancers.md\n> <https://github.com/quicwg/load-balancers/pull/71#discussion_r553693388>:\n>\n> > @@ -621,7 +621,8 @@ has the following additional fields:\n>\n>  ODCIL: The length of the original destination connection ID from the triggering\n>  Initial packet. This is in cleartext to be readable for the server, but\n> -authenticated later in the token.\n> +authenticated later in the token. The Retry Service SHOULD reject any token\n> +in which the value is less than 8.\n>\n>\n> .. at least as long as we are doing QUIC V1. This is not strictly speaking\n> part of the QUIC invariants. But OK, fine.\n> ------------------------------\n>\n> In draft-ietf-quic-load-balancers.md\n> <https://github.com/quicwg/load-balancers/pull/71#discussion_r553695122>:\n>\n> > @@ -741,6 +746,10 @@ MUST set this field to zero.\n>  RSCIL: The retry source connection ID length. Tokens in NEW_TOKEN frames MUST\n>  set this field to zero.\n>\n> +Port: The Source Port of the UDP datagram that triggered the Retry packet.\n> +This field MUST be present if and only if the ODCIL is greater than zero. This\n> +field is therefore always absent in tokens in NEW_TOKEN frames.\n> +\n>\n> I think you need to specify how that field is processed. What is the\n> expectation? Shall the server verify that the port matches? Is that\n> something that the LB should do?\n> ------------------------------\n>\n> In draft-ietf-quic-load-balancers.md\n> <https://github.com/quicwg/load-balancers/pull/71#discussion_r553695509>:\n>\n> > @@ -752,14 +761,15 @@ the expiration time of the token as a number of seconds in POSIX time (see Sec.\n>  4.16 of {{TIME_T}}).\n>\n>  Opaque Data: The server may use this field to encode additional information,\n> -such as congestion window, RTT, or MTU. Opaque data MAY also allow servers to\n> -distinguish between retry tokens (which trigger use of certain transport\n> -parameters) and NEW_TOKEN frame tokens.\n> +such as congestion window, RTT, or MTU. The Retry Service MUST have zero-length\n> +opaque data.\n>\n>\n> OK.\n> ------------------------------\n>\n> In draft-ietf-quic-load-balancers.md\n> <https://github.com/quicwg/load-balancers/pull/71#discussion_r553695966>:\n>\n> > @@ -778,7 +788,13 @@ On the wire, the token is presented as:\n>  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n>  | AEAD Encrypted Token (variable)                               |\n>  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n> -| AEAD Checksum (variable, function of encryption algorithm)    |                               |\n> +|                                                               |\n> ++                                                               +\n> +|                                                               |\n> ++                      AEAD Checksum (128)                      +\n> +|                                                               |\n> ++                                                               +\n> +|                                                               |\n>  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n>  ~~~\n>\n>\n> OK.\n> ------------------------------\n>\n> In draft-ietf-quic-load-balancers.md\n> <https://github.com/quicwg/load-balancers/pull/71#discussion_r553698880>:\n>\n> > @@ -852,9 +873,8 @@ the server can issue an up-to-date token to the client.\n>\n>  When issuing Retry or NEW_TOKEN tokens, the server MUST include the client IP\n>  address in the authenticated data as specified in\n> -{{token-protection-with-aead}}. It MUST include a means of distinguishing\n> -service-generated Retry tokens, server-generated Retry tokens (if different),\n> -and NEW_TOKEN tokens.\n> +{{token-protection-with-aead}}. The ODCIL and RSCIL fields are zero for\n> +NEW_TOKEN tokens, making them easily distinguishable from Retry tokens.\n>\n>\n> The text about port verification should probably be added there, or in the\n> next paragraphs.\n>\n> \u2014\n> You are receiving this because you modified the open/close state.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/quicwg/load-balancers/pull/71#pullrequestreview-563949272>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AF2EYEOXSI37MYFIOUIQMLDSYZR5TANCNFSM4VE6ECJA>\n> .\n>\n",
          "createdAt": "2021-01-08T19:15:54Z",
          "updatedAt": "2021-01-08T19:15:54Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MjI1MzA1",
          "commit": {
            "abbreviatedOid": "71923d2"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-22T16:58:11Z",
          "updatedAt": "2020-12-22T16:58:11Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzOTQ5Mjcy",
          "commit": {
            "abbreviatedOid": "30830a7"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Most changes appear editorial, except for the addition of the port number field. If you add that port, you need to also specify how it should be processed!",
          "createdAt": "2021-01-08T01:43:03Z",
          "updatedAt": "2021-01-08T02:04:59Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Yes, that's correct. AT least for QUIC V1.",
              "createdAt": "2021-01-08T01:43:03Z",
              "updatedAt": "2021-01-08T02:04:59Z"
            },
            {
              "originalPosition": 16,
              "body": ".. at least as long as we are doing QUIC V1. This is not strictly speaking part of the QUIC invariants. But OK, fine.",
              "createdAt": "2021-01-08T01:44:31Z",
              "updatedAt": "2021-01-08T02:04:59Z"
            },
            {
              "originalPosition": 63,
              "body": "I think you need to specify how that field is processed. What is the expectation? Shall the server verify that the port matches? Is that something that the LB should do?\r\n\r\n\r\n",
              "createdAt": "2021-01-08T01:50:35Z",
              "updatedAt": "2021-01-08T02:04:59Z"
            },
            {
              "originalPosition": 76,
              "body": "OK.",
              "createdAt": "2021-01-08T01:51:58Z",
              "updatedAt": "2021-01-08T02:04:59Z"
            },
            {
              "originalPosition": 101,
              "body": "OK.",
              "createdAt": "2021-01-08T01:53:33Z",
              "updatedAt": "2021-01-08T02:04:59Z"
            },
            {
              "originalPosition": 123,
              "body": "The text about port verification should probably be added there, or in the next paragraphs. ",
              "createdAt": "2021-01-08T02:03:53Z",
              "updatedAt": "2021-01-08T02:05:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0NDcyOTM5",
          "commit": {
            "abbreviatedOid": "30830a7"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-08T18:07:10Z",
          "updatedAt": "2021-01-08T18:07:11Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Retry services are version-specific, so this is OK.",
              "createdAt": "2021-01-08T18:07:11Z",
              "updatedAt": "2021-01-08T18:07:11Z"
            }
          ]
        }
      ]
    },
    {
      "number": 75,
      "id": "MDExOlB1bGxSZXF1ZXN0NTUxMjA0MTQy",
      "title": "Sync Retry-cleanup with master",
      "url": "https://github.com/quicwg/load-balancers/pull/75",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-01-07T17:39:58Z",
      "updatedAt": "2021-01-07T17:41:23Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "30830a71f1cc5932027c662adcf46b7205c55cfa",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "master",
      "headRefOid": "e356119aaeb61a79be9f592e450364328e69410e",
      "closedAt": "2021-01-07T17:41:23Z",
      "mergedAt": "2021-01-07T17:41:23Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "e356119aaeb61a79be9f592e450364328e69410e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 76,
      "id": "MDExOlB1bGxSZXF1ZXN0NTUxMjIzOTQw",
      "title": "Use quic-transport notation",
      "url": "https://github.com/quicwg/load-balancers/pull/76",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Resolves #73",
      "createdAt": "2021-01-07T18:20:26Z",
      "updatedAt": "2021-01-07T18:32:55Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "e356119aaeb61a79be9f592e450364328e69410e",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "quic-notation",
      "headRefOid": "6b9aad406902478dd2146bbae7d1e5af8b3f0112",
      "closedAt": "2021-01-07T18:32:54Z",
      "mergedAt": "2021-01-07T18:32:54Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "86649a626f257642a4d837780e6379c0b3d097c6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzNzIyOTg0",
          "commit": {
            "abbreviatedOid": "6b9aad4"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-07T18:28:56Z",
          "updatedAt": "2021-01-07T18:28:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 77,
      "id": "MDExOlB1bGxSZXF1ZXN0NTUxMzg4NDE2",
      "title": "Cleanup of ECMP/Low-config design",
      "url": "https://github.com/quicwg/load-balancers/pull/77",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "follow-on to #61, also fixing #64",
      "createdAt": "2021-01-07T23:27:57Z",
      "updatedAt": "2021-01-11T21:37:13Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "d985a9f171ec244f1c9290315e4ee5bf8c3b922d",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "ecmp-edits",
      "headRefOid": "1e3a1d94bd921003bd7b7b5ac7964169018f8a9f",
      "closedAt": "2021-01-11T21:37:12Z",
      "mergedAt": "2021-01-11T21:37:11Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "59321280e476bba2ffdb785256fc2f13995de069"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1NjM2NDY0",
          "commit": {
            "abbreviatedOid": "bcc4464"
          },
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks for adding all this extra detail, I think this will make it a lot clearer to readers.",
          "createdAt": "2021-01-11T18:40:24Z",
          "updatedAt": "2021-01-11T20:42:22Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Q: Does it have to be in octets?  It seems like it could be in bits if one wanted?",
              "createdAt": "2021-01-11T18:40:24Z",
              "updatedAt": "2021-01-11T21:34:10Z"
            },
            {
              "originalPosition": 53,
              "body": "```suggestion\r\nhave at least enough entropy to have a different code point for each server. It MUST be\r\n```",
              "createdAt": "2021-01-11T18:43:00Z",
              "updatedAt": "2021-01-11T21:34:10Z"
            },
            {
              "originalPosition": 68,
              "body": "```suggestion\r\nexisting server ID, the packets are routed to the matching server ID. As there are no\r\n```",
              "createdAt": "2021-01-11T18:52:18Z",
              "updatedAt": "2021-01-11T21:34:10Z"
            },
            {
              "originalPosition": 82,
              "body": "Editorial comment: I find the word non-compliant a bit odd in this context.  No need to change it now, but I feel like there might be a slightly better name.",
              "createdAt": "2021-01-11T18:54:38Z",
              "updatedAt": "2021-01-11T21:34:10Z"
            },
            {
              "originalPosition": 97,
              "body": "I'm a bit confused about how multiple configurations are intended to be used.  Is this just the concept that you can rotate configs and you want to pick the newest config when adding a new server ID?",
              "createdAt": "2021-01-11T20:32:08Z",
              "updatedAt": "2021-01-11T21:34:10Z"
            },
            {
              "originalPosition": 94,
              "body": "It might be worth summarizing what the following steps are intended to do.  I think they're intending to use the existing bytes in the DCID as the Server ID with the most recent config?",
              "createdAt": "2021-01-11T20:37:17Z",
              "updatedAt": "2021-01-11T21:34:10Z"
            },
            {
              "originalPosition": 141,
              "body": "```suggestion\r\nA server SHOULD have a mechanism to stop using some server IDs if the list\r\n```",
              "createdAt": "2021-01-11T20:40:11Z",
              "updatedAt": "2021-01-11T21:34:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1NzQ4NDQz",
          "commit": {
            "abbreviatedOid": "51640df"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-11T21:22:00Z",
          "updatedAt": "2021-01-11T21:22:00Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I suppose that applies to all the algorithms, but... yech.",
              "createdAt": "2021-01-11T21:22:00Z",
              "updatedAt": "2021-01-11T21:34:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1NzQ4ODc0",
          "commit": {
            "abbreviatedOid": "51640df"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-11T21:22:40Z",
          "updatedAt": "2021-01-11T21:22:41Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "This is defined at the top of the algorithms section, and is critical to the spec. I'm happy to pick another name.",
              "createdAt": "2021-01-11T21:22:41Z",
              "updatedAt": "2021-01-11T21:34:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1NzUxMDk3",
          "commit": {
            "abbreviatedOid": "51640df"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-11T21:26:00Z",
          "updatedAt": "2021-01-11T21:26:00Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "QUIC-LB can maintain up to three simultaneous configurations. If a CID arrives with the codepoint for one of them, it routes using it. If it arrives with '11', it's 4-tuple routed.\r\n\r\nClient generated-CIDs will generally be non-compliant and be routed arbitrarily, and then that CID will be replaced. With this algorithm, however, we need to extract a server ID even though the config rotation bits might not match a known config.\r\n\r\nIf the CID has unknown config rotation bits and there is one low-config CID configuration, this is easy. However, if there are two, we have to know how long of an SID to extract and which table to put it in. The heuristic here isn't perfect, but it will at least be consistent.",
              "createdAt": "2021-01-11T21:26:00Z",
              "updatedAt": "2021-01-11T21:34:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1NzUxNzUy",
          "commit": {
            "abbreviatedOid": "51640df"
          },
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-11T21:26:58Z",
          "updatedAt": "2021-01-11T21:26:58Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "File an issue and keep it as is for now?",
              "createdAt": "2021-01-11T21:26:58Z",
              "updatedAt": "2021-01-11T21:34:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1NzUyMDg0",
          "commit": {
            "abbreviatedOid": "51640df"
          },
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-11T21:27:29Z",
          "updatedAt": "2021-01-11T21:27:30Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "Yeah, it's a bit of a bikeshed, I'll tell you if I think of something better.",
              "createdAt": "2021-01-11T21:27:30Z",
              "updatedAt": "2021-01-11T21:34:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1NzU1MzU5",
          "commit": {
            "abbreviatedOid": "51640df"
          },
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-11T21:32:35Z",
          "updatedAt": "2021-01-11T21:32:35Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "Thanks, this makes sense.  A summary of what the algorithm is attempting to do would still be useful.",
              "createdAt": "2021-01-11T21:32:35Z",
              "updatedAt": "2021-01-11T21:34:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1NzU3MzY5",
          "commit": {
            "abbreviatedOid": "1e3a1d9"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-11T21:34:32Z",
          "updatedAt": "2021-01-11T21:34:32Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "fixed",
              "createdAt": "2021-01-11T21:34:32Z",
              "updatedAt": "2021-01-11T21:34:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1NzU4OTY2",
          "commit": {
            "abbreviatedOid": "1e3a1d9"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-11T21:37:03Z",
          "updatedAt": "2021-01-11T21:37:03Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Filed #80 ",
              "createdAt": "2021-01-11T21:37:03Z",
              "updatedAt": "2021-01-11T21:37:03Z"
            }
          ]
        }
      ]
    },
    {
      "number": 78,
      "id": "MDExOlB1bGxSZXF1ZXN0NTUxNTI3ODU4",
      "title": "Add security considerations for retry token encryption",
      "url": "https://github.com/quicwg/load-balancers/pull/78",
      "state": "MERGED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Close #71",
      "createdAt": "2021-01-08T06:05:37Z",
      "updatedAt": "2025-03-05T18:55:15Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "d985a9f171ec244f1c9290315e4ee5bf8c3b922d",
      "headRepository": "huitema/load-balancers",
      "headRefName": "retry-sec-issues",
      "headRefOid": "43784c587755777f50564aa03d89e9a285aa0800",
      "closedAt": "2021-01-11T15:10:52Z",
      "mergedAt": "2021-01-11T15:10:52Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "88aa81ced7b6d953796fbee9c2460c019e9db567"
      },
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinduke please take a look.",
          "createdAt": "2021-01-08T06:06:19Z",
          "updatedAt": "2021-01-08T06:06:19Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks Christian, this looks great.",
          "createdAt": "2021-01-11T15:10:47Z",
          "updatedAt": "2021-01-11T15:10:47Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1NDQzNTM0",
          "commit": {
            "abbreviatedOid": "4b012d3"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-11T15:10:22Z",
          "updatedAt": "2021-01-11T15:10:23Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "```suggestion\r\nIt is prudent to adopt the same limit here, and configure the service in such a way that\r\n```",
              "createdAt": "2021-01-11T15:10:23Z",
              "updatedAt": "2021-01-11T15:10:28Z"
            }
          ]
        }
      ]
    },
    {
      "number": 79,
      "id": "MDExOlB1bGxSZXF1ZXN0NTUxOTEyNTA0",
      "title": "Address Christian's late review",
      "url": "https://github.com/quicwg/load-balancers/pull/79",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Ended up rewriting the Retry Requirements for shared-state while adding the bit about port verification.\r\n\r\nInspired by the review here: https://github.com/quicwg/load-balancers/pull/71",
      "createdAt": "2021-01-08T19:14:40Z",
      "updatedAt": "2021-01-11T15:07:41Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "d985a9f171ec244f1c9290315e4ee5bf8c3b922d",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "huitema-comments",
      "headRefOid": "ed99d9e2080bb4ec2fac8ea7a3aaaa5425c9f4af",
      "closedAt": "2021-01-11T15:07:40Z",
      "mergedAt": "2021-01-11T15:07:40Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "b0f0e66bc0814281a3d9fe654de2b7d18c9482ec"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 83,
      "id": "MDExOlB1bGxSZXF1ZXN0NTUzNzY1NTgx",
      "title": "Added version allow-lists and deny-lists to Retry services",
      "url": "https://github.com/quicwg/load-balancers/pull/83",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #82. Hopefully this will close the gap between what we want Retry Services to do and reality.",
      "createdAt": "2021-01-12T21:15:19Z",
      "updatedAt": "2021-01-25T17:21:43Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "59321280e476bba2ffdb785256fc2f13995de069",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "allow-deny-list",
      "headRefOid": "8fa98ee3f8d1378ef77cefe260c3b51c7d5931e1",
      "closedAt": "2021-01-25T17:21:42Z",
      "mergedAt": "2021-01-25T17:21:42Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "173222c345575842cc6b7061022d13c72d7410fb"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 86,
      "id": "MDExOlB1bGxSZXF1ZXN0NTYxMzEyNTMy",
      "title": "Clean up server-use bytes",
      "url": "https://github.com/quicwg/load-balancers/pull/86",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #85",
      "createdAt": "2021-01-25T19:26:47Z",
      "updatedAt": "2021-02-02T23:23:08Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "ad518a51acfc20e39f1d93ad1e3e33362fc73337",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "more-server-use",
      "headRefOid": "c3f0269a09bd72fc986e9e9fa90083d8d29670f6",
      "closedAt": "2021-02-02T23:23:07Z",
      "mergedAt": "2021-02-02T23:23:07Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "50f9c367fea204de941f4f12f1af965b86382868"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 87,
      "id": "MDExOlB1bGxSZXF1ZXN0NTYzNjQ1OTkx",
      "title": "Update branch from master",
      "url": "https://github.com/quicwg/load-balancers/pull/87",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-01-29T00:04:36Z",
      "updatedAt": "2021-01-29T00:04:47Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "all-lowconfig",
      "baseRefOid": "11c934ac8400b97af014bbe3ce43ee900cf99ba9",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "master",
      "headRefOid": "ad518a51acfc20e39f1d93ad1e3e33362fc73337",
      "closedAt": "2021-01-29T00:04:47Z",
      "mergedAt": "2021-01-29T00:04:47Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "433f0d5e41f2ee0dc8a27cdd933df60d08b8139c"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 89,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY0MzI0MzQ2",
      "title": "Generalize SID Allocation",
      "url": "https://github.com/quicwg/load-balancers/pull/89",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes the broken bits in #84 and also extends to encrypted algorithms (fixing #88)",
      "createdAt": "2021-01-30T00:31:49Z",
      "updatedAt": "2021-02-05T01:43:41Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "ad518a51acfc20e39f1d93ad1e3e33362fc73337",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "all-lowconfig",
      "headRefOid": "607ab4fcec881ada10b59a00b414517c19e7d21c",
      "closedAt": "2021-02-02T23:35:01Z",
      "mergedAt": "2021-02-02T23:35:01Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "d9e263347ec15cb0f1c3db0d8769df846d835508"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 90,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY0MzQ2MTE1",
      "title": "YANG Model",
      "url": "https://github.com/quicwg/load-balancers/pull/90",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-01-30T02:44:59Z",
      "updatedAt": "2021-02-04T20:36:06Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "d9e263347ec15cb0f1c3db0d8769df846d835508",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "yang",
      "headRefOid": "75fea235fde4e8652399786642e0ab0a3f9279d7",
      "closedAt": "2021-02-04T20:36:05Z",
      "mergedAt": "2021-02-04T20:36:05Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "12c09553f63998dbbe50d86d00166248afca8994"
      },
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "fixes #91 ",
          "createdAt": "2021-02-02T18:37:02Z",
          "updatedAt": "2021-02-02T18:37:02Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 92,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY2NDA1NDQ3",
      "title": "Sync all-lowconfig with master",
      "url": "https://github.com/quicwg/load-balancers/pull/92",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-02-02T23:29:33Z",
      "updatedAt": "2021-02-02T23:35:02Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "607ab4fcec881ada10b59a00b414517c19e7d21c",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "master",
      "headRefOid": "d9e263347ec15cb0f1c3db0d8769df846d835508",
      "closedAt": "2021-02-02T23:35:02Z",
      "mergedAt": "2021-02-02T23:35:02Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "d9e263347ec15cb0f1c3db0d8769df846d835508"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 93,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY2NDA4MTM3",
      "title": "sync yang with master",
      "url": "https://github.com/quicwg/load-balancers/pull/93",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-02-02T23:36:48Z",
      "updatedAt": "2021-02-02T23:38:50Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "yang",
      "baseRefOid": "7253e9fa54523612113991b2a712c4250576bcf3",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "master",
      "headRefOid": "d9e263347ec15cb0f1c3db0d8769df846d835508",
      "closedAt": "2021-02-02T23:38:50Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 94,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY3OTA4MDkz",
      "title": "shortened references",
      "url": "https://github.com/quicwg/load-balancers/pull/94",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2021-02-04T20:51:15Z",
      "updatedAt": "2021-02-04T20:51:34Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "a15185369fc2fbc051f77cad82f729c0fa8abfec",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "shorter-refs",
      "headRefOid": "e38fbd0fd1adc6fafdb5476ec7b9e9f85438ff54",
      "closedAt": "2021-02-04T20:51:33Z",
      "mergedAt": "2021-02-04T20:51:33Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "d70769ddf6721140d68bde4b49c121e09646e909"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 95,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY4MDM4NTYz",
      "title": "Ian's Editorial Nits",
      "url": "https://github.com/quicwg/load-balancers/pull/95",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Here are some suggestions from my first pass, but overall I think the static vs dynamic server ID allocation idea works nicely.\r\n\r\n2 Q's:\r\n- Is the definition of non-compliant different at LB and server in some cases?\r\n- Might non-routable be a better term than non-compliant?",
      "createdAt": "2021-02-05T02:19:53Z",
      "updatedAt": "2021-03-05T17:06:09Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "c9898856f1ae54b27bca79a0852e03d5e2b018fd",
      "headRepository": "ianswett/load-balancers",
      "headRefName": "patch-2",
      "headRefOid": "3148cbdf457a7e732fb354bfc0a5db036363f5b8",
      "closedAt": "2021-03-05T17:01:24Z",
      "mergedAt": "2021-03-05T17:01:24Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "710f916f4a6f41071e0ca64665a6a3975bd0e3d4"
      },
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Here are some suggestions from my first pass, but overall I think the static vs dynamic server ID allocation idea works nicely.\r\n> \r\n\r\nThanks, I merged your suggestions.\r\n\r\n> 2 Q's:\r\n> \r\n>     * Is the definition of non-compliant different at LB and server in some cases?\r\n\r\nYes, they can be different because the perception of the configuration is different. In general, during configuration updates the LB will have a configs that some servers don't. Therefore, a DCID with those CR bits will be compliant at the LB and non-compliant at the server.\r\n\r\nWith static allocation, servers don't do anything with non-compliant DCIDs, so this is irrelevant. With dynamic allocation, it means that the LB will allocate an SID that the server doesn't know anything about, until:\r\n1) the allocation times out\r\n2) the LB has the occasion to forward another packet with that SID to the server when the server has the configuration.\r\n\r\n> \r\n>     * Might non-routable be a better term than non-compliant?\r\n\r\nI don't feel strongly about this, but it works for me. If you want to file a PR with this change I'd approve it.\r\n",
          "createdAt": "2021-03-05T17:06:09Z",
          "updatedAt": "2021-03-05T17:06:09Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 97,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg1ODM4NTIz",
      "title": "Clarify Retry Service handling of non-Initial Packets",
      "url": "https://github.com/quicwg/load-balancers/pull/97",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #96",
      "createdAt": "2021-03-05T19:52:37Z",
      "updatedAt": "2021-03-18T19:19:36Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "710f916f4a6f41071e0ca64665a6a3975bd0e3d4",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "retry-non-initial",
      "headRefOid": "f89e6bdc7b578a3e683925ed64eef7fbd106e504",
      "closedAt": "2021-03-12T22:32:28Z",
      "mergedAt": "2021-03-12T22:32:28Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "b425b1c36600166dc83fed5d72114b79f4dafd8a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA1NTc0MTYw",
          "commit": {
            "abbreviatedOid": "6b0b864"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-05T20:26:43Z",
          "updatedAt": "2021-03-05T20:26:43Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Do you mean a non-Initial & non-1-RTT packet here? You respond to an unknown 1-RTT packet with a stateless reset.",
              "createdAt": "2021-03-05T20:26:43Z",
              "updatedAt": "2021-03-05T20:57:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA1NTc1NDgy",
          "commit": {
            "abbreviatedOid": "6b0b864"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-05T20:28:49Z",
          "updatedAt": "2021-03-05T20:28:49Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "\"valid and invalid packets\" here refers to \"valid and invalid non-Initial packets\" right? Probably worth clarifying.",
              "createdAt": "2021-03-05T20:28:49Z",
              "updatedAt": "2021-03-05T20:57:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA1NTkyMjI2",
          "commit": {
            "abbreviatedOid": "6b0b864"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-05T20:56:32Z",
          "updatedAt": "2021-03-05T20:56:33Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Oh, good point.",
              "createdAt": "2021-03-05T20:56:33Z",
              "updatedAt": "2021-03-05T20:57:49Z"
            }
          ]
        }
      ]
    },
    {
      "number": 100,
      "id": "MDExOlB1bGxSZXF1ZXN0NTkxNjcyNzc4",
      "title": "Changing wording about server/service synchronization",
      "url": "https://github.com/quicwg/load-balancers/pull/100",
      "state": "MERGED",
      "author": null,
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This is in response to a post @wbl made on [the mailing list](https://mailarchive.ietf.org/arch/msg/quic/xcP0cwxpu1GcUnl4_XSBN70hF8E/).",
      "createdAt": "2021-03-12T13:18:04Z",
      "updatedAt": "2021-03-18T15:12:35Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "710f916f4a6f41071e0ca64665a6a3975bd0e3d4",
      "headRepository": null,
      "headRefName": "time",
      "headRefOid": "6829983553597e6868e0ae4011928134224843b8",
      "closedAt": "2021-03-18T15:12:35Z",
      "mergedAt": "2021-03-18T15:12:34Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "ef833f7843d1ab48963bcb4572e74f3a49a5fe9c"
      },
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the PR!\r\n\r\nSo as an interoperability standard, if the retry service encodes \"4000\", what does the server do with that? Do we need to add a config parameter for the time_t that serves as time 0?",
          "createdAt": "2021-03-12T22:27:37Z",
          "updatedAt": "2021-03-12T22:27:37Z"
        },
        {
          "author": "wbl",
          "authorAssociation": "NONE",
          "body": "Timestamps should be absolute, not relative, in which case I'm not sure you need a 0. There's nothing special about midnight 1 January 1970.",
          "createdAt": "2021-03-13T19:19:58Z",
          "updatedAt": "2021-03-13T19:19:58Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, so you're just suggesting declaring a later date  to begin the epoch? Makes sense ",
          "createdAt": "2021-03-13T20:22:33Z",
          "updatedAt": "2021-03-13T20:22:33Z"
        },
        {
          "author": "wbl",
          "authorAssociation": "NONE",
          "body": "Why do we need to have a sential time? If it's a precision vs. range issue then shifting the epoch makes sense.",
          "createdAt": "2021-03-13T20:34:09Z",
          "updatedAt": "2021-03-13T20:34:09Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry, I don't know what \"sential time\" is. What are you proposing?",
          "createdAt": "2021-03-15T17:24:53Z",
          "updatedAt": "2021-03-15T17:24:53Z"
        },
        {
          "author": "wbl",
          "authorAssociation": "NONE",
          "body": "What I'm proposing is that we not treat any times differently. It's not clear to me why 4000 needed special treatment.",
          "createdAt": "2021-03-16T02:32:50Z",
          "updatedAt": "2021-03-16T03:16:39Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "4000 is just an example. The intent of using the epoch was to have common agreement on when tokens expire without any QUIC-LB-specific coordination.\r\n\r\nThe current draft uses 1970 as a timebase, which absolutely makes integers longer than it needs to be. IIUC the PR doesn't have any baseline so it's unclear how the server and retry service are supposed to interpret each other's expiration times.\r\n\r\nAs we're probably speaking past each other: what, precisely, does the integer in this field indicate?\r\n",
          "createdAt": "2021-03-16T18:45:22Z",
          "updatedAt": "2021-03-16T18:45:22Z"
        },
        {
          "author": "wbl",
          "authorAssociation": "NONE",
          "body": "It's the end of the validity period for the token in some convenient timebase.",
          "createdAt": "2021-03-17T01:35:21Z",
          "updatedAt": "2021-03-17T01:35:21Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Alright, we agree on that. So this PR is being a little less precise on synchronization, which is fine, but isn't addressing the fact that we're counting from 1970. Fair enough.",
          "createdAt": "2021-03-17T14:40:42Z",
          "updatedAt": "2021-03-17T14:40:42Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE0Mzg4NDMy",
          "commit": {
            "abbreviatedOid": "644a796"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-17T14:38:53Z",
          "updatedAt": "2021-03-17T14:38:54Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nBoth server and service must have time synchronized with respect to one another to prevent tokens\r\n```",
              "createdAt": "2021-03-17T14:38:53Z",
              "updatedAt": "2021-03-18T12:47:45Z"
            }
          ]
        }
      ]
    },
    {
      "number": 104,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk2MDQwNDAw",
      "title": "Smaller tables",
      "url": "https://github.com/quicwg/load-balancers/pull/104",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #101. This tweak, IMO, substantially improves dynamic allocation.",
      "createdAt": "2021-03-18T23:46:20Z",
      "updatedAt": "2021-10-04T16:46:10Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "0aec9ac5b00a317de88720bef9689f76511d967b",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "smaller-tables",
      "headRefOid": "713b8e58ed68f4c6e860d3f4eaa43e71cd546ed7",
      "closedAt": "2021-10-04T16:46:09Z",
      "mergedAt": "2021-10-04T16:46:09Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "3e49da4a9ea495633f59756a6452ab60fd065e20"
      },
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ianswett I believe this is good as dynamic SID allocation is going to get, so IMO this is a strict improvement on the current text.\r\n\r\nHowever, I'd like you to review it, as the drawbacks remain significant and if you're no longer wedded to this approach it might best be removed. It's true that SID allocation is kind of a pain, but even with dynamic allocation the LB still needs to configure its server pool, so the gains are not all that large.\r\n\r\nAlso adding @huitema due to a heinous hack involving zero padding short CIDs, that I can't seem to poke a security hole in.",
          "createdAt": "2021-10-01T19:49:34Z",
          "updatedAt": "2021-10-01T19:49:34Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "thanks, will merge this as a strict improvement (zero padding is bad but better than \"read a bunch of bytes as if was plaintext\"), then take up the issue of whether to keep dynamic at all.",
          "createdAt": "2021-10-04T16:46:04Z",
          "updatedAt": "2021-10-04T16:46:04Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODoD6yc4t3Qvv",
          "commit": {
            "abbreviatedOid": "713b8e5"
          },
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LG, though the more I think about this, the more I want to just move away from this approach. In retrospect, I think it's just a bit too clever for our own good.",
          "createdAt": "2021-10-02T04:28:09Z",
          "updatedAt": "2021-10-02T04:28:09Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODoD6yc4t3kED",
          "commit": {
            "abbreviatedOid": "713b8e5"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I am kind of convinced that \"padding with zeroes\" will not end well. I am also a tiny bit worried that relying on the values provided in initial packets for dynamic allocations will backfire when clients become creative. The spec says \"When an Initial packet is sent by a client that has not previously received an Initial or Retry packet from the server, the client populates the Destination Connection ID field with an unpredictable value. This Destination Connection ID MUST be at least 8 bytes in length.\" But \"unpredictable value\" is in the eyes of the beholder, and \"99999999\" is just as unpredictable as \"012345678\".\r\n\r\nI would feel better if the dynamic method was only used in conjunction with stream encryption and length 8 CID, because clients will have a hard time predicting what an arbitrary CID decrypts to: flip one bit in the input, and every output bit has a 50% chance of splitting. The block cipher might also work, but will definitely require padding.",
          "createdAt": "2021-10-03T02:47:46Z",
          "updatedAt": "2021-10-03T02:47:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 106,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk5ODk2MDc3",
      "title": "Dtls",
      "url": "https://github.com/quicwg/load-balancers/pull/106",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-03-24T17:30:10Z",
      "updatedAt": "2021-05-05T18:52:14Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "e2a452f8d58f890d5d17f3eedde42905bd42b7fa",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "dtls",
      "headRefOid": "661531d6776f8dda0a33267b05d564b3378ebc38",
      "closedAt": "2021-05-05T18:52:14Z",
      "mergedAt": "2021-05-05T18:52:14Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "99088755d82ac9d7e68bc33901e7918282778767"
      },
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixes #105 ",
          "createdAt": "2021-03-24T17:30:25Z",
          "updatedAt": "2021-03-24T17:30:25Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To expand on the comment that we should explain how to parse DTLS:\r\n\r\nTo me, it is more important to remain as QUIC-version-invariant as possible than to support DTLS. DTLS-awareness implies a very specific set of assumptions about the first byte which are not consistent with version-invariance.\r\n\r\nThis PR is mostly non-normative text about what happens if you're also running DTLS on the same port in the server pool behind QUIC-LB. I've added a few normative statements about what DTLS servers should do to avoid the most serious problems, but I would rather delete the normative bits than expand the scope to fully support DTLS.\r\n\r\nI am open to the argument that this should be a non-normative appendix.\r\n",
          "createdAt": "2021-03-25T17:38:56Z",
          "updatedAt": "2021-03-25T17:38:56Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The most substantive critique was that this was \"halfway\". Putting it a non-normative appendix backs it off being halfway to just being some notes. I think expanding this spec to include a full DTLS-aware load balancer would be a mistake.",
          "createdAt": "2021-05-05T18:49:04Z",
          "updatedAt": "2021-05-05T18:49:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMzQxMjQ4",
          "commit": {
            "abbreviatedOid": "2f2f55d"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "I'm ambivalent on this.  Especially this half-way approach.\r\n\r\nIf you are going to do DTLS, then for a tiny bit more text you can tell people how to find the CID.  And then you can deal with clients that don't want to support connection IDs properly also.",
          "createdAt": "2021-03-25T00:50:49Z",
          "updatedAt": "2021-03-25T00:57:06Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "DTLS 1.0 isn't getting connection ID support as far as I'm aware.",
              "createdAt": "2021-03-25T00:50:50Z",
              "updatedAt": "2021-05-05T18:50:08Z"
            },
            {
              "originalPosition": 47,
              "body": "It seems like, given the amount of text you just added for DTLS it would be trivial to identify how to match the first DTLS octet and then find the connection ID.  It's just a few bytes down at a fixed location.",
              "createdAt": "2021-03-25T00:54:27Z",
              "updatedAt": "2021-05-05T18:50:08Z"
            },
            {
              "originalPosition": 72,
              "body": "NEVER recommend downgrade.  Maybe just imply that a server that requires the use of connection IDs might not be able to deploy DTLS 1.3.",
              "createdAt": "2021-03-25T00:55:57Z",
              "updatedAt": "2021-05-05T18:50:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMzQ1OTg2",
          "commit": {
            "abbreviatedOid": "2f2f55d"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-25T01:04:50Z",
          "updatedAt": "2021-03-25T01:04:51Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Yes, this is addressing a couple of things:\r\n\r\n1) Running DTLS in the same infrastructure as QUIC on the same port. Will a plain old QUIC-LB load balancer break my stuff? The answer is no, except DTLS 1.3 when not using CIDs.\r\n2) #1, plus I want to use Connection IDs to be resistant to address changes. This will just not work for DTLS 1.2 but it will work fine for 1.3 unless the client refuses to use CIDs.",
              "createdAt": "2021-03-25T01:04:50Z",
              "updatedAt": "2021-05-05T18:50:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMzQ2NTE2",
          "commit": {
            "abbreviatedOid": "2f2f55d"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-25T01:06:19Z",
          "updatedAt": "2021-03-25T01:06:19Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "I guess, but then you have to talk about demultiplexing QUIC and DTLS, the bit-grease extension, and you're breaking the almost-version-invariance of QUIC-LB pretty badly.\r\n\r\nThis draft has already got too much stuff in it, so I thought I'd just write down how DTLS would work out of the box. If people care about this use case I could write DTLS-LB or whatever.",
              "createdAt": "2021-03-25T01:06:19Z",
              "updatedAt": "2021-05-05T18:50:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMzQ3NDI3",
          "commit": {
            "abbreviatedOid": "2f2f55d"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-25T01:08:45Z",
          "updatedAt": "2021-03-25T01:08:45Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "Yeah, downgrade is a gross suggestion, but it's the only way to continue. This is a case where DTLS 1.3 will often be fine but can negotiate itself into a mode that fails catastrophically.\r\n\r\nBut your second sentence is backwards. A TLS1.3 server MUST support connection IDs, or else the ciphertext packets will spray all over the place. The real problem is if the client refuses to use them.",
              "createdAt": "2021-03-25T01:08:45Z",
              "updatedAt": "2021-05-05T18:50:08Z"
            }
          ]
        }
      ]
    },
    {
      "number": 109,
      "id": "MDExOlB1bGxSZXF1ZXN0NjA4Mjc0MzEz",
      "title": "Replace \"non-compliant\" and \"arbitrary\"",
      "url": "https://github.com/quicwg/load-balancers/pull/109",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #98 and #99",
      "createdAt": "2021-04-02T22:11:58Z",
      "updatedAt": "2021-04-03T18:34:45Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "19fd1994889ad4face0ad11c0b84abd60d1b5cc7",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "new-terms",
      "headRefOid": "20d595aee3d614ddbfeee1369a2b29b41489d3f9",
      "closedAt": "2021-04-03T18:34:45Z",
      "mergedAt": "2021-04-03T18:34:45Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "0e5b20fe561a403038cf5a92ce30b6c7a0dfb3cf"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI3NDYxOTU3",
          "commit": {
            "abbreviatedOid": "2b0314b"
          },
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks, this is a lot easier to read for me.",
          "createdAt": "2021-04-03T14:32:25Z",
          "updatedAt": "2021-04-03T14:32:25Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI3NDc3NTc2",
          "commit": {
            "abbreviatedOid": "2b0314b"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-03T18:31:04Z",
          "updatedAt": "2021-04-03T18:32:00Z",
          "comments": [
            {
              "originalPosition": 183,
              "body": "```suggestion\r\n{{unroutable}} provides guidance about how load balancers should handle\r\n```",
              "createdAt": "2021-04-03T18:31:04Z",
              "updatedAt": "2021-04-03T18:32:22Z"
            },
            {
              "originalPosition": 184,
              "body": "```suggestion\r\nunroutable DCIDs. This guidance, and the implementation of an algorithm to\r\n```",
              "createdAt": "2021-04-03T18:31:18Z",
              "updatedAt": "2021-04-03T18:32:22Z"
            },
            {
              "originalPosition": 193,
              "body": "```suggestion\r\nof packets that contain unroutable DCIDs, and in extreme cases connection\r\n```",
              "createdAt": "2021-04-03T18:31:36Z",
              "updatedAt": "2021-04-03T18:32:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 110,
      "id": "MDExOlB1bGxSZXF1ZXN0NjA4MjgyNzQx",
      "title": "More text on tenants that share an IP",
      "url": "https://github.com/quicwg/load-balancers/pull/110",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #107",
      "createdAt": "2021-04-02T22:47:46Z",
      "updatedAt": "2021-07-09T18:58:02Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "19fd1994889ad4face0ad11c0b84abd60d1b5cc7",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "shared-ip",
      "headRefOid": "c143314bed226514d1cc103a86a7bc068cc3117e",
      "closedAt": "2021-04-21T21:03:40Z",
      "mergedAt": "2021-04-21T21:03:40Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "1c1a02ac188de2b55a545eb018a104d7aab7ce1e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 112,
      "id": "MDExOlB1bGxSZXF1ZXN0NjEwMzgzMjg2",
      "title": "change AEAD checksum to AEAD ICV",
      "url": "https://github.com/quicwg/load-balancers/pull/112",
      "state": "MERGED",
      "author": "Neo-ZK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "fix #111, detail info:\r\n1. fix a typo.\r\n2. change AEAD checksum to AEAD ICV(defined in rfc4106)",
      "createdAt": "2021-04-07T06:46:48Z",
      "updatedAt": "2021-04-21T23:16:38Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "0e5b20fe561a403038cf5a92ce30b6c7a0dfb3cf",
      "headRepository": "Neo-ZK/load-balancers",
      "headRefName": "dev_fix_aead_checksum",
      "headRefOid": "309186d500d0ce7486c8703d056dbc2f08580c8d",
      "closedAt": "2021-04-21T23:16:38Z",
      "mergedAt": "2021-04-21T23:16:38Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "01797dfcece8cd23605dda6747309fa5438f5eaa"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 115,
      "id": "MDExOlB1bGxSZXF1ZXN0NjEwNDc3MDM4",
      "title": "Give more illustration of AEAD IV and key sequence",
      "url": "https://github.com/quicwg/load-balancers/pull/115",
      "state": "MERGED",
      "author": "Neo-ZK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "fix #113",
      "createdAt": "2021-04-07T08:54:47Z",
      "updatedAt": "2021-07-09T19:45:31Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "0e5b20fe561a403038cf5a92ce30b6c7a0dfb3cf",
      "headRepository": "Neo-ZK/load-balancers",
      "headRefName": "dev_rename_iv_and_nonce",
      "headRefOid": "f764584b784727accf51c2c11e4fa189f9e45ad5",
      "closedAt": "2021-07-09T19:45:31Z",
      "mergedAt": "2021-07-09T19:45:31Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "880fdc8de99dcb75ac445e30313dcc52694bcdb8"
      },
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Made the changes to merge this.",
          "createdAt": "2021-07-09T19:45:25Z",
          "updatedAt": "2021-07-09T19:45:25Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQxNjM0MDUx",
          "commit": {
            "abbreviatedOid": "3b17197"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Most of this is fine, but there would appear to be some confusion.",
          "createdAt": "2021-04-21T23:23:46Z",
          "updatedAt": "2021-04-21T23:47:28Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n* The Key Sequence is the 8 bit identifier to retrieve the token key and IV.\r\n```",
              "createdAt": "2021-04-21T23:23:46Z",
              "updatedAt": "2021-04-24T06:08:25Z"
            },
            {
              "originalPosition": 27,
              "body": "```suggestion\r\nbit identifier of the AES-GCM encryption context. There are three important\r\n```",
              "createdAt": "2021-04-21T23:25:56Z",
              "updatedAt": "2021-04-24T06:08:25Z"
            },
            {
              "originalPosition": 11,
              "body": "It's not a sequence number and it's not incremented by one. The IV is a product of the key derivation function.",
              "createdAt": "2021-04-21T23:28:13Z",
              "updatedAt": "2021-04-24T06:08:25Z"
            },
            {
              "originalPosition": 17,
              "body": "This paragraph doesn't correctly capture what the original paragraph did. To generate the nonce:\r\n1. left-pad the unique token number to the length of the IV\r\n2. nonce = IV ^ (padded unique token number)",
              "createdAt": "2021-04-21T23:31:24Z",
              "updatedAt": "2021-04-24T06:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQxNzE3Mzc5",
          "commit": {
            "abbreviatedOid": "853012c"
          },
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-22T02:01:51Z",
          "updatedAt": "2021-04-22T02:01:51Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Should we limit that length of nonce and IV is just 96 bit? See section 5.1 of RFC5116(https://tools.ietf.org/html/rfc5116#section-5.1)\r\n```\r\nAEAD_AES_128_GCM input and output lengths are as follows:\r\n\r\n      K_LEN is 16 octets,\r\n\r\n      P_MAX is 2^36 - 31 octets,\r\n\r\n      A_MAX is 2^61 - 1 octets,\r\n\r\n      N_MIN and N_MAX are both 12 octets, and\r\n\r\n      C_MAX is 2^36 - 15 octets.\r\n```\r\nIf we limit that, then there is no need for padding",
              "createdAt": "2021-04-22T02:01:51Z",
              "updatedAt": "2021-04-24T06:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQxNzM3MTkw",
          "commit": {
            "abbreviatedOid": "46f9bef"
          },
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-22T02:55:44Z",
          "updatedAt": "2021-04-22T02:55:44Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I have rewrite the illustration of `AEAD IV`, please check it ;-)",
              "createdAt": "2021-04-22T02:55:44Z",
              "updatedAt": "2021-04-24T06:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQyNTQ2MjA4",
          "commit": {
            "abbreviatedOid": "46f9bef"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-22T18:31:55Z",
          "updatedAt": "2021-04-22T18:31:55Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I don't see much value in that. Selecting long keys and IVs probably has some security value that there isn't much reason to prohibit.",
              "createdAt": "2021-04-22T18:31:55Z",
              "updatedAt": "2021-04-24T06:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQyOTAxOTI5",
          "commit": {
            "abbreviatedOid": "46f9bef"
          },
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-23T03:38:58Z",
          "updatedAt": "2021-04-23T03:38:58Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Please have a look at this discussion: https://crypto.stackexchange.com/questions/41601/aes-gcm-recommended-iv-size-why-12-bytes\r\n\r\nA 12 byte nonce(which was called IV in the link) is the best practice of  aes-gcm related cipher.\r\n\r\nFurther more, in cryptography related discussion, the definition of IV and nonce terms is always confusing, that's why I propose to add some explanation about them in our draft",
              "createdAt": "2021-04-23T03:38:58Z",
              "updatedAt": "2021-04-24T06:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzNTU5NDc2",
          "commit": {
            "abbreviatedOid": "46f9bef"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "More precision is always good. I would not make the implicit hypothesis that the IV is always 96 bits, but that could be a simplification.",
          "createdAt": "2021-04-23T18:22:41Z",
          "updatedAt": "2021-04-23T18:26:37Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "It would be simpler to just add the paragraph describing the IV and keep the description of the nonce as is. Something like:\r\n```\r\n* The Key Sequence is the 8 bit identifier to retrieve the token key and IV.\r\n\r\n* The AEAD IV, is a 96 bit data which produced by implementer's custom\r\nAEAD IV derivation function.\r\n\r\n* The AEAD nonce, N, is formed by combining the IV with the 96 bit unique token\r\nnumber. The 96 bits of the unique token number are left-padded with zeros to the\r\nsize of the IV. The exclusive OR of the padded unique token number and the IV\r\nforms the AEAD nonce.\r\n",
              "createdAt": "2021-04-23T18:22:41Z",
              "updatedAt": "2021-04-24T06:08:25Z"
            },
            {
              "originalPosition": 28,
              "body": "Context is a better word, since it encompasses both Key and IV. But if we do that, it might be good to say something like \"AES-GCM encryption context containing Key and IV\".",
              "createdAt": "2021-04-23T18:24:48Z",
              "updatedAt": "2021-04-24T06:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzNzY0ODk3",
          "commit": {
            "abbreviatedOid": "46f9bef"
          },
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-24T05:38:05Z",
          "updatedAt": "2021-04-24T05:38:05Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "> It would be simpler to just add the paragraph describing the IV and keep the description of the nonce as is. Something like:\r\n> \r\n> ```\r\n> * The Key Sequence is the 8 bit identifier to retrieve the token key and IV.\r\n> \r\n> * The AEAD IV, is a 96 bit data which produced by implementer's custom\r\n> AEAD IV derivation function.\r\n> \r\n> * The AEAD nonce, N, is formed by combining the IV with the 96 bit unique token\r\n> number. The 96 bits of the unique token number are left-padded with zeros to the\r\n> size of the IV. The exclusive OR of the padded unique token number and the IV\r\n> forms the AEAD nonce.\r\n> ```\r\n\r\nHi huitema:\r\nOur current discussion is about whether we need to limit AEAD nonce to 96 bits, I find that 12-byte nonce is the best practice of aes-gcm related cipher, if we limit that, then we need not do padding for unique token number. Can you give us some better advice about it?",
              "createdAt": "2021-04-24T05:38:05Z",
              "updatedAt": "2021-04-24T06:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzNzY1NjQ2",
          "commit": {
            "abbreviatedOid": "46f9bef"
          },
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-24T05:50:16Z",
          "updatedAt": "2021-04-24T05:50:16Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "> Context is a better word, since it encompasses both Key and IV. But if we do that, it might be good to say something like \"AES-GCM encryption context containing Key and IV\".\r\n\r\nOK, I have fix it, just like this:\r\n```\r\nand an 8 bit identifier used to get the AES-GCM encryption context. The AES-GCM encryption\r\ncontext contains a 96 bit key and a 96 bit AEAD IV\r\n```",
              "createdAt": "2021-04-24T05:50:16Z",
              "updatedAt": "2021-04-24T06:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzNzg4NzMy",
          "commit": {
            "abbreviatedOid": "aba2a9f"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-24T06:06:09Z",
          "updatedAt": "2021-04-24T06:06:09Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "The key is 128 bits for AES_GCM 128.",
              "createdAt": "2021-04-24T06:06:09Z",
              "updatedAt": "2021-04-24T06:08:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzNzkzNTYx",
          "commit": {
            "abbreviatedOid": "aba2a9f"
          },
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-24T06:08:45Z",
          "updatedAt": "2021-04-24T06:08:45Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "sorry, I made a foolish mistake...fixed",
              "createdAt": "2021-04-24T06:08:45Z",
              "updatedAt": "2021-04-24T06:08:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzODAwMzE1",
          "commit": {
            "abbreviatedOid": "aba2a9f"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-24T06:12:27Z",
          "updatedAt": "2021-04-24T06:12:38Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "In theory, the IV could be as large as the block size, 128 bits. In practice, it is indeed using 96 bits for AES GCM. @martinduke if we are OK with only supporting AES GCM, then we can fix the IV size to 96 bits.",
              "createdAt": "2021-04-24T06:12:27Z",
              "updatedAt": "2021-04-24T06:12:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUyNjU2OTIx",
          "commit": {
            "abbreviatedOid": "2aab2d9"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-05T19:09:58Z",
          "updatedAt": "2021-05-05T19:09:58Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I guess that's where we are now. I'm tempted to have more crypto agility, but ultimately Retry Services are version dependent and everyone has to speak 128GCM in QUICv1 to handle Initial Packets. Let's use William's proposal.",
              "createdAt": "2021-05-05T19:09:58Z",
              "updatedAt": "2021-05-05T19:09:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUyNjU4NDI4",
          "commit": {
            "abbreviatedOid": "2aab2d9"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-05T19:11:50Z",
          "updatedAt": "2021-05-05T19:11:50Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Actually, I take that back. Initial encryption doesn't protect anything and is much lower stakes. There should be a way to negotiate different ciphers.\r\n\r\nWilliam, let's get rid of the 12 Byte restriction. When this PR lands, I'll do another to introduce crypto agility.",
              "createdAt": "2021-05-05T19:11:50Z",
              "updatedAt": "2021-05-05T19:11:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUyNjU5MTgw",
          "commit": {
            "abbreviatedOid": "2aab2d9"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Let's get rid of the 96 bit IV restriction, and then this good to go.",
          "createdAt": "2021-05-05T19:12:44Z",
          "updatedAt": "2021-05-05T19:12:44Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUyOTA2Nzc2",
          "commit": {
            "abbreviatedOid": "2aab2d9"
          },
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-06T02:17:49Z",
          "updatedAt": "2021-05-06T02:17:50Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "OK, I got it.",
              "createdAt": "2021-05-06T02:17:49Z",
              "updatedAt": "2021-05-06T02:17:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAzMzQyMTkx",
          "commit": {
            "abbreviatedOid": "2aab2d9"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-09T19:37:09Z",
          "updatedAt": "2021-07-09T19:37:10Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "```suggestion\r\ncontext contains a 128 bit key and an AEAD IV. There are three important\r\n```",
              "createdAt": "2021-07-09T19:37:09Z",
              "updatedAt": "2021-07-09T19:37:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAzMzQ2Mzc4",
          "commit": {
            "abbreviatedOid": "9b7947e"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-09T19:44:26Z",
          "updatedAt": "2021-07-09T19:44:26Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "```suggestion\r\nunique token number. The 96 bits of the unique token number are left-padded with zeros to the\r\nsize of the IV. The exclusive OR of the padded unique token number and the\r\n```",
              "createdAt": "2021-07-09T19:44:26Z",
              "updatedAt": "2021-07-09T19:44:26Z"
            }
          ]
        }
      ]
    },
    {
      "number": 116,
      "id": "MDExOlB1bGxSZXF1ZXN0NjIwNTUxMzkz",
      "title": "sync with master",
      "url": "https://github.com/quicwg/load-balancers/pull/116",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-04-21T21:02:23Z",
      "updatedAt": "2021-04-21T21:03:41Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "c143314bed226514d1cc103a86a7bc068cc3117e",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "master",
      "headRefOid": "1c1a02ac188de2b55a545eb018a104d7aab7ce1e",
      "closedAt": "2021-04-21T21:03:41Z",
      "mergedAt": "2021-04-21T21:03:40Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "1c1a02ac188de2b55a545eb018a104d7aab7ce1e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 117,
      "id": "MDExOlB1bGxSZXF1ZXN0NjI1ODQwMjI1",
      "title": "add test vector for shared-stated retry service, see #114",
      "url": "https://github.com/quicwg/load-balancers/pull/117",
      "state": "MERGED",
      "author": "Neo-ZK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "see issue: #114 ",
      "createdAt": "2021-04-29T07:08:23Z",
      "updatedAt": "2021-05-14T20:37:30Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "master",
      "baseRefOid": "99088755d82ac9d7e68bc33901e7918282778767",
      "headRepository": "Neo-ZK/load-balancers",
      "headRefName": "dev_add_test_vector_for_share_state_retry_service",
      "headRefOid": "52517ce4b9e6d49c3a1e9f5c73985b820b501c50",
      "closedAt": "2021-05-14T20:37:30Z",
      "mergedAt": "2021-05-14T20:37:30Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "398ba6514002231273dc96df88868d26d189f19f"
      },
      "comments": [
        {
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> When I fake my inputs to use the inverted IP address as you have here, I get the same output. So I think your code is sound except for that.\r\n\r\nSounds great, I have rewrite the test-vector and give more information about it,please confirm again if you are free",
          "createdAt": "2021-05-11T03:36:01Z",
          "updatedAt": "2021-05-11T03:36:01Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUyNjc3NDg3",
          "commit": {
            "abbreviatedOid": "4d99f59"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-05T19:36:04Z",
          "updatedAt": "2021-05-05T19:36:05Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n## Shared-state Retry Token\r\n```",
              "createdAt": "2021-05-05T19:36:04Z",
              "updatedAt": "2021-05-11T03:31:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUyNzM5MzE2",
          "commit": {
            "abbreviatedOid": "27e5336"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-05T20:56:31Z",
          "updatedAt": "2021-05-05T20:56:32Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "The IP address is backwards. It should appear as it does it does in the IP header: 7f000001.",
              "createdAt": "2021-05-05T20:56:31Z",
              "updatedAt": "2021-05-11T03:31:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUyNzk5OTIy",
          "commit": {
            "abbreviatedOid": "27e5336"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "When I fake my inputs to use the inverted IP address as you have here, I get the same output. So I think your code is sound except for that.",
          "createdAt": "2021-05-05T21:46:04Z",
          "updatedAt": "2021-05-05T21:46:04Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU2MjUzNDU3",
          "commit": {
            "abbreviatedOid": "dae2b01"
          },
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-11T03:34:08Z",
          "updatedAt": "2021-05-11T03:34:09Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "I have fixed it and rewrite the  whole test-vector, please have a look at it",
              "createdAt": "2021-05-11T03:34:08Z",
              "updatedAt": "2021-05-11T03:34:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjYwMTk0MzQz",
          "commit": {
            "abbreviatedOid": "dae2b01"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Checks out, thanks",
          "createdAt": "2021-05-14T20:36:42Z",
          "updatedAt": "2021-05-14T20:36:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 120,
      "id": "MDExOlB1bGxSZXF1ZXN0NjM3OTI4NjM0",
      "title": "first commit: add stateless reset.",
      "url": "https://github.com/quicwg/load-balancers/pull/120",
      "state": "CLOSED",
      "author": "Lingtaonju",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "details:\r\n[#119](https://github.com/quicwg/load-balancers/issues/119)",
      "createdAt": "2021-05-10T16:10:44Z",
      "updatedAt": "2022-04-07T19:58:08Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "99088755d82ac9d7e68bc33901e7918282778767",
      "headRepository": "Lingtaonju/load-balancers",
      "headRefName": "dev_reset",
      "headRefOid": "99fd21a77ce7e92d430d2307720a5882076083f1",
      "closedAt": "2022-04-07T19:58:08Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "closed underlying issue #119 ",
          "createdAt": "2022-04-07T19:58:08Z",
          "updatedAt": "2022-04-07T19:58:08Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 123,
      "id": "MDExOlB1bGxSZXF1ZXN0NjUyNzU3NTMx",
      "title": "Simplify format",
      "url": "https://github.com/quicwg/load-balancers/pull/123",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #121.\r\n\r\nWriting it, I'm not sure that this makes anything conceptually clearer, but I'm open to merging it.",
      "createdAt": "2021-05-25T19:51:39Z",
      "updatedAt": "2021-09-23T21:32:58Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "e13356ed48b642f9d1259626cf42df1adaa6ed74",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "simplify-format",
      "headRefOid": "83ac15c7b0d613fb88fc95a61caf03be0096f991",
      "closedAt": "2021-09-23T21:32:57Z",
      "mergedAt": "2021-09-23T21:32:57Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "94a05c4478504421d9c0aa8c78d278d5eab6af87"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY4Mjg5NDE2",
          "commit": {
            "abbreviatedOid": "989c77f"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-25T19:57:38Z",
          "updatedAt": "2021-05-25T19:57:38Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "nit: Should `server ID` and `nonce` below have the same capitalization as they do above?",
              "createdAt": "2021-05-25T19:57:38Z",
              "updatedAt": "2021-05-25T19:57:38Z"
            }
          ]
        }
      ]
    },
    {
      "number": 128,
      "id": "MDExOlB1bGxSZXF1ZXN0NzE1NDI0NzEw",
      "title": "remove rscid",
      "url": "https://github.com/quicwg/load-balancers/pull/128",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #125.\r\n\r\nTakes the RSCID out of the token body because the server can catch mismatches with the DCID if it's used as associated data.",
      "createdAt": "2021-08-18T21:20:33Z",
      "updatedAt": "2021-08-27T20:58:01Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "0a4ab4db0af6aa2adb11e7e4bfc2c0b59cd5c84d",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "remove-rscid",
      "headRefOid": "d15049062fb5e587ac5d402a18b777df01417690",
      "closedAt": "2021-08-27T20:58:01Z",
      "mergedAt": "2021-08-27T20:58:01Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "e13356ed48b642f9d1259626cf42df1adaa6ed74"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM1NDQyMzc4",
          "commit": {
            "abbreviatedOid": "e4c4bb7"
          },
          "author": "nqv",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-20T23:54:41Z",
          "updatedAt": "2021-08-21T00:03:58Z",
          "comments": [
            {
              "originalPosition": 175,
              "body": "```suggestion\r\n  [RSCIL (8)],\r\n  [Retry Source Connection ID (0..20)],\r\n```",
              "createdAt": "2021-08-20T23:54:42Z",
              "updatedAt": "2021-08-21T00:03:58Z"
            }
          ]
        }
      ]
    },
    {
      "number": 131,
      "id": "PR_kwDODoD6yc4sRsr0",
      "title": "Reduce the minimum nonce length to 4 bytes",
      "url": "https://github.com/quicwg/load-balancers/pull/131",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "For the StreamID cipher.\r\n\r\nFixes the non-editorial parts of #129",
      "createdAt": "2021-09-26T09:07:08Z",
      "updatedAt": "2021-09-27T12:45:00Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "94a05c4478504421d9c0aa8c78d278d5eab6af87",
      "headRepository": "ianswett/load-balancers",
      "headRefName": "patch-3",
      "headRefOid": "c850f8d8653d9d565cf944bc55bc1cf644f66e62",
      "closedAt": "2021-09-27T12:44:59Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing this because @martinduke already has one in progress.",
          "createdAt": "2021-09-27T12:44:59Z",
          "updatedAt": "2021-09-27T12:44:59Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 132,
      "id": "PR_kwDODoD6yc4sU1Np",
      "title": "4B length",
      "url": "https://github.com/quicwg/load-balancers/pull/132",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #129.\r\n\r\nAfter a lot of thinking about nonce reuse, I added somewhat related text about stateless reset token key management.",
      "createdAt": "2021-09-27T17:06:31Z",
      "updatedAt": "2021-09-27T19:34:59Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "94a05c4478504421d9c0aa8c78d278d5eab6af87",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "4B-nonce",
      "headRefOid": "724320b0cc95318563593bef003efec8cdcf5700",
      "closedAt": "2021-09-27T19:34:58Z",
      "mergedAt": "2021-09-27T19:34:57Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "0aec9ac5b00a317de88720bef9689f76511d967b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD6yc4tkkIh",
          "commit": {
            "abbreviatedOid": "724320b"
          },
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LG.  The intent is to reduce the minimum nonce length for both Stream and Block ciphers, correct?",
          "createdAt": "2021-09-27T17:29:54Z",
          "updatedAt": "2021-09-27T17:30:31Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "This makes it look like you're reducing the minimum nonce size for both stream and block ciphers.  Is that correct?",
              "createdAt": "2021-09-27T17:29:54Z",
              "updatedAt": "2021-09-27T17:30:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc4tkyVU",
          "commit": {
            "abbreviatedOid": "724320b"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-27T18:33:32Z",
          "updatedAt": "2021-09-27T18:33:32Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "No, we're converging the minimum to 4 for all cases (it was already at 4 for BCCID)",
              "createdAt": "2021-09-27T18:33:32Z",
              "updatedAt": "2021-09-27T18:33:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc4tk7Ys",
          "commit": {
            "abbreviatedOid": "724320b"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks fine to me.",
          "createdAt": "2021-09-27T19:15:36Z",
          "updatedAt": "2021-09-27T19:15:36Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODoD6yc4tk7n-",
          "commit": {
            "abbreviatedOid": "724320b"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Let's do this.",
          "createdAt": "2021-09-27T19:16:43Z",
          "updatedAt": "2021-09-27T19:16:43Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODoD6yc4tk8F1",
          "commit": {
            "abbreviatedOid": "724320b"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2021-09-27T19:19:01Z",
          "updatedAt": "2021-09-27T19:19:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 134,
      "id": "PR_kwDODoD6yc4sp0GG",
      "title": "Crypto agility",
      "url": "https://github.com/quicwg/load-balancers/pull/134",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fix #118 ",
      "createdAt": "2021-10-04T17:39:27Z",
      "updatedAt": "2021-10-04T18:00:24Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "3e49da4a9ea495633f59756a6452ab60fd065e20",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "crypto-agility",
      "headRefOid": "969816c4bbb567026014dee0ec4fba04716e0f23",
      "closedAt": "2021-10-04T18:00:23Z",
      "mergedAt": "2021-10-04T18:00:23Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "322884bd8038e643a4cda1345db36630ae2c5d6f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 136,
      "id": "PR_kwDODoD6yc4sqM9v",
      "title": "further algorithm simplification",
      "url": "https://github.com/quicwg/load-balancers/pull/136",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "fix #130. the server no longer has discretion to lengthen the CID.\r\n\r\nAlso, the algorithms are more aligned so there has to be less unique text associated with each algorithm.",
      "createdAt": "2021-10-04T20:00:06Z",
      "updatedAt": "2021-10-05T16:52:10Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "d988000b642f722a8423c2101c285f061c9f6653",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "constant-length",
      "headRefOid": "eb9c6d51d34c69be0cba192e411f4f5656d1d0a5",
      "closedAt": "2021-10-05T16:52:10Z",
      "mergedAt": "2021-10-05T16:52:10Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "169ad41600286de9585db60d1c8cb1584d90054d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 137,
      "id": "PR_kwDODoD6yc4sqNNs",
      "title": "fix oversight",
      "url": "https://github.com/quicwg/load-balancers/pull/137",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Forgot to update this text before.",
      "createdAt": "2021-10-04T20:01:29Z",
      "updatedAt": "2021-10-04T20:02:41Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "322884bd8038e643a4cda1345db36630ae2c5d6f",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "oversight",
      "headRefOid": "621f91b29b78e189b37baa8dcf7de4d968086bc3",
      "closedAt": "2021-10-04T20:02:41Z",
      "mergedAt": "2021-10-04T20:02:41Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "d988000b642f722a8423c2101c285f061c9f6653"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 139,
      "id": "PR_kwDODoD6yc4sqeqw",
      "title": "Kill dynamic",
      "url": "https://github.com/quicwg/load-balancers/pull/139",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #103 and #135.",
      "createdAt": "2021-10-04T21:46:36Z",
      "updatedAt": "2021-10-05T17:05:28Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "169ad41600286de9585db60d1c8cb1584d90054d",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "kill-dynamic",
      "headRefOid": "1ef60e24579ba98aefc037401451375f6b63e68f",
      "closedAt": "2021-10-05T17:05:28Z",
      "mergedAt": "2021-10-05T17:05:27Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "19b0eeb12cb4e89a9e1994da7220a3f09689d108"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 141,
      "id": "PR_kwDODoD6yc4s9z4w",
      "title": "Try to diagram the Nonce length",
      "url": "https://github.com/quicwg/load-balancers/pull/141",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Since you say Nonce must be at least 4 bytes, I started there (`32..`). Then I saw your novel new `len` notation and thought I'd try it out. No idea if this is how you intended it to be used though because the only thing that uses it is an example!",
      "createdAt": "2021-10-08T23:59:54Z",
      "updatedAt": "2021-10-11T17:43:16Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "7e0bf0f9bcb48056dec73913e1105b88819d0f12",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "LPardue-patch-1",
      "headRefOid": "60049510531e64eaac94fb90aa916252e05f2fb2",
      "closedAt": "2021-10-11T17:43:16Z",
      "mergedAt": "2021-10-11T17:43:16Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "7e98785430179074243a00b76135ddc6a2379371"
      },
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, the notation disappeared as we've continued to align the different algorithm specs to use the same concepts. Thanks for bringing it back!",
          "createdAt": "2021-10-11T17:32:25Z",
          "updatedAt": "2021-10-11T17:32:48Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODoD6yc4uSNLA",
          "commit": {
            "abbreviatedOid": "fbeeca3"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-11T17:31:14Z",
          "updatedAt": "2021-10-11T17:31:15Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\n    Server ID (8..152-len(Nonce)),\r\n```",
              "createdAt": "2021-10-11T17:31:14Z",
              "updatedAt": "2021-10-11T17:31:15Z"
            }
          ]
        }
      ]
    },
    {
      "number": 142,
      "id": "PR_kwDODoD6yc4tO3ju",
      "title": "Remove useless sentence in Stream Cipher CID Algorithm",
      "url": "https://github.com/quicwg/load-balancers/pull/142",
      "state": "MERGED",
      "author": "iyangsj",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The CID format figure has been removed since draft-ietf-quic-load-balancers-08",
      "createdAt": "2021-10-15T03:09:44Z",
      "updatedAt": "2021-10-19T16:58:30Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "7e98785430179074243a00b76135ddc6a2379371",
      "headRepository": null,
      "headRefName": "patch-1",
      "headRefOid": "a986f8d5a15bb4173e77bdbe4486d1bc46cfa15a",
      "closedAt": "2021-10-19T16:58:30Z",
      "mergedAt": "2021-10-19T16:58:30Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "ad90f86112a55b274fca54862128052a8ee4b44c"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 144,
      "id": "PR_kwDODoD6yc4t12Bx",
      "title": "refactor the description of stream cipher",
      "url": "https://github.com/quicwg/load-balancers/pull/144",
      "state": "CLOSED",
      "author": "Neo-ZK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "see #143 for more detail",
      "createdAt": "2021-10-29T09:56:06Z",
      "updatedAt": "2021-12-15T20:26:54Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "ad90f86112a55b274fca54862128052a8ee4b44c",
      "headRepository": "Neo-ZK/load-balancers",
      "headRefName": "dev_refactor_padding_mode_of_stream_cipher",
      "headRefOid": "c8bf1860eec76717d8f112ab8595afa6a678aa46",
      "closedAt": "2021-12-15T20:26:54Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As we totally reworked the stream cipher, this PR has been overcome by events.\r\n\r\nI deleted the whitespace in a separate direct merge to main.",
          "createdAt": "2021-12-15T20:26:54Z",
          "updatedAt": "2021-12-15T20:26:54Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 145,
      "id": "PR_kwDODoD6yc4u_VLK",
      "title": "rename algorithms",
      "url": "https://github.com/quicwg/load-balancers/pull/145",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Some have noted that \"Stream Cipher\" is now a misnomer. So this PR renames them.",
      "createdAt": "2021-11-24T22:59:47Z",
      "updatedAt": "2021-11-24T23:02:25Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "ad90f86112a55b274fca54862128052a8ee4b44c",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "4pass",
      "headRefOid": "e4120349d890a34233bc78300fcfb1742571528d",
      "closedAt": "2021-11-24T23:02:24Z",
      "mergedAt": "2021-11-24T23:02:24Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "e2839d26f6a2f333e0ddbb8382bd9250ba8fa019"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 146,
      "id": "PR_kwDODoD6yc4u_XnZ",
      "title": "4-pass short CID algorithm",
      "url": "https://github.com/quicwg/load-balancers/pull/146",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-11-24T23:23:54Z",
      "updatedAt": "2021-12-15T19:38:22Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "e2839d26f6a2f333e0ddbb8382bd9250ba8fa019",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "4pass",
      "headRefOid": "163685b26d447c1481b983659a7ab19e27a47a19",
      "closedAt": "2021-12-15T19:38:22Z",
      "mergedAt": "2021-12-15T19:38:22Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "62dacef7efd743dd4d9a9d1b789b72b5fdc65ce8"
      },
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Alright @huitema @william-zk I've incorporated feedback from both of you and the one crypto review we've received. I suggest you read all of section 5.2 (## Encrypted Short CID Algorithm) to see what I've done, as this is a total rewrite.",
          "createdAt": "2021-12-14T23:30:34Z",
          "updatedAt": "2021-12-14T23:30:34Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODoD6yc4wm8dB",
          "commit": {
            "abbreviatedOid": "8ef8602"
          },
          "author": "Neo-ZK",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-25T02:53:51Z",
          "updatedAt": "2021-11-25T03:47:30Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "I think that the `(key, nonce_0 || zeros || 0x01)` is to use `0` to fill the input of `AES-ECB` to 16 bytes, actually it depends on my experience of last version. If I was the first time to read this draft, I can't understand the meaning of `zeros`, so I strongly suggest that we should give more illustration about that.",
              "createdAt": "2021-11-25T02:53:51Z",
              "updatedAt": "2021-11-25T03:47:30Z"
            },
            {
              "originalPosition": 48,
              "body": "By the way, maybe we can give a tips about the padding, just like this: `Because of the input of AES-ECB() is always 16 bytes, implementer SHOULD disable the padding of AES-ECB()`",
              "createdAt": "2021-11-25T02:59:18Z",
              "updatedAt": "2021-11-25T03:47:31Z"
            },
            {
              "originalPosition": 52,
              "body": "Actually I have a little doubts about this 4-pass algorithm, for it is complicated but bring little security promotion. For example: set the plaintext to be `p`,  the security of `AES-ECB(p)` is equal to `AES-ECB(AES-ECB(p))`, that means the security of `nonce_1` and `server_id_1` is equal to `nonce_2` and `server_id_2`, then maybe 2-pass is enough?",
              "createdAt": "2021-11-25T03:28:45Z",
              "updatedAt": "2021-11-25T07:48:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc4xOmCg",
          "commit": {
            "abbreviatedOid": "8ef8602"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This new text incorporates some of the feedback from the crypto expert, but not all. There were three different issues:\r\n\r\n1) Three passes is probably not enough, 4 would be more robust. You address that, with one caveat (inline)\r\n2) There has to be differences between all passes to prevent shifting attacks. You address that.\r\n3) The Feistel algorithm has better properties if the clear text is split in equal length passes. You do not address that.\r\n\r\nSplitting in equal length \"left and right\" is easy if the number of octets in `(server_id||nonce)` is even, but a bit messy if it is odd. We may want further input from the reviewers.",
          "createdAt": "2021-12-08T00:52:00Z",
          "updatedAt": "2021-12-08T00:56:58Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "I would process in a different order:\r\n\r\n    nonce1 = nonce_0 ^ truncate(AES-ECB(key, server_id_0 || zeros || 0x01))\r\n    server_id_1= server_id_0 ^ (truncate(AES-ECB(key, nonce_1 || zeros || 0x02)))\r\n    nonce_2 = nonce_1 ^ (truncate(AES-ECB(key, server_id_1 || zeros || 0x03)))\r\n    server_id_2 = server_id_1 ^ (truncate(AES-ECB(key, nonce_2 || zeros || 0x02)))\r\n\r\nThis has a couple of advantages:\r\n\r\n1) There is a risk that servers will use a counter instead of a random number for the nonce. Scrambling the nonce in the first pass makes sense there.\r\n2) The first pass can be pre-computed just once per server-id\r\n3) If you are not interested in the decrypted value of the nonce, then the server ID is decrypted in just three passes.\r\n\r\nBut then, there is also a point about using left and right halves instead of splitting at server_id and nonce.\r\n",
              "createdAt": "2021-12-08T00:52:00Z",
              "updatedAt": "2021-12-08T00:56:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc4xlagH",
          "commit": {
            "abbreviatedOid": "8ef8602"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-14T18:34:05Z",
          "updatedAt": "2021-12-14T18:34:05Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Ok, good suggestion. I'll try to clarify the language.",
              "createdAt": "2021-12-14T18:34:05Z",
              "updatedAt": "2021-12-14T18:34:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc4xlasc",
          "commit": {
            "abbreviatedOid": "8ef8602"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-14T18:34:51Z",
          "updatedAt": "2021-12-14T18:34:52Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "I am not equipped for an informed conversation about this; this PR is a result of the crypto review from cfrg.",
              "createdAt": "2021-12-14T18:34:51Z",
              "updatedAt": "2021-12-14T18:34:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc4xllCJ",
          "commit": {
            "abbreviatedOid": "8ef8602"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-14T19:17:18Z",
          "updatedAt": "2021-12-14T19:17:18Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Actually, looking again, the text already says \"zeros is of length equal to 15 octets minus the server ID length, so that the input to AES-ECB is 16 octets.\"\r\n\r\nAs for padding, since we've specified a 16B input, I suppose the padding setting is irrelevant. Why have a normative requirement?\r\n\r\nThat said, and example would be useful, and I'll add one.\r\n",
              "createdAt": "2021-12-14T19:17:18Z",
              "updatedAt": "2021-12-14T19:17:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc4xlvja",
          "commit": {
            "abbreviatedOid": "8ef8602"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-14T20:01:00Z",
          "updatedAt": "2021-12-14T20:01:00Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "1. The point of the design is that the server SHOULD use a counter; that's how we shrank the nonce! I'm not sure why the order here matters as long as we encrypt both sides\r\n2 and 3 are good points; I'll update this PR, but I'm curious what the crypto review folks would say.\r\n",
              "createdAt": "2021-12-14T20:01:00Z",
              "updatedAt": "2021-12-14T20:01:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc4xlzt5",
          "commit": {
            "abbreviatedOid": "31a1458"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-14T20:18:51Z",
          "updatedAt": "2021-12-14T20:18:52Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "I see your point now about balancing the size of each pass. I'll do that now.",
              "createdAt": "2021-12-14T20:18:51Z",
              "updatedAt": "2021-12-14T20:18:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc4xmN_h",
          "commit": {
            "abbreviatedOid": "31a1458"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-14T22:16:57Z",
          "updatedAt": "2021-12-14T22:16:57Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "An alternative would be to ask each server implementation to pick a random \"nonce mask\" for each encryption period, and to construct the nonce as \"counter xor mask\". That would have the same effect as the first pass that I proposed, and you could then keep your original proposal. But you would need four passes for decryption.",
              "createdAt": "2021-12-14T22:16:57Z",
              "updatedAt": "2021-12-14T22:16:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc4xmOfN",
          "commit": {
            "abbreviatedOid": "31a1458"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-14T22:19:29Z",
          "updatedAt": "2021-12-14T22:19:29Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "The order matters because the counter values used as nonce are predictable. I am not exactly a crypto expert, but I am pretty sure that predictable values are easier to crack than random values.",
              "createdAt": "2021-12-14T22:19:29Z",
              "updatedAt": "2021-12-14T22:19:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc4xmY6q",
          "commit": {
            "abbreviatedOid": "a8ebf00"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-14T23:24:29Z",
          "updatedAt": "2021-12-14T23:24:29Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "You may be right, but a major part of this design is to allow a counting nonce, so that it can be smaller without triggering the birthday problem.\r\n\r\nPerhaps if we just encouraged the server to start with a random first nonce value?\r\n",
              "createdAt": "2021-12-14T23:24:29Z",
              "updatedAt": "2021-12-14T23:24:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc4xmZWi",
          "commit": {
            "abbreviatedOid": "880d50d"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-14T23:27:36Z",
          "updatedAt": "2021-12-14T23:27:36Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "OK, I suggested a random initial nonce",
              "createdAt": "2021-12-14T23:27:36Z",
              "updatedAt": "2021-12-14T23:27:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc4xmexY",
          "commit": {
            "abbreviatedOid": "1f7ea90"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T00:10:31Z",
          "updatedAt": "2021-12-15T00:10:32Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Yes, that's a good suggestion, can only help.",
              "createdAt": "2021-12-15T00:10:31Z",
              "updatedAt": "2021-12-15T00:10:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc4xmfNN",
          "commit": {
            "abbreviatedOid": "1f7ea90"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I think we really need an example for the uneven split case. Implementers might forget the 4 bit boundary when doing expand and truncate.",
          "createdAt": "2021-12-15T00:14:11Z",
          "updatedAt": "2021-12-15T00:17:34Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "The truncate operation here is underspecified. Left might not start on an even octet boundary. If it does not, the top 4 bits of the AES_ECB result should be reset to zero before the XOR.  ",
              "createdAt": "2021-12-15T00:14:11Z",
              "updatedAt": "2021-12-15T00:17:34Z"
            },
            {
              "originalPosition": 172,
              "body": "Consider adding example with an uneven break, such as 3 bytes server ID and 4 bytes nonce. This might save us lots of trouble!",
              "createdAt": "2021-12-15T00:15:45Z",
              "updatedAt": "2021-12-15T00:17:34Z"
            },
            {
              "originalPosition": 186,
              "body": "typo \"pseudocode\"",
              "createdAt": "2021-12-15T00:16:08Z",
              "updatedAt": "2021-12-15T00:17:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc4xmuuA",
          "commit": {
            "abbreviatedOid": "1f7ea90"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T02:25:52Z",
          "updatedAt": "2021-12-15T02:25:52Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "I chose to bitshift right so that the MSB is on the octet boundary",
              "createdAt": "2021-12-15T02:25:52Z",
              "updatedAt": "2021-12-15T02:25:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc4xmu4Y",
          "commit": {
            "abbreviatedOid": "1f7ea90"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T02:27:23Z",
          "updatedAt": "2021-12-15T02:27:23Z",
          "comments": [
            {
              "originalPosition": 172,
              "body": "That what the current example is!",
              "createdAt": "2021-12-15T02:27:23Z",
              "updatedAt": "2021-12-15T02:27:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc4xmy21",
          "commit": {
            "abbreviatedOid": "1f7ea90"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I still think we need to add an example just after defining the odd split, maybe with 2 examples, 4+4 (even) and 3+4 (odd). And fix the type in \"psuedocode\". But that's your choice. ",
          "createdAt": "2021-12-15T03:05:37Z",
          "updatedAt": "2021-12-15T03:11:08Z",
          "comments": [
            {
              "originalPosition": 172,
              "body": "Yes, I missed that when I first read it. Sorry.",
              "createdAt": "2021-12-15T03:05:38Z",
              "updatedAt": "2021-12-15T03:11:08Z"
            },
            {
              "originalPosition": 67,
              "body": "That's probably where I missed the point in my first review. An example would be nice.",
              "createdAt": "2021-12-15T03:07:57Z",
              "updatedAt": "2021-12-15T03:11:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc4xq0Uw",
          "commit": {
            "abbreviatedOid": "163685b"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good.",
          "createdAt": "2021-12-15T19:37:01Z",
          "updatedAt": "2021-12-15T19:37:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 150,
      "id": "PR_kwDODoD6yc4v6YW5",
      "title": "Sni",
      "url": "https://github.com/quicwg/load-balancers/pull/150",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #147. Upon further consideration, any TP to provide CIDs for future connections should be in a different document.",
      "createdAt": "2021-12-15T20:24:31Z",
      "updatedAt": "2021-12-19T23:01:37Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "62dacef7efd743dd4d9a9d1b789b72b5fdc65ce8",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "sni",
      "headRefOid": "1a392aea98ba53561ff907c58315da9666263cef",
      "closedAt": "2021-12-19T23:01:37Z",
      "mergedAt": "2021-12-19T23:01:37Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "e39636e4f83e997871f931c4ed67a992da339f68"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 151,
      "id": "PR_kwDODoD6yc4v6sA5",
      "title": "Considerations for stateless LBs",
      "url": "https://github.com/quicwg/load-balancers/pull/151",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #140 ",
      "createdAt": "2021-12-15T22:31:17Z",
      "updatedAt": "2021-12-19T23:01:13Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "f3a60af93a2dcfb3b54fd9f19a42b3e521aea437",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "nostate",
      "headRefOid": "e4de454ae5f684f82503b9af56c26b581fbc0ec3",
      "closedAt": "2021-12-19T23:01:13Z",
      "mergedAt": "2021-12-19T23:01:12Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "263c04ac849a0ca021c1d4a167943ecd542e1fda"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 152,
      "id": "PR_kwDODoD6yc4wDPD1",
      "title": "Add Christian",
      "url": "https://github.com/quicwg/load-balancers/pull/152",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-12-19T23:21:14Z",
      "updatedAt": "2021-12-19T23:21:21Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "e39636e4f83e997871f931c4ed67a992da339f68",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "authors",
      "headRefOid": "1fb9ddd0741922632f2fd6f4ccefbdacb020b519",
      "closedAt": "2021-12-19T23:21:21Z",
      "mergedAt": "2021-12-19T23:21:21Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "184859e5c81c227a9649314cc6ce4a42ea88cd63"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 155,
      "id": "PR_kwDODoD6yc4yNIw3",
      "title": "refactor algorithm descriptions",
      "url": "https://github.com/quicwg/load-balancers/pull/155",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #154, narrows single-pass encryption to a special-case optimization, and simplifies presentation of the design.",
      "createdAt": "2022-02-08T00:45:16Z",
      "updatedAt": "2022-02-08T15:32:00Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "184859e5c81c227a9649314cc6ce4a42ea88cd63",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "fix-scid",
      "headRefOid": "938dfaed850d4b58efb3be6533b2523e6048afdf",
      "closedAt": "2022-02-08T15:31:59Z",
      "mergedAt": "2022-02-08T15:31:59Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "3f97109ab99c9dbc9fb936d7315585a2b1dc4b36"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD6yc40L7D1",
          "commit": {
            "abbreviatedOid": "8d61542"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "That works. The macros are clever, and you may want to explain the cleverness somewhere. It is obvious to me that you want to align \"right\" and \"left\" to an even number of bytes, adding a null nibble at the left or right or at the right of left. That will indeed save a lot of bit twiddling.\r\n\r\nFound an unrelated typo.\r\n",
          "createdAt": "2022-02-08T05:40:46Z",
          "updatedAt": "2022-02-08T05:55:35Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "There is a ) missing after len(Server ID)",
              "createdAt": "2022-02-08T05:40:46Z",
              "updatedAt": "2022-02-08T05:55:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 158,
      "id": "PR_kwDODoD6yc4yadtM",
      "title": "test vectors",
      "url": "https://github.com/quicwg/load-balancers/pull/158",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #143 ",
      "createdAt": "2022-02-10T18:38:40Z",
      "updatedAt": "2022-02-10T18:39:15Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "3f97109ab99c9dbc9fb936d7315585a2b1dc4b36",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "test-vectors",
      "headRefOid": "f9224cbdbc53084e1bd92fd7602406622ef0c3a7",
      "closedAt": "2022-02-10T18:39:14Z",
      "mergedAt": "2022-02-10T18:39:14Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "8b32d681105b3241082234362bccbcb0149c118d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 159,
      "id": "PR_kwDODoD6yc4ybBc8",
      "title": "separated yang models into server and middlebox",
      "url": "https://github.com/quicwg/load-balancers/pull/159",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #156.\r\n\r\nSuccessfully compiled both models with pyang.",
      "createdAt": "2022-02-10T19:50:21Z",
      "updatedAt": "2022-02-10T19:50:57Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "8b32d681105b3241082234362bccbcb0149c118d",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "fix-yang",
      "headRefOid": "e92ecc43e18a94d2dc3e307b11097cd076038cc1",
      "closedAt": "2022-02-10T19:50:56Z",
      "mergedAt": "2022-02-10T19:50:56Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "d8e843205e2157811cbc25227f1c24d9fae19f96"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 161,
      "id": "PR_kwDODoD6yc4yikyX",
      "title": "test vectors were broken",
      "url": "https://github.com/quicwg/load-balancers/pull/161",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #160",
      "createdAt": "2022-02-11T18:05:08Z",
      "updatedAt": "2022-02-11T19:23:27Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "367267c3e4f423065bf7ef70ce02aac2f631a2e7",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "test-vector-error",
      "headRefOid": "6d04071714d2b5a7c866bf031e9e1bec1112af9e",
      "closedAt": "2022-02-11T19:23:27Z",
      "mergedAt": "2022-02-11T19:23:26Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "94e5d5dabe72972a11968fe9d26e5dc14fb0c7d0"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 163,
      "id": "PR_kwDODoD6yc4z7VDe",
      "title": "Split docs",
      "url": "https://github.com/quicwg/load-balancers/pull/163",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "fix #157 ",
      "createdAt": "2022-03-03T23:57:05Z",
      "updatedAt": "2022-03-25T14:41:45Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "94e5d5dabe72972a11968fe9d26e5dc14fb0c7d0",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "split-docs",
      "headRefOid": "ca31548d99924cfe14a09c87193579bd1de1db3b",
      "closedAt": "2022-03-25T14:41:43Z",
      "mergedAt": "2022-03-25T14:41:43Z",
      "mergedBy": "nibanks",
      "mergeCommit": {
        "oid": "c1db80cf2bc575fc249bc7a7a8fa1f27e7bf24b5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD6yc41qltj",
          "commit": {
            "abbreviatedOid": "5ce62db"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-04T15:19:44Z",
          "updatedAt": "2022-03-04T15:19:44Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "You use `Retry Offload` later on. We should choose a capitalization pattern and stick with it. I don't personally care what it is though.",
              "createdAt": "2022-03-04T15:19:44Z",
              "updatedAt": "2022-03-04T15:19:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc41qoDo",
          "commit": {
            "abbreviatedOid": "5ce62db"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-04T15:27:32Z",
          "updatedAt": "2022-03-04T15:27:32Z",
          "comments": [
            {
              "originalPosition": 215,
              "body": "I'm somewhat worried about this statement. There could be some other input (i.e. resumption token, transport parameter) that breaks some assumption here, even for QUIC v1. I would feel better recommending the Retry Offload only validate the minimum amount necessary to operate correctly.",
              "createdAt": "2022-03-04T15:27:32Z",
              "updatedAt": "2022-03-04T15:27:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc41qp_k",
          "commit": {
            "abbreviatedOid": "5ce62db"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-04T15:34:08Z",
          "updatedAt": "2022-03-04T15:34:08Z",
          "comments": [
            {
              "originalPosition": 296,
              "body": "While I agree that in an ideal world informing the client of an on-path attacker might be nice, I don't think any server would waste the resources to decrypt and re-encrypt, and I don't think it's even worth calling this out as an option. I think we should simply recommend drop.",
              "createdAt": "2022-03-04T15:34:08Z",
              "updatedAt": "2022-03-04T15:34:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc41quxx",
          "commit": {
            "abbreviatedOid": "5ce62db"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM. A few comments in the Retry, but we can follow up separately on them.",
          "createdAt": "2022-03-04T15:50:29Z",
          "updatedAt": "2022-03-04T15:50:29Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODoD6yc41sWaS",
          "commit": {
            "abbreviatedOid": "5ce62db"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-05T00:03:32Z",
          "updatedAt": "2022-03-05T00:03:32Z",
          "comments": [
            {
              "originalPosition": 215,
              "body": "I eliminated \"not routable\" part because I'm not sure what that meant, and certainly not in this draft.\r\n\r\nI don't really understand your concern (how could tokens bring it below the minimum packet size?) but as this is orthogonal to the PR, please file an issue if you'd like to pursue it.",
              "createdAt": "2022-03-05T00:03:32Z",
              "updatedAt": "2022-03-05T00:03:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc41sWkk",
          "commit": {
            "abbreviatedOid": "5ce62db"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-05T00:05:46Z",
          "updatedAt": "2022-03-05T00:05:47Z",
          "comments": [
            {
              "originalPosition": 296,
              "body": "I think that's fine, but please file an issue.",
              "createdAt": "2022-03-05T00:05:46Z",
              "updatedAt": "2022-03-05T00:05:47Z"
            }
          ]
        }
      ]
    },
    {
      "number": 167,
      "id": "PR_kwDODoD6yc41r65S",
      "title": "updated index calculation",
      "url": "https://github.com/quicwg/load-balancers/pull/167",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fix #166 in accordance with the 2nd crypto review",
      "createdAt": "2022-04-05T20:50:14Z",
      "updatedAt": "2022-04-26T19:02:20Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "cf4c59ea1d54b6023a36458192ff0ce058cdbfc6",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "fix-index",
      "headRefOid": "9f889f12f5b72dcb752f22d82cf46acc4c59e39c",
      "closedAt": "2022-04-26T19:02:19Z",
      "mergedAt": "2022-04-26T19:02:19Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "5635d1aacebb3c3bc5441e80e8a3202a640baa95"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD6yc43lbSV",
          "commit": {
            "abbreviatedOid": "38ad347"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I don't like replacing \"0x01\", which specifies bits, by \"1 + cid_len\". Several issues:\r\n* is the encoding of the integer big indian or little endian?\r\n* how many bits?\r\n* could cid_len1 + pass_number_x collide with cid_len2 + pass_number_y\r\nI would feel more comfortable with \"pass_number + 16*cid_len\" + specify the bits.",
          "createdAt": "2022-04-05T21:53:22Z",
          "updatedAt": "2022-04-05T21:56:48Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "\"1+cid_len\" is not ideal, especially if we have to bump the count to 12. I would rather have something \"len on 8 bits + rank on 4 bits\"",
              "createdAt": "2022-04-05T21:53:22Z",
              "updatedAt": "2022-04-05T21:56:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc43xDTY",
          "commit": {
            "abbreviatedOid": "38ad347"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-07T19:53:24Z",
          "updatedAt": "2022-04-07T19:53:24Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I was envisioning all this fitting in one byte (which was not clear in the text), but I agree parsing the space is a better result.",
              "createdAt": "2022-04-07T19:53:24Z",
              "updatedAt": "2022-04-07T19:53:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc44ywcE",
          "commit": {
            "abbreviatedOid": "0a20492"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "That works. My main comment below is that you are packing bits, leaving only 3 to encode the step number. That will work for up to 8 steps, but we have a worst case of 12 steps. Do we need to pack bits, or should we just use 2 bytes?",
          "createdAt": "2022-04-26T06:37:03Z",
          "updatedAt": "2022-04-26T06:39:45Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "So the index is effectively:\r\n\r\n* 3 bits for the identifier of the step,\r\n* 5 bits for the length of the CID.\r\n\r\nIf we stick with QUIC v1, the max CID length is 20 bytes. 5 bits definitely suffice. But if we ever increase the number of steps to 12, 3 bits will not suffice.\r\n\r\nDo we really need to pack bits? The \"right\" and \"left\" fields are at most 10 bytes, so we have 6 bytes available for the \"tweak\". Can't we have 1 byte for the step number and one byte for the CID length? \r\n The \"right\" and \"left\" can be at most 10 bytes.",
              "createdAt": "2022-04-26T06:37:03Z",
              "updatedAt": "2022-04-26T06:39:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc442ZLH",
          "commit": {
            "abbreviatedOid": "6b9ea51"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good, except for the missing parenthesis.",
          "createdAt": "2022-04-26T17:44:04Z",
          "updatedAt": "2022-04-26T17:46:50Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Missing parenthesis. Should be `expand_right(0xaaba3c, 0x0b, 0x02)`.",
              "createdAt": "2022-04-26T17:44:05Z",
              "updatedAt": "2022-04-26T17:46:50Z"
            },
            {
              "originalPosition": 58,
              "body": "This comment is addressed in the new text.",
              "createdAt": "2022-04-26T17:44:43Z",
              "updatedAt": "2022-04-26T17:46:50Z"
            }
          ]
        }
      ]
    },
    {
      "number": 170,
      "id": "PR_kwDODoD6yc42HxoK",
      "title": "Handle Second Initial correctly",
      "url": "https://github.com/quicwg/load-balancers/pull/170",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "nibanks"
      ],
      "labels": [],
      "body": "Fix #165",
      "createdAt": "2022-04-12T18:06:40Z",
      "updatedAt": "2024-01-19T18:06:57Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "cf4c59ea1d54b6023a36458192ff0ce058cdbfc6",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "late-retyr",
      "headRefOid": "f18171bd1d14aa9a30f5d808fc3480672847eae9",
      "closedAt": "2022-07-06T15:16:40Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Replaced by #172",
          "createdAt": "2022-07-06T15:16:40Z",
          "updatedAt": "2022-07-06T15:16:40Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODoD6yc45xcGD",
          "commit": {
            "abbreviatedOid": "f18171b"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "I have strong reservations here. I think we should definitely callout the problems, but at least for now, not suggest any solutions. The more I think about this, I believe we should solve this in the QUIC protocol.\r\n\r\nI recommend we define an extension that does the following:\r\n\r\nThe server includes a new transport parameter `initial_token` that contains the value of the initial token that clients should use for any subsequent initial packets they send. If the client understands this extension/TP, it acts accordingly. If it does not, then it may hit the issues you describe in this PR and eventually time out.",
          "createdAt": "2022-05-11T12:29:17Z",
          "updatedAt": "2022-05-11T12:39:51Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "I do not think we should do this. This is encouraging exceeding the amplification limit.",
              "createdAt": "2022-05-11T12:29:17Z",
              "updatedAt": "2022-05-11T12:39:51Z"
            },
            {
              "originalPosition": 66,
              "body": "I don't care for this for two reasons:\r\n\r\n1. It requires Retry Offloads to parse the entire UDP datagram (or at least more of it). This could be leveraged to attack the Retry Offload itself.\r\n2. It requires the Retry Offloads to modify the contents of the datagram in these cases. This text stats the UDP payload length should be updated accordingly, but it doesn't go into any details about what you actually put at the end of the datagram (after the valid packets). And again, this requirement can be leveraged to attack the Retry Offload.",
              "createdAt": "2022-05-11T12:35:15Z",
              "updatedAt": "2022-05-11T12:39:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc46jViE",
          "commit": {
            "abbreviatedOid": "f18171b"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Aside from the qualitative issues of requiring client participation in this mechanism, the transport parameter doesn't arrive early enough in the handshake to address any of these problems.",
          "createdAt": "2022-05-23T21:01:41Z",
          "updatedAt": "2022-05-23T21:15:23Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "1. The limited amount of parsing seems quite inexpensive to me.\r\n\r\n2. You're not putting anything at the end of the datagram, you're just deleting Initial and 0-RTT. Invalid hanshake packets can be immediately discarded at the server, so there are no costs to letting them through. Meanwhile, if this is the second flight the server will do fine if Initial doesn't get through.",
              "createdAt": "2022-05-23T21:01:41Z",
              "updatedAt": "2022-05-23T21:15:09Z"
            },
            {
              "originalPosition": 87,
              "body": "A CONNECTION_CLOSE is small and IMO doesn't violate the spirit of the 3x limit, but I can instead add some language that the server has to save some space under the limit to send this.",
              "createdAt": "2022-05-23T21:07:54Z",
              "updatedAt": "2022-05-23T21:15:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 172,
      "id": "PR_kwDODoD6yc44YqDX",
      "title": "Retry transition",
      "url": "https://github.com/quicwg/load-balancers/pull/172",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "A different fix for #165.\r\n\r\nAvoids any client involvement, and covers all but extreme corner cases.",
      "createdAt": "2022-05-24T18:15:21Z",
      "updatedAt": "2022-05-25T19:21:48Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "5635d1aacebb3c3bc5441e80e8a3202a640baa95",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "retry-transition",
      "headRefOid": "f6a977cedc3d69a698d17eca07006338f37451ec",
      "closedAt": "2022-05-25T19:21:47Z",
      "mergedAt": "2022-05-25T19:21:47Z",
      "mergedBy": "nibanks",
      "mergeCommit": {
        "oid": "9d3ff08ef2b87fcb7ad6bd6aa7e3274750c96d60"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD6yc46u1hQ",
          "commit": {
            "abbreviatedOid": "f6a977c"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2022-05-25T19:20:57Z",
          "updatedAt": "2022-05-25T19:20:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 173,
      "id": "PR_kwDODoD6yc44ag9j",
      "title": "s/invalid/not valid",
      "url": "https://github.com/quicwg/load-balancers/pull/173",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "the in-solidarity bot should have flagged this and it is an easy fix",
      "createdAt": "2022-05-25T05:40:13Z",
      "updatedAt": "2022-05-25T19:22:31Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "5635d1aacebb3c3bc5441e80e8a3202a640baa95",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "LPardue-patch-1",
      "headRefOid": "34b625f80a09cc85022fd1c77b3ccc298a70bff8",
      "closedAt": "2022-05-25T19:22:30Z",
      "mergedAt": "2022-05-25T19:22:30Z",
      "mergedBy": "nibanks",
      "mergeCommit": {
        "oid": "7676a95b288d3369818c344d76674f39f054e743"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD6yc46u15J",
          "commit": {
            "abbreviatedOid": "34b625f"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-25T19:22:26Z",
          "updatedAt": "2022-05-25T19:22:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 174,
      "id": "PR_kwDODoD6yc46-qGs",
      "title": "Further 0b11 discussion",
      "url": "https://github.com/quicwg/load-balancers/pull/174",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #171.",
      "createdAt": "2022-07-06T23:59:06Z",
      "updatedAt": "2022-07-08T18:48:51Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "8569234f87c482c8a081e28a0ff184d83c02e700",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "cp11",
      "headRefOid": "f5d852cb8dade0d22124e42047d6078e54378ed1",
      "closedAt": "2022-07-08T18:48:50Z",
      "mergedAt": "2022-07-08T18:48:50Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "bca1b43912f4e4154fcc078f6d786881e1638573"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD6yc49lgXX",
          "commit": {
            "abbreviatedOid": "4e47658"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-08T18:12:13Z",
          "updatedAt": "2022-07-08T18:12:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 175,
      "id": "PR_kwDODoD6yc46_guy",
      "title": "Adding the description of twelve pass encryption",
      "url": "https://github.com/quicwg/load-balancers/pull/175",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Parked"
      ],
      "body": "Not really sure that we have to do that, but I did it anyhow. \r\nAlso fixed a couple of random line length issues that were causing errors in xml2rfc",
      "createdAt": "2022-07-07T06:01:41Z",
      "updatedAt": "2025-02-11T19:11:17Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "8569234f87c482c8a081e28a0ff184d83c02e700",
      "headRepository": "getdnsapi/load-balancers",
      "headRefName": "12passes",
      "headRefOid": "27845bd6d306ad974704f7d5e77c5af239b6d796",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for doing this. One comment:\r\n\r\nI don't think the Security Considerations section here fully captures our doubts about the need for this. IIRC, the 4-pass is only vulnerable to known-plaintext attacks, which seem hard to mount here. And as you state, if the consequence is the attacker discovering that the CID is not random, it's not obvious to me that it's a serious problem.",
          "createdAt": "2022-07-07T19:42:58Z",
          "updatedAt": "2022-07-07T19:42:58Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Per offline discussion with @huitema: we are disinclined to include this in the draft, because we don't think people will implement it. We will keep it around in case reviews demand it, but have no plans to merge.",
          "createdAt": "2022-07-08T17:29:59Z",
          "updatedAt": "2022-07-08T17:29:59Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinduke the latest commit have resolved potential merge conflicts between this PR and the main branch, making it easier to \"pull the PR off our back pocket\" if we really have to.",
          "createdAt": "2022-07-08T17:35:08Z",
          "updatedAt": "2022-07-08T17:35:08Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 176,
      "id": "PR_kwDODoD6yc47E4fC",
      "title": "Just4passes",
      "url": "https://github.com/quicwg/load-balancers/pull/176",
      "state": "MERGED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Discuss Distinguishing Attack in security section.\r\nFix specification of Four Passes decryption\r\nFix number of kramdown issues.",
      "createdAt": "2022-07-08T03:19:20Z",
      "updatedAt": "2022-07-08T16:03:06Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "6c3767308940722dd8e0a2da06dce30810d0a91d",
      "headRepository": "getdnsapi/load-balancers",
      "headRefName": "just4passes",
      "headRefOid": "faa0b882748c407b531c0b6a14a2c674ce372b44",
      "closedAt": "2022-07-08T16:03:01Z",
      "mergedAt": "2022-07-08T16:03:01Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "8569234f87c482c8a081e28a0ff184d83c02e700"
      },
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinduke I think this simple PR is ready.",
          "createdAt": "2022-07-08T03:33:22Z",
          "updatedAt": "2022-07-08T03:33:22Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you, this is perfect.",
          "createdAt": "2022-07-08T16:03:05Z",
          "updatedAt": "2022-07-08T16:03:05Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 178,
      "id": "PR_kwDODoD6yc47IY7W",
      "title": "Process Demultiplexing",
      "url": "https://github.com/quicwg/load-balancers/pull/178",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #177 ",
      "createdAt": "2022-07-08T21:36:03Z",
      "updatedAt": "2022-07-11T15:32:28Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "bca1b43912f4e4154fcc078f6d786881e1638573",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "process",
      "headRefOid": "3df68dad56eb9484dfb0dc94d0fd92590de8bc60",
      "closedAt": "2022-07-11T15:32:27Z",
      "mergedAt": "2022-07-11T15:32:27Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "654856b672746b9dbcb4fddd60137020b022d0c9"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 180,
      "id": "PR_kwDODoD6yc47YYJw",
      "title": "Remove trailing whitespace",
      "url": "https://github.com/quicwg/load-balancers/pull/180",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This might make the build happier.",
      "createdAt": "2022-07-14T05:57:58Z",
      "updatedAt": "2022-07-14T14:37:28Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "7277aa10ab3f0dbf77330d32eaefa2098a34ca6c",
      "headRepository": "martinthomson/quic-lb",
      "headRefName": "whitespace",
      "headRefOid": "39d8c9956e50327ebce840a3e9765000eb97fc8e",
      "closedAt": "2022-07-14T14:37:28Z",
      "mergedAt": "2022-07-14T14:37:28Z",
      "mergedBy": "nibanks",
      "mergeCommit": {
        "oid": "41cbdd0cf567618c9019a9346f49484b7915f3ce"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD6yc497Z52",
          "commit": {
            "abbreviatedOid": "39d8c99"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-14T14:37:17Z",
          "updatedAt": "2022-07-14T14:37:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 181,
      "id": "PR_kwDODoD6yc47YYn4",
      "title": "First absolute",
      "url": "https://github.com/quicwg/load-balancers/pull/181",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-07-14T06:01:15Z",
      "updatedAt": "2022-10-03T20:23:27Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "7277aa10ab3f0dbf77330d32eaefa2098a34ca6c",
      "headRepository": "martinthomson/quic-lb",
      "headRefName": "first-absolute",
      "headRefOid": "50a9ea01cd9755004f2dc35158703833dead686e",
      "closedAt": "2022-10-03T20:23:27Z",
      "mergedAt": "2022-10-03T20:23:27Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "c934353dbcf285237ce9ca3bdf7ffab264b89af9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD6yc497aQr",
          "commit": {
            "abbreviatedOid": "50a9ea0"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-14T14:38:10Z",
          "updatedAt": "2022-07-14T14:38:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 182,
      "id": "PR_kwDODoD6yc47YY_t",
      "title": "Encode cid",
      "url": "https://github.com/quicwg/load-balancers/pull/182",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-07-14T06:03:31Z",
      "updatedAt": "2022-10-03T20:25:24Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "7277aa10ab3f0dbf77330d32eaefa2098a34ca6c",
      "headRepository": "martinthomson/quic-lb",
      "headRefName": "encode-cid",
      "headRefOid": "7812b116ce76ddd172e52c754e83527d5d94a65e",
      "closedAt": "2022-10-03T20:25:23Z",
      "mergedAt": "2022-10-03T20:25:23Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "b039f6991489702f199339cf6063adc6eb004710"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD6yc497azO",
          "commit": {
            "abbreviatedOid": "285dfbe"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-14T14:39:04Z",
          "updatedAt": "2022-07-14T14:39:04Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Should `designate` be removed in this sentence if we go with this wording?\r\n```suggestion\r\nQUIC allows servers (or load balancers) to encode useful routing\r\n```",
              "createdAt": "2022-07-14T14:39:04Z",
              "updatedAt": "2022-07-14T14:39:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc499_VH",
          "commit": {
            "abbreviatedOid": "7812b11"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-15T00:21:04Z",
          "updatedAt": "2022-07-15T00:21:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 183,
      "id": "PR_kwDODoD6yc47YaDf",
      "title": "Long sentence",
      "url": "https://github.com/quicwg/load-balancers/pull/183",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-07-14T06:09:47Z",
      "updatedAt": "2022-10-03T20:26:42Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "7277aa10ab3f0dbf77330d32eaefa2098a34ca6c",
      "headRepository": "martinthomson/quic-lb",
      "headRefName": "long-sentence",
      "headRefOid": "50dcf668945986a62b1a734d0045f23055953cf0",
      "closedAt": "2022-10-03T20:26:41Z",
      "mergedAt": "2022-10-03T20:26:41Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "efcee816a1895c8500e8ce42b9d5480e60d584ca"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD6yc497bhO",
          "commit": {
            "abbreviatedOid": "50dcf66"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-14T14:40:15Z",
          "updatedAt": "2022-07-14T14:40:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 185,
      "id": "PR_kwDODoD6yc47Ycui",
      "title": "Key lookup problems aren't guaranteed",
      "url": "https://github.com/quicwg/load-balancers/pull/185",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This only applies if the CID varies in length (so say that).\r\n\r\nAlso, it only applies if the common stem doesn't otherwise distinguish itself enough to allow an efficient lookup (so say \"might\" rather than get into all that).\r\n\r\nIn other words, it's probably inefficient, but not necessarily so.",
      "createdAt": "2022-07-14T06:25:06Z",
      "updatedAt": "2022-10-03T20:27:44Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "7277aa10ab3f0dbf77330d32eaefa2098a34ca6c",
      "headRepository": "martinthomson/quic-lb",
      "headRefName": "might-be-hard",
      "headRefOid": "7cf1a3899524cd9cf9fada72199712c74bac529e",
      "closedAt": "2022-10-03T20:27:44Z",
      "mergedAt": "2022-10-03T20:27:44Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "0178a8b690a1464a54f3f5a86734aa4f3aa92127"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD6yc497b02",
          "commit": {
            "abbreviatedOid": "7cf1a38"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-14T14:40:55Z",
          "updatedAt": "2022-07-14T14:40:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 186,
      "id": "PR_kwDODoD6yc47YeCI",
      "title": "Be clearer about CID limits",
      "url": "https://github.com/quicwg/load-balancers/pull/186",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "As they relate to invariants.",
      "createdAt": "2022-07-14T06:32:26Z",
      "updatedAt": "2022-10-03T20:28:35Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "7277aa10ab3f0dbf77330d32eaefa2098a34ca6c",
      "headRepository": "martinthomson/quic-lb",
      "headRefName": "cid-length-constraints",
      "headRefOid": "8725c840f61542b00808481abc8f2272791bd7cf",
      "closedAt": "2022-10-03T20:28:35Z",
      "mergedAt": "2022-10-03T20:28:35Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "36c5bf6c1ee8ca5ba4e182e6ee26341da3d6d1bf"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD6yc497cB0",
          "commit": {
            "abbreviatedOid": "8725c84"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-14T14:41:25Z",
          "updatedAt": "2022-07-14T14:41:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 187,
      "id": "PR_kwDODoD6yc47YgBk",
      "title": "No understandy = no worky",
      "url": "https://github.com/quicwg/load-balancers/pull/187",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "THe addition to the first paragraph here seems necessary.  The basic\r\nidea is that if a QUIC version violates the (reasonable) assumptions\r\nthis section makes, then it just doesn't work if you try to apply this\r\ndesign.  You will need to update your load balancer and probably update\r\nthe CID allocation/negotiation/configuration you are using.\r\n\r\nThe second paragraph I'm less sure about.  I think that the intent was\r\nto say that if you follow the advice here you still get a functioning\r\nsystem even if the load balancer gets it wrong.  So I said that.  I\r\nthink that I agree, provided that the tenant (new term?) chooses a good\r\nconnection ID for any new ones.  So that's not just Section 3.1 you need\r\nto refer to, but the whole document.",
      "createdAt": "2022-07-14T06:42:02Z",
      "updatedAt": "2022-10-03T20:40:34Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "7277aa10ab3f0dbf77330d32eaefa2098a34ca6c",
      "headRepository": "martinthomson/quic-lb",
      "headRefName": "no-worky",
      "headRefOid": "4b46b2dfdb8947ac8320645f71a88b45ab311b47",
      "closedAt": "2022-10-03T20:40:34Z",
      "mergedAt": "2022-10-03T20:40:34Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "7f8da4df2f360065f86182fea85b541b75d54dde"
      },
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So what I'm trying to say at the end of the second paragraph is this:\r\n\r\n1) Say, for example you have a LB that routes the Client Inital by SNI\r\n2) For other packets, it uses a QUIC-LB config with 8B CIDs.\r\n3) A client Initial arrives to foo.com with an (unknown) QUIC version\r\n4) This initial also has an 8B CID that accidentally happens to route to a bar.com tenant\r\n5) Since the LB can't read the CHLO, it ends up using the CID to route and things fail.\r\n\r\nMaybe you got all that from the text, but I'm making sure.\r\n\r\nThis scenario isn't great but also isn't any worse than the pre-QUIC-LB status quo. *shrug*\r\n\r\nStill, your editorial change makes things clearer.",
          "createdAt": "2022-10-03T20:40:30Z",
          "updatedAt": "2022-10-03T20:40:30Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODoD6yc497dQw",
          "commit": {
            "abbreviatedOid": "4b46b2d"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-14T14:44:33Z",
          "updatedAt": "2022-07-14T14:44:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 190,
      "id": "PR_kwDODoD6yc47Yg-x",
      "title": "\"forward load balancers\" is a new concept",
      "url": "https://github.com/quicwg/load-balancers/pull/190",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Better not to deal with creating a new definition here.  Especially one\r\nthat uses the word \"forward\".  Reword.",
      "createdAt": "2022-07-14T06:46:54Z",
      "updatedAt": "2022-10-03T20:22:33Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "7277aa10ab3f0dbf77330d32eaefa2098a34ca6c",
      "headRepository": "martinthomson/quic-lb",
      "headRefName": "forward-lb",
      "headRefOid": "e943573c43ed4fb1f4081598b276360b5e9bbb90",
      "closedAt": "2022-10-03T20:22:33Z",
      "mergedAt": "2022-10-03T20:22:33Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "d9525a21207c3ce056cd06c3666965f2e0073b6b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD6yc497d_1",
          "commit": {
            "abbreviatedOid": "e943573"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-14T14:46:28Z",
          "updatedAt": "2022-07-14T14:46:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 191,
      "id": "PR_kwDODoD6yc47YiDm",
      "title": "These designs",
      "url": "https://github.com/quicwg/load-balancers/pull/191",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-07-14T06:52:28Z",
      "updatedAt": "2022-10-03T20:41:30Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "7277aa10ab3f0dbf77330d32eaefa2098a34ca6c",
      "headRepository": "martinthomson/quic-lb",
      "headRefName": "these-designs",
      "headRefOid": "de64e96def6a11db6ce6c3e9ff57936ea938be23",
      "closedAt": "2022-10-03T20:41:30Z",
      "mergedAt": "2022-10-03T20:41:30Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "ebebe0598e13ed075444af33e0b12fc536b6323f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD6yc497eNB",
          "commit": {
            "abbreviatedOid": "de64e96"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-14T14:47:00Z",
          "updatedAt": "2022-07-14T14:47:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 202,
      "id": "PR_kwDODoD6yc5AGCjn",
      "title": "Define all the Connection ID fields",
      "url": "https://github.com/quicwg/load-balancers/pull/202",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #188 ",
      "createdAt": "2022-10-03T23:45:01Z",
      "updatedAt": "2022-10-05T21:10:00Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "92a82149b8cf390ef7787768f3ffd125b696ddd0",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "explain-fields",
      "headRefOid": "399d08a930ed153a984f38b8f83f136d5febb17d",
      "closedAt": "2022-10-05T21:09:59Z",
      "mergedAt": "2022-10-05T21:09:59Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "aaf10af843e192c396fe51a6476d3119e33a54f6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD6yc5DTZNH",
          "commit": {
            "abbreviatedOid": "14740a8"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-04T00:02:08Z",
          "updatedAt": "2022-10-04T00:02:08Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODoD6yc5DZTVW",
          "commit": {
            "abbreviatedOid": "14740a8"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-04T23:04:54Z",
          "updatedAt": "2022-10-04T23:15:30Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nQUIC allows servers (or load balancers) to select connection IDs so that the identifier\r\n```",
              "createdAt": "2022-10-04T23:04:54Z",
              "updatedAt": "2022-10-04T23:15:30Z"
            },
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nencodes useful routing information for load balancers.  It also encourages\r\n```",
              "createdAt": "2022-10-04T23:05:24Z",
              "updatedAt": "2022-10-04T23:15:30Z"
            },
            {
              "originalPosition": 24,
              "body": "```suggestion\r\nThe encoding scheme used in this document reserves the first octet of a Connection ID for two purposes: one\r\n```",
              "createdAt": "2022-10-04T23:06:08Z",
              "updatedAt": "2022-10-04T23:15:30Z"
            },
            {
              "originalPosition": 89,
              "body": "Not sure that this change is a positive one.",
              "createdAt": "2022-10-04T23:14:08Z",
              "updatedAt": "2022-10-04T23:15:30Z"
            },
            {
              "originalPosition": 109,
              "body": "\"forward\" here meaning what?  Closer to the client?",
              "createdAt": "2022-10-04T23:14:40Z",
              "updatedAt": "2022-10-04T23:15:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc5DeM8C",
          "commit": {
            "abbreviatedOid": "14740a8"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-05T20:12:22Z",
          "updatedAt": "2022-10-05T20:12:23Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Um, I think the grammar here is wrong? The infinitive is \"to encode\"",
              "createdAt": "2022-10-05T20:12:22Z",
              "updatedAt": "2022-10-05T20:12:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc5DeOC0",
          "commit": {
            "abbreviatedOid": "14740a8"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-05T20:16:17Z",
          "updatedAt": "2022-10-05T20:16:18Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "OK",
              "createdAt": "2022-10-05T20:16:18Z",
              "updatedAt": "2022-10-05T20:16:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc5DeOaU",
          "commit": {
            "abbreviatedOid": "4675539"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-05T20:17:43Z",
          "updatedAt": "2022-10-05T20:17:43Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nencodes useful routing information for load balancers.  It also encourages\r\n```",
              "createdAt": "2022-10-05T20:17:43Z",
              "updatedAt": "2022-10-05T20:17:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc5DeOtk",
          "commit": {
            "abbreviatedOid": "25ff0b5"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-05T20:18:50Z",
          "updatedAt": "2022-10-05T20:18:51Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "```suggestion\r\nHowever, on physical devices operating multiple QUIC servers, it might be impractical\r\n```",
              "createdAt": "2022-10-05T20:18:50Z",
              "updatedAt": "2022-10-05T20:18:51Z"
            }
          ]
        }
      ]
    },
    {
      "number": 203,
      "id": "PR_kwDODoD6yc5AGDRz",
      "title": "Fix problems with server handover",
      "url": "https://github.com/quicwg/load-balancers/pull/203",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fix #189 ",
      "createdAt": "2022-10-03T23:49:46Z",
      "updatedAt": "2022-10-05T16:54:04Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "ebebe0598e13ed075444af33e0b12fc536b6323f",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "handover",
      "headRefOid": "d5d7cea5ae22728dee0c72ae98e4f17c88a81779",
      "closedAt": "2022-10-05T16:54:04Z",
      "mergedAt": "2022-10-05T16:54:04Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "32592939a0400fc9e310f734ed74d7f1d917876e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD6yc5DZTJR",
          "commit": {
            "abbreviatedOid": "d5d7cea"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-04T23:03:32Z",
          "updatedAt": "2022-10-04T23:03:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 204,
      "id": "PR_kwDODoD6yc5AGJQo",
      "title": "Randomness",
      "url": "https://github.com/quicwg/load-balancers/pull/204",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #192 ",
      "createdAt": "2022-10-04T00:26:39Z",
      "updatedAt": "2022-10-05T20:05:02Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "ebebe0598e13ed075444af33e0b12fc536b6323f",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "randomness",
      "headRefOid": "676ece412b5cca191921ba6bb593f788edba8ffa",
      "closedAt": "2022-10-05T20:05:02Z",
      "mergedAt": "2022-10-05T20:05:01Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "caa7446939cc1330e21c1dc15f549718171a3d6e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD6yc5DZtHz",
          "commit": {
            "abbreviatedOid": "63d26b2"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-05T02:13:19Z",
          "updatedAt": "2022-10-05T02:13:34Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "```suggestion\r\nconnection (i.e., the bytes can be chosen at random).\r\n```",
              "createdAt": "2022-10-05T02:13:20Z",
              "updatedAt": "2022-10-05T02:13:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc5DeKmj",
          "commit": {
            "abbreviatedOid": "4043573"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-05T20:04:03Z",
          "updatedAt": "2022-10-05T20:04:04Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "```suggestion\r\nconnection (e.g., the bytes can be chosen at random).\r\n```",
              "createdAt": "2022-10-05T20:04:03Z",
              "updatedAt": "2022-10-05T20:04:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 205,
      "id": "PR_kwDODoD6yc5AGLAT",
      "title": "Add reference for AES-ECB",
      "url": "https://github.com/quicwg/load-balancers/pull/205",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #195",
      "createdAt": "2022-10-04T00:36:25Z",
      "updatedAt": "2022-10-05T20:09:04Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "ebebe0598e13ed075444af33e0b12fc536b6323f",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "nist-ref",
      "headRefOid": "4c83088a5139eab2ac3d354439728769ed1c79d2",
      "closedAt": "2022-10-05T20:09:04Z",
      "mergedAt": "2022-10-05T20:09:04Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "92a82149b8cf390ef7787768f3ffd125b696ddd0"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 206,
      "id": "PR_kwDODoD6yc5AGMmD",
      "title": "Define reasonable",
      "url": "https://github.com/quicwg/load-balancers/pull/206",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #199",
      "createdAt": "2022-10-04T00:45:58Z",
      "updatedAt": "2022-10-18T20:10:23Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "aaf10af843e192c396fe51a6476d3119e33a54f6",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "what-is-reasonable",
      "headRefOid": "93f81fac92384b3567e660a2fe3cdfe5959ad477",
      "closedAt": "2022-10-18T20:10:22Z",
      "mergedAt": "2022-10-18T20:10:22Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "3a679bab69a019510d96a92934ac5c74fc581869"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD6yc5DZy6e",
          "commit": {
            "abbreviatedOid": "850b5a9"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-05T03:00:32Z",
          "updatedAt": "2022-10-05T03:00:39Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "These algorithms ensure that two connection IDs for the same connection cannot be identified as such as long as the server chooses the first octet and any plaintext nonce correctly. (without defining what correctly is here, instead relying on other definitions)",
              "createdAt": "2022-10-05T03:00:32Z",
              "updatedAt": "2022-10-05T03:00:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc5DdUq9",
          "commit": {
            "abbreviatedOid": "850b5a9"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-05T16:59:06Z",
          "updatedAt": "2022-10-05T16:59:09Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "So you want to use this text instead, basically replacing the word \"reasonable\" with \"correct\"?",
              "createdAt": "2022-10-05T16:59:06Z",
              "updatedAt": "2022-10-05T16:59:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 207,
      "id": "PR_kwDODoD6yc5AGO4h",
      "title": "Avoid changing RFC9000 notation",
      "url": "https://github.com/quicwg/load-balancers/pull/207",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixing #179.\r\n\r\nI love deleting this much text!",
      "createdAt": "2022-10-04T01:04:15Z",
      "updatedAt": "2022-10-05T16:46:49Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "a9cd3b3112d5ebaca38f5b7a99991c300ab6716a",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "simplify-notation",
      "headRefOid": "a63cc5d1d8d83f2ad3e06f78e9b87b705687086f",
      "closedAt": "2022-10-05T16:46:48Z",
      "mergedAt": "2022-10-05T16:46:48Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "218169131b0874a83687b91083ac89e473f1a117"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD6yc5DT3gQ",
          "commit": {
            "abbreviatedOid": "a63cc5d"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good",
          "createdAt": "2022-10-04T04:25:19Z",
          "updatedAt": "2022-10-04T04:25:19Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODoD6yc5DaGJz",
          "commit": {
            "abbreviatedOid": "a63cc5d"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-05T05:52:21Z",
          "updatedAt": "2022-10-05T05:52:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 208,
      "id": "PR_kwDODoD6yc5BPCnA",
      "title": "Revised 4-pass algorithm, clearer explanation",
      "url": "https://github.com/quicwg/load-balancers/pull/208",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Attempt to fix #196, #197, #200.\r\n\r\nExamples and test vectors not yet updated. PTAL at the description.\r\n\r\n- Is the algorithm accurately described\r\n- Are things clearer or not",
      "createdAt": "2022-10-20T22:00:55Z",
      "updatedAt": "2022-10-24T17:15:52Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "3a679bab69a019510d96a92934ac5c74fc581869",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "new-4pass",
      "headRefOid": "62552a2e650c11b8e27eaf08c0c6218891e9c0f2",
      "closedAt": "2022-10-24T17:15:51Z",
      "mergedAt": "2022-10-24T17:15:51Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "4457a8327e1948105a4a7c606fbec2bd7edb7fc0"
      },
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson Thanks for all the formatting suggestions. It's cleaned up a bit, although I wasn't able to get aasvg to work. PTAL",
          "createdAt": "2022-10-21T19:33:23Z",
          "updatedAt": "2022-10-21T19:33:23Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Correction. I got aasvg to work but it did not look good at all, probably due to user incompetence. If you would like to submit a PR after this that is prettier, I would welcome it.",
          "createdAt": "2022-10-21T19:57:36Z",
          "updatedAt": "2022-10-21T19:57:36Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODoD6yc5EjSz5",
          "commit": {
            "abbreviatedOid": "da6cab1"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Yes, the new text seems clear, and correct.",
          "createdAt": "2022-10-20T22:55:27Z",
          "updatedAt": "2022-10-20T22:55:27Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODoD6yc5EjbBO",
          "commit": {
            "abbreviatedOid": "da6cab1"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Much clearer, thanks.\r\n\r\nI am concerned that you aren't being very clear about whether you are logically treating the intermediate values as bitstrings or integers and that could end up being confusing.  If not now, when people start implementing this and talking to each other about it.",
          "createdAt": "2022-10-20T23:48:10Z",
          "updatedAt": "2022-10-21T00:06:05Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "```suggestion\r\n```aasvg\r\n```\r\n\r\nGive it a try.  You'll need to add a package.json file though (`npm i -s aasvg;git add package.json`) and update `.gitignore` (to add `/node_modules/` and `/package-lock.json`), but the picture will be prettier.",
              "createdAt": "2022-10-20T23:48:10Z",
              "updatedAt": "2022-10-21T00:06:05Z"
            },
            {
              "originalPosition": 82,
              "body": "Is this picture too long?  It's pretty, but I worry that it will overflow a page in the paginated format a lot of people seem determined to preserve.\r\n\r\nYou might be able to save space by removing the left_2/right_1 boxes and instead add those as labels on a line.  You can do an XOR on a single line by drawing it as `(+)` or maybe even a single `\u2295` (the latter being more likely to make aasvg do the right thing).\r\n\r\nI say that, but then note that \"Encrypt\" should probably be a box is it is an operation.",
              "createdAt": "2022-10-20T23:49:28Z",
              "updatedAt": "2022-10-21T00:06:05Z"
            },
            {
              "originalPosition": 94,
              "body": "```suggestion\r\nforms the most significant octet of the output. The 'length' argument MUST NOT exceed 28. The\r\n```\r\n\r\nHard to follow here.  Consider using paragraphs.  That might mean using subsections too.  Though I note that you are already at h4, which is already too deep for me generally.  h4 doesn't usually appear in a table of contents, which makes it harder to find the content.",
              "createdAt": "2022-10-20T23:55:48Z",
              "updatedAt": "2022-10-21T00:06:05Z"
            },
            {
              "originalPosition": 93,
              "body": "Is this length in bits or bytes?",
              "createdAt": "2022-10-20T23:57:20Z",
              "updatedAt": "2022-10-21T00:06:05Z"
            },
            {
              "originalPosition": 112,
              "body": "I think that you mean bits again here.\r\n\r\nWhich leads me to be concerned about your choice of presentation here.  Hex is a fine way to present octets, but when your output in the example is in bits you risk confusion because you are relying on the length of the hex string to indicate length.\r\n\r\nAlso, as you are effectively requesting a bit string, presenting that as a number is a little dubious.  Is this really a number?  (That is, does the caller need to remember how many bits they asked for?  I wouldn't tolerate that if this were in software: I would insist that the return value carry the number of bits, either encoded in its type or as a separate field.)",
              "createdAt": "2022-10-20T23:58:04Z",
              "updatedAt": "2022-10-21T00:06:05Z"
            },
            {
              "originalPosition": 155,
              "body": "Assigning `truncate(AES_ECB(key, expand(plaintext_len, 1, left_0))` to an intermediate variable might make this fit line lengths easier.  If you don't, then this is poorly aligned with the line above.\r\n\r\nThis (and the later ones) appear to be missing a closing paren",
              "createdAt": "2022-10-21T00:01:57Z",
              "updatedAt": "2022-10-21T00:06:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc5EoWHQ",
          "commit": {
            "abbreviatedOid": "da6cab1"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-21T19:00:39Z",
          "updatedAt": "2022-10-21T19:00:39Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "I typed these commands but when I type 'aasvg' it says \"command not found\"",
              "createdAt": "2022-10-21T19:00:39Z",
              "updatedAt": "2022-10-21T19:00:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc5EoXoL",
          "commit": {
            "abbreviatedOid": "da6cab1"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-21T19:06:14Z",
          "updatedAt": "2022-10-21T19:06:14Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "OK, with these suggestions I was able to make a smaller diagram. Thanks!",
              "createdAt": "2022-10-21T19:06:14Z",
              "updatedAt": "2022-10-21T19:06:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc5EoZ5a",
          "commit": {
            "abbreviatedOid": "da6cab1"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-21T19:12:45Z",
          "updatedAt": "2022-10-21T19:12:45Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "Nope, I changed it from bits to octets and forgot to update there. Fixed now.\r\n\r\nGood point about integers vs strings -- I got rid of the 'most significant' language with respect to octets.",
              "createdAt": "2022-10-21T19:12:45Z",
              "updatedAt": "2022-10-21T19:12:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc5EsFKS",
          "commit": {
            "abbreviatedOid": "da6cab1"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-24T00:07:51Z",
          "updatedAt": "2022-10-24T00:07:52Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "You won't be able to run aasvg directly if you install it that way.  But the makefile should download it (assuming you have npm installed, that is) and run it for you.",
              "createdAt": "2022-10-24T00:07:51Z",
              "updatedAt": "2022-10-24T00:07:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc5EsJ1k",
          "commit": {
            "abbreviatedOid": "7e46900"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-24T01:09:35Z",
          "updatedAt": "2022-10-24T01:09:36Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "```suggestion\r\n~~~ aasvg\r\n   +-----+-----------+-----------------------+\r\n   | FO  | Server ID |         Nonce         |\r\n   +--+--+-----------+-----+-----------------+\r\n      |                    |\r\n      |                    V\r\n      |  +-----------------+-----------------+\r\n      |  |      left_0     |      right_0    |\r\n      |  +--+--------------+--------------+--+\r\n      |     |                             |\r\n      |     |                             |\r\n      |     |         .--------.          V\r\n      |     +-------->| AES-ECB +-------->\u2295\r\n      |     |         '--------'          |\r\n      |     V             .--------.      | right_1\r\n      |     \u2295<-----------+ AES-ECB |<-----+\r\n      |     |             '--------'      |\r\n      |     | left_1  .--------.          V\r\n      |     +-------->| AES-ECB +-------->\u2295\r\n      |     |         '--------'          |\r\n      |     V             .--------.      |\r\n      |     \u2295<-----------+ AES-ECB |<-----+\r\n      |     |             '--------'      |\r\n      |     |                             |\r\n      |     V                             V\r\n      |  +-----------------+-----------------+\r\n      |  |      left_2     |      right_2    |\r\n      |  +-------+---------+--------+--------+\r\n      |          |                  |\r\n      V          V                  V\r\n   +-----+-----------------------------------+\r\n   | FO  |            Ciphertext             |\r\n   +-----+-----------------------------------+\r\n```\r\n\r\nThis looks something like this:\r\n\r\n![image](https://user-images.githubusercontent.com/67641/197428830-b24c676a-ae63-428c-a300-d46defa4b4cf.png)\r\n\r\nThough you might need to update `aasvg` as the XOR character wasn't supported property before today.\r\n",
              "createdAt": "2022-10-24T01:09:35Z",
              "updatedAt": "2022-10-24T01:10:17Z"
            }
          ]
        }
      ]
    },
    {
      "number": 210,
      "id": "PR_kwDODoD6yc5BUWj1",
      "title": "improve multithreading design",
      "url": "https://github.com/quicwg/load-balancers/pull/210",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #209 \r\n\r\nPlease check that this is clearly written.",
      "createdAt": "2022-10-21T22:57:39Z",
      "updatedAt": "2022-10-24T17:25:29Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "3a679bab69a019510d96a92934ac5c74fc581869",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "keyed-hash",
      "headRefOid": "73cb3b0f488a265cc5fddb9895af7059a1bca36f",
      "closedAt": "2022-10-24T17:25:27Z",
      "mergedAt": "2022-10-24T17:25:27Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "5e288e56516386be5dad363a4b6adc72520b00d5"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 212,
      "id": "PR_kwDODoD6yc5Bd40O",
      "title": "You don't need circleci",
      "url": "https://github.com/quicwg/load-balancers/pull/212",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Actions are easier",
      "createdAt": "2022-10-25T04:27:20Z",
      "updatedAt": "2022-10-26T17:49:56Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "0f16e477cdcca9bc67c5821b0fe32d1a3bd0967b",
      "headRepository": "martinthomson/quic-lb",
      "headRefName": "patch-1",
      "headRefOid": "87d4c6f721761b72e2a24bd819006356930750d1",
      "closedAt": "2022-10-26T17:49:56Z",
      "mergedAt": "2022-10-26T17:49:56Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "c003bef883f2176c472c8fca092e96da811b0b6a"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 213,
      "id": "PR_kwDODoD6yc5Bd4-9",
      "title": "Close picture",
      "url": "https://github.com/quicwg/load-balancers/pull/213",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This was not properly terminated.",
      "createdAt": "2022-10-25T04:28:30Z",
      "updatedAt": "2022-10-26T17:49:40Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "0f16e477cdcca9bc67c5821b0fe32d1a3bd0967b",
      "headRepository": "martinthomson/quic-lb",
      "headRefName": "patch-2",
      "headRefOid": "f15c9e8f08062e3f38f0f9fd0707a19de752d97f",
      "closedAt": "2022-10-26T17:49:40Z",
      "mergedAt": "2022-10-26T17:49:40Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "8269d6fb864606655654bc2ef038fd5bf82c88dc"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 214,
      "id": "PR_kwDODoD6yc5DLPVg",
      "title": "Bump the aasvg dependency to get the XOR fix",
      "url": "https://github.com/quicwg/load-balancers/pull/214",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "It's possible that the version on gh-pages is stuck because I cache dependencies.  That's ordinarily good, but when you need a bugfix...",
      "createdAt": "2022-11-18T05:36:37Z",
      "updatedAt": "2023-04-21T17:47:56Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "c003bef883f2176c472c8fca092e96da811b0b6a",
      "headRepository": "martinthomson/quic-lb",
      "headRefName": "aasvg-bump",
      "headRefOid": "fdfd5392f6b2cd61385bf7397c6966bc7ac73cd0",
      "closedAt": "2023-04-21T17:47:56Z",
      "mergedAt": "2023-04-21T17:47:56Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "00b9841773638646e6fe1af140a5a50ab0611fd5"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 216,
      "id": "PR_kwDODoD6yc5Vj4Gu",
      "title": "Three config rotation bits",
      "url": "https://github.com/quicwg/load-balancers/pull/216",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #215 ",
      "createdAt": "2023-07-14T21:50:59Z",
      "updatedAt": "2023-08-02T20:15:53Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "86ff32da5ae7b28df61af13baaea763eedb6dba5",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "three-bits",
      "headRefOid": "4fef60a6f886253e406267df52509353ffacd3a1",
      "closedAt": "2023-08-02T20:15:52Z",
      "mergedAt": "2023-08-02T20:15:52Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "dc597ebffa2ba816f3ed9a4f5c8c0fcd022ee29a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD6yc5cJxiv",
          "commit": {
            "abbreviatedOid": "4fef60a"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2023-07-25T18:10:25Z",
          "updatedAt": "2023-07-25T18:10:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 217,
      "id": "PR_kwDODoD6yc5YF6m-",
      "title": "Fix some references to 2-bit config ID",
      "url": "https://github.com/quicwg/load-balancers/pull/217",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-08-16T19:03:12Z",
      "updatedAt": "2023-09-28T20:11:01Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "dc597ebffa2ba816f3ed9a4f5c8c0fcd022ee29a",
      "headRepository": "martinduke/load-balancers",
      "headRefName": "missed-a-few",
      "headRefOid": "aac44a5ce9ab63d677575422c111c7b61139e71d",
      "closedAt": "2023-09-28T19:57:29Z",
      "mergedAt": "2023-09-28T19:57:29Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "642fe800f69e7480b92296935cb8c182f92e8b0d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 218,
      "id": "PR_kwDODoD6yc5beuFZ",
      "title": "Add Andy Sykes",
      "url": "https://github.com/quicwg/load-balancers/pull/218",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-09-28T19:59:02Z",
      "updatedAt": "2023-09-28T20:10:59Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "642fe800f69e7480b92296935cb8c182f92e8b0d",
      "headRepository": "martinduke/load-balancers",
      "headRefName": "add-andy",
      "headRefOid": "f3b095915bdd7f187b5d830d419965e01c63c0c5",
      "closedAt": "2023-09-28T19:59:21Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 219,
      "id": "PR_kwDODoD6yc5bexpG",
      "title": "Add Andy Sykes",
      "url": "https://github.com/quicwg/load-balancers/pull/219",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-09-28T20:11:51Z",
      "updatedAt": "2023-09-28T20:12:00Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "642fe800f69e7480b92296935cb8c182f92e8b0d",
      "headRepository": "martinduke/load-balancers",
      "headRefName": "add-andy",
      "headRefOid": "53c84c246d353bb7c722cdcc41b655779ad31398",
      "closedAt": "2023-09-28T20:11:59Z",
      "mergedAt": "2023-09-28T20:11:59Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "58019b0f0344b5e5f4acb5a80fc38b1d7e14bd4f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 220,
      "id": "PR_kwDODoD6yc5be3KK",
      "title": "restore config.yml",
      "url": "https://github.com/quicwg/load-balancers/pull/220",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-09-28T20:28:39Z",
      "updatedAt": "2024-01-19T18:07:21Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "58019b0f0344b5e5f4acb5a80fc38b1d7e14bd4f",
      "headRepository": "martinduke/load-balancers",
      "headRefName": "add-andy",
      "headRefOid": "24b81971aba2d9e1f0648a29b7b94136648d4620",
      "closedAt": "2023-09-28T20:28:48Z",
      "mergedAt": "2023-09-28T20:28:48Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "eeb517c00b8f0edd138766f5bebfc2631dd0456f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 223,
      "id": "PR_kwDODoD6yc5kkrAn",
      "title": "Fix regressions",
      "url": "https://github.com/quicwg/load-balancers/pull/223",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #221 ",
      "createdAt": "2024-01-19T18:01:41Z",
      "updatedAt": "2024-01-19T18:02:07Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "eeb517c00b8f0edd138766f5bebfc2631dd0456f",
      "headRepository": "martinduke/load-balancers",
      "headRefName": "main",
      "headRefOid": "813527df6758df513d02e485302f2799f5877d8b",
      "closedAt": "2024-01-19T18:02:07Z",
      "mergedAt": "2024-01-19T18:02:07Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "e830f57a70481fada838d98522077b17615d5eb8"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 224,
      "id": "PR_kwDODoD6yc5kl8nj",
      "title": "Rearrange expand()",
      "url": "https://github.com/quicwg/load-balancers/pull/224",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "by moving the arbitrary location of some bytes around, we can eliminate a copy and improve performance on 3-pass decryption by about 7%.\r\n\r\nI would very much appreciate someone verifying my test vectors.\r\n\r\nFixes #222",
      "createdAt": "2024-01-19T21:24:35Z",
      "updatedAt": "2025-02-11T18:02:21Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "e830f57a70481fada838d98522077b17615d5eb8",
      "headRepository": "martinduke/load-balancers",
      "headRefName": "rearrange-expand",
      "headRefOid": "77062f3b8265fa72e868107cdacde6871ea484ca",
      "closedAt": "2024-02-05T20:30:31Z",
      "mergedAt": "2024-02-05T20:30:31Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "84fd79e6571401689b4cd4af01ca26739abe3bab"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD6yc5uv_Hw",
          "commit": {
            "abbreviatedOid": "f150581"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Yes, I see how this new syntax leads to simpler code. But the text could be improved, see suggestion.",
          "createdAt": "2024-02-02T01:23:52Z",
          "updatedAt": "2024-02-02T01:24:46Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "This appears to be half an edit. The syntax as you express it appears to be:\r\n~~~\r\nExpandResult {\r\n      Bytes(...),\r\n      ZeroPad(...),\r\n      length(8),\r\n      pass(8)\r\n}\r\n~~~\r\n\r\nIn which:\r\n\r\n* 'Bytes' are the N most significant octets of the output. The number N is half the 'length', rounded up, thus a number between 1 and 14.\r\n* 'Zeropad' is a set of 14-N zeroes,\r\n* 'length' is an 8-bit integer that reports the sum of the configured nonce length and server id length in octets, and forms the fifteenth octet of the output. The 'length' argument MUST NOT exceed 28.\r\n* 'pass' is an 8-bit integer that reports the 'pass' argument of the algorithm, and\r\nforms the sixteenth (least significant) octet of the output.\r\n     \r\n      ",
              "createdAt": "2024-02-02T01:23:53Z",
              "updatedAt": "2024-02-02T01:24:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc5u5Axs",
          "commit": {
            "abbreviatedOid": "f150581"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-02T21:45:29Z",
          "updatedAt": "2024-02-02T21:45:29Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "OK, I took this working, minus some corrections. Length has to be between 5 and 19, meaning N is between 3 and 10.",
              "createdAt": "2024-02-02T21:45:29Z",
              "updatedAt": "2024-02-02T21:45:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc5u7YU1",
          "commit": {
            "abbreviatedOid": "a724713"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-03T16:12:09Z",
          "updatedAt": "2024-02-03T16:12:09Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Typo.",
              "createdAt": "2024-02-03T16:12:09Z",
              "updatedAt": "2024-02-03T16:12:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc5u7YYb",
          "commit": {
            "abbreviatedOid": "a724713"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-03T16:13:54Z",
          "updatedAt": "2024-02-03T16:13:54Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Reading again, I would write \"a set of 14-N octets set to zero.\"",
              "createdAt": "2024-02-03T16:13:54Z",
              "updatedAt": "2024-02-03T16:13:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc5vFpET",
          "commit": {
            "abbreviatedOid": "77062f3"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good now.",
          "createdAt": "2024-02-05T20:22:28Z",
          "updatedAt": "2024-02-05T20:22:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 226,
      "id": "PR_kwDODoD6yc5p1Z-l",
      "title": "fixed encryption example",
      "url": "https://github.com/quicwg/load-balancers/pull/226",
      "state": "MERGED",
      "author": "nandsky",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There is an error in the [encryption example](https://github.com/quicwg/load-balancers/blob/84fd79e6571401689b4cd4af01ca26739abe3bab/draft-ietf-quic-load-balancers.md?plain=1#L637) .\r\n\r\n> // step 4\r\n> right_1 = 0x0c69c275 ^ 0xa255dd8c = 0xae**3c**1ff9\r\n>\r\n> // step 5 (clear bits)\r\n> right_1 = 0x0e**8c**1ff9\r\n> \r\n> // step 6\r\n> aes_input = 0x0e**8c**1ff9000000000000000000000702\r\n> aes_output = 0xe5e452cb9e1bedb0b2bf830506bf4c4e\r\n\r\nTest as follows:\r\n\r\n``` python\r\n#!/usr/bin/env python\r\n\r\nfrom Crypto.Cipher import AES\r\nimport binascii\r\n\r\nkey = binascii.unhexlify('fdf726a9893ec05c0632d3956680baf0')\r\ncipher = AES.new(key, AES.MODE_ECB)\r\n\r\ndef encrypt(plaintext):\r\n        ciphertext = cipher.encrypt(plaintext)\r\n        hex_str = binascii.b2a_hex(ciphertext)\r\n        print(\"plaintext: \", binascii.b2a_hex(plaintext), \" -> ciphertext: \", hex_str)\r\n\r\nplaintext1 = binascii.unhexlify('0e8c1ff9000000000000000000000702')\r\nplaintext2 = binascii.unhexlify('0e3c1ff9000000000000000000000702')\r\n\r\nencrypt(plaintext1)\r\nencrypt(plaintext2)\r\n```\r\n\r\n```shell\r\n$python ~/test.py\r\n('plaintext: ', '0e8c1ff9000000000000000000000702', ' -> ciphertext: ', '6e9883364a602f96aac381ecfeaff13f')\r\n('plaintext: ', '0e3c1ff9000000000000000000000702', ' -> ciphertext: ', 'e5e452cb9e1bedb0b2bf830506bf4c4e')\r\n```",
      "createdAt": "2024-03-16T17:50:57Z",
      "updatedAt": "2024-03-26T18:13:00Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "84fd79e6571401689b4cd4af01ca26739abe3bab",
      "headRepository": "nandsky/load-balancers",
      "headRefName": "encryption_example",
      "headRefOid": "d0fa1b12f4f095815d17988a26d7398450e2089c",
      "closedAt": "2024-03-26T18:12:59Z",
      "mergedAt": "2024-03-26T18:12:59Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "12b10309682dd06edc4a18912cb27ab7a8f8b9f7"
      },
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for catching this!",
          "createdAt": "2024-03-26T18:12:56Z",
          "updatedAt": "2024-03-26T18:12:56Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 228,
      "id": "PR_kwDODoD6yc5q1Nt8",
      "title": "Rest of example fix",
      "url": "https://github.com/quicwg/load-balancers/pull/228",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Rest of fix for #227",
      "createdAt": "2024-03-26T18:19:56Z",
      "updatedAt": "2025-02-11T18:02:23Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "12b10309682dd06edc4a18912cb27ab7a8f8b9f7",
      "headRepository": "martinduke/load-balancers",
      "headRefName": "error",
      "headRefOid": "fa750188a575407b34f93801357b6a43b46330da",
      "closedAt": "2024-03-26T18:20:46Z",
      "mergedAt": "2024-03-26T18:20:46Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "cd03bab419f180a3d287aec85b82ce03ef24d471"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 232,
      "id": "PR_kwDODoD6yc6K2V6N",
      "title": "Considerations for Server Processes/Threads",
      "url": "https://github.com/quicwg/load-balancers/pull/232",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #231 ",
      "createdAt": "2025-02-11T18:57:13Z",
      "updatedAt": "2025-02-28T22:07:17Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "cd03bab419f180a3d287aec85b82ce03ef24d471",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "threads",
      "headRefOid": "9985dafb271a955f297bae7261caab3eb4f40686",
      "closedAt": "2025-02-28T22:07:16Z",
      "mergedAt": "2025-02-28T22:07:16Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "d811e9e4e8ab22acf468227f74770562816283d3"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 233,
      "id": "PR_kwDODoD6yc6K2YJg",
      "title": "Expand DCID, update reference to config ID",
      "url": "https://github.com/quicwg/load-balancers/pull/233",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #229 ",
      "createdAt": "2025-02-11T19:00:55Z",
      "updatedAt": "2025-02-28T22:06:58Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "0b9374ddb2179db19742f38a5702a9e6278b0a44",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "definition",
      "headRefOid": "1a1734e13de9329dc08a0a213aae9cc485d61c23",
      "closedAt": "2025-02-28T22:06:57Z",
      "mergedAt": "2025-02-28T22:06:57Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "74ea168a3e68d1386d200d4b045e493c00fde1d6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD6yc6bvwgW",
          "commit": {
            "abbreviatedOid": "7954330"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-02-12T19:25:14Z",
          "updatedAt": "2025-02-12T19:25:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 234,
      "id": "PR_kwDODoD6yc6K_rWc",
      "title": "Clarified fallback algorithm rules for known versions",
      "url": "https://github.com/quicwg/load-balancers/pull/234",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #230",
      "createdAt": "2025-02-12T17:44:47Z",
      "updatedAt": "2025-02-28T22:03:42Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "cd03bab419f180a3d287aec85b82ce03ef24d471",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "unroutable",
      "headRefOid": "787a9f6b1dbbf036e31f353a1ad85232f6a0c4ec",
      "closedAt": "2025-02-28T22:03:41Z",
      "mergedAt": "2025-02-28T22:03:41Z",
      "mergedBy": "martinduke",
      "mergeCommit": {
        "oid": "0b9374ddb2179db19742f38a5702a9e6278b0a44"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD6yc6bvyFM",
          "commit": {
            "abbreviatedOid": "787a9f6"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-02-12T19:28:01Z",
          "updatedAt": "2025-02-12T19:28:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 236,
      "id": "PR_kwDODoD6yc6NAQqm",
      "title": "Make fallback algorithm airtight",
      "url": "https://github.com/quicwg/load-balancers/pull/236",
      "state": "OPEN",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #235",
      "createdAt": "2025-03-01T01:40:23Z",
      "updatedAt": "2025-03-05T22:58:37Z",
      "baseRepository": "quicwg/load-balancers",
      "baseRefName": "main",
      "baseRefOid": "d811e9e4e8ab22acf468227f74770562816283d3",
      "headRepository": "quicwg/load-balancers",
      "headRefName": "fix-unroutable",
      "headRefOid": "63722d1415dc483844db801d99856cb48df96fcd",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I think we need at a minimum an editorial pass of the \"fallback algorithms\".\r\n\r\nThe overall theme of my reply is that you have missed the overall context of these changes, which are to improve the case when the server has no config and is sending 0b111 CIDs. In this case, the entire life of the connection may be unroutable.\r\n\r\nSecondarily, it is cleaning up cases where the client's first flight has more than one packet, which had many holes in the logic.\r\n\r\nIf there are changes to Section 2.2 and 3 to make all this clearer, I would be happy to make them.",
          "createdAt": "2025-03-04T22:35:39Z",
          "updatedAt": "2025-03-04T22:36:30Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I did another pass to try to organize the text better and make things clearer.",
          "createdAt": "2025-03-04T23:13:46Z",
          "updatedAt": "2025-03-04T23:13:46Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Christian and I had a chat and came to some conclusions on how to present this more clearly.\r\n\r\nThe baseline fallback algorithm is 4-tuple based, with no other inputs, eliminating a lot of edge cases.\r\n\r\nIf mutual configuration is guaranteed, keep no tables. Otherwise,\r\n\r\nThe LB MAY keep a table of 4-tuple to server, which protects against the case where the server is generating Unroutable CIDs and the hash result changes down the line.\r\n\r\nThe LB MAY also keep a table of CID to server, so that it can be robust to NAT rebinding.\r\n\r\nall LBs MUST implement this in case they see an unknown version.\r\n\r\n***\r\n\r\nI don't see a compelling case for f(CID), and it introduces tons of edge cases.\r\n\r\n***\r\n\r\nThere is also an advanced case where the LB does DPI on a known version (really this is about SNI routing). This levies additional requirements:\r\n\r\n- There must be a capability to buffer packets in a flow until the LB can make a decision\r\n\r\n- Routing decisions SHOULD be stored by 4-tuple\r\n- Routing decisions MAY be stored by both source connection ID and destination CID to disambiguate multiple connections on the same 4-tuple for both long and short headers, respectively.  The SCID part is required because it is otherwise impossible to disambiguate simultaneous connections on the same 4-tuple that go to different SNIs, where the servers provide new DCIDs.\r\n\r\nI'll rewrite again.\r\n",
          "createdAt": "2025-03-05T21:37:23Z",
          "updatedAt": "2025-03-05T21:37:23Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Whew! Thanks to @huitema, I've simplified the text a lot by reducing the degrees of freedom. @ggreenway PTAL.",
          "createdAt": "2025-03-05T22:56:31Z",
          "updatedAt": "2025-03-05T22:56:31Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODoD6yc6ePnwm",
          "commit": {
            "abbreviatedOid": "2413b6f"
          },
          "author": "ggreenway",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Overall looks great, and much clearer!",
          "createdAt": "2025-03-03T18:18:48Z",
          "updatedAt": "2025-03-03T19:35:08Z",
          "comments": [
            {
              "originalPosition": 148,
              "body": "```suggestion\r\nalgorithm result in case changes to the server pool change fallback algorithm\r\n```",
              "createdAt": "2025-03-03T18:18:48Z",
              "updatedAt": "2025-03-03T19:35:08Z"
            },
            {
              "originalPosition": 170,
              "body": "If the fallback algorithm is hash-based instead of stateful, there is no recording.\r\n\r\n```suggestion\r\n1. Use the fallback algorithm to make a routing decision and, if applicable, record the results\r\nin the tables indexed by 4-tuple and/or DCID.\r\n```",
              "createdAt": "2025-03-03T18:32:29Z",
              "updatedAt": "2025-03-03T19:35:08Z"
            },
            {
              "originalPosition": 192,
              "body": "I think it would be helpful to state here what they MUST do (use fallback to route the packet)",
              "createdAt": "2025-03-03T18:34:51Z",
              "updatedAt": "2025-03-03T19:35:08Z"
            },
            {
              "originalPosition": 195,
              "body": "a \"for example\" of the colocated function would be useful. I'm assuming you mean something like security, rate limiting, or similar.",
              "createdAt": "2025-03-03T18:35:53Z",
              "updatedAt": "2025-03-03T19:35:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc6eR3TR",
          "commit": {
            "abbreviatedOid": "abc0cbc"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-03T22:19:10Z",
          "updatedAt": "2025-03-03T22:19:10Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "As stated a few paragraphs above, there is never a case where the table has no value. If the hash includes the DCID, the server could change the DCID.\r\n\r\nEven if fully 4-tuple based, if the server pool changes, the a 4-tuple hash could give you a different result.\r\n\r\nHowever, \"if applicable\" is a reasonable thing to add.",
              "createdAt": "2025-03-03T22:19:10Z",
              "updatedAt": "2025-03-03T22:19:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc6eR5xK",
          "commit": {
            "abbreviatedOid": "d9c5c41"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-03T22:26:09Z",
          "updatedAt": "2025-03-03T22:26:09Z",
          "comments": [
            {
              "originalPosition": 192,
              "body": "Welp, this language is broken now that 0b111 is Unroutable and server-generated.",
              "createdAt": "2025-03-03T22:26:09Z",
              "updatedAt": "2025-03-03T22:26:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc6eSDZ5",
          "commit": {
            "abbreviatedOid": "2413b6f"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-03T22:55:36Z",
          "updatedAt": "2025-03-03T22:55:36Z",
          "comments": [
            {
              "originalPosition": 192,
              "body": "I am thinking about eliminating all the language about dropping packets. It seems to have a very narrow application and is easy to circumvent if an attacker is really trying to launch a DoS (just send a mass of Initial packets with different unroutable CIDs).\r\n\r\nThis would also simplify the version-invariance considerations further down. WDYT?",
              "createdAt": "2025-03-03T22:55:36Z",
              "updatedAt": "2025-03-03T22:55:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc6eTWPJ",
          "commit": {
            "abbreviatedOid": "173a7f4"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I think we need at a minimum an editorial pass of the \"fallback algorithms\".",
          "createdAt": "2025-03-04T04:04:49Z",
          "updatedAt": "2025-03-04T04:18:03Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "This a bit awkward. Start with \"additional checks are possible\" -- the dreaded passive form. I would rather say: \r\n\r\n_If the load balancer has  knowledge that all servers in the pool are encoding CID\r\n length in the first octet (see {{length-self-description}}), it MAY perform additional\r\n checks based on that self-encoded length:_\r\n\r\nThen, the following tests should be written in the positive way:\r\n\r\n\r\n_* In a long header, verify that the self-encoded length is consistent with the CID length,_\r\n_* Verify that the self-encoded length is consistent with the QUIC version,_\r\n_* Verify that the self-encoded length is large enough for the decoder to process using the indicated config ID._\r\n\r\n_DCIDs that do not meet these criteria are not routable._\r\n\r\nI have an additional question regarding the version check. Is this something to be done only for long headers, which include the version number, or for all packets? If for all packets, how does the LB knows the negotiated version number?\r\n\r\n\r\n\r\n",
              "createdAt": "2025-03-04T04:04:49Z",
              "updatedAt": "2025-03-04T04:18:03Z"
            },
            {
              "originalPosition": 127,
              "body": "What about Post-Quantum? Do you mean, buffer the initial packets until the SNI can be retrieved from the Client Hello contained in the Crypto frames\"? What if the SNI straddles multiple QUIC packets? What if ECH is used? ",
              "createdAt": "2025-03-04T04:04:53Z",
              "updatedAt": "2025-03-04T04:18:03Z"
            },
            {
              "originalPosition": 138,
              "body": "Sure. But if the server changes the CID, isn't it expected to pick a routable CID?",
              "createdAt": "2025-03-04T04:05:41Z",
              "updatedAt": "2025-03-04T04:18:03Z"
            },
            {
              "originalPosition": 146,
              "body": "Do LBs need to worry about RSS in TLS? Or about stateless Retry?",
              "createdAt": "2025-03-04T04:06:48Z",
              "updatedAt": "2025-03-04T04:18:03Z"
            },
            {
              "originalPosition": 150,
              "body": "I am not an LB implementer, but aren't you describing some kind of race condition? Once the server has received the first flight, it will provide its source CID to the client. The next packets from the client will use that as a DCID, and it will be routable.",
              "createdAt": "2025-03-04T04:09:36Z",
              "updatedAt": "2025-03-04T04:18:03Z"
            },
            {
              "originalPosition": 156,
              "body": "We seem to be dancing around the issue. First, NAT rebinding *during the client's first fly\" ought to be fairly rare -- rare enough to be treated as an error case. Second, resilience to NAT rebinding requires routing based on DCID, instead of the 4 tuple. Why not just say that if a server uses unroutable CIDs, then NAT rebinding is not supported? And maybe tell servers that use unroutable CIDs to set the TP \"disable_active_migration=TRUE\" ?",
              "createdAt": "2025-03-04T04:15:09Z",
              "updatedAt": "2025-03-04T04:18:03Z"
            },
            {
              "originalPosition": 171,
              "body": "Yes. Note that it is much easier to discuss Fallback Algorithms *after* we have defined the default behavior. Consider changing the order of these sections.",
              "createdAt": "2025-03-04T04:16:56Z",
              "updatedAt": "2025-03-04T04:18:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc6egDDg",
          "commit": {
            "abbreviatedOid": "173a7f4"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-04T22:15:54Z",
          "updatedAt": "2025-03-04T22:15:54Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "Done.\r\n\r\nI extended your second bullet to say \"consistent with the QUIC versions, if known.\" I would expect this check for long headers; for short headers, it might keep state.",
              "createdAt": "2025-03-04T22:15:54Z",
              "updatedAt": "2025-03-04T22:15:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc6egHah",
          "commit": {
            "abbreviatedOid": "173a7f4"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-04T22:21:55Z",
          "updatedAt": "2025-03-04T22:21:55Z",
          "comments": [
            {
              "originalPosition": 127,
              "body": "I think that's what this is saying, right? \"SNI field, which might appear in one of several... packets\". Is there another wording you would suggest/\r\n\r\nAs for ECH, it seems clear to me that the LB would have to be the \"client-facing server\" in Fig. 2 of the ESNI draft. I don't know that this draft has to get into the details of how to implement arbitrary routing strategies. WDYT?",
              "createdAt": "2025-03-04T22:21:55Z",
              "updatedAt": "2025-03-04T22:21:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc6egH7f",
          "commit": {
            "abbreviatedOid": "173a7f4"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-04T22:22:31Z",
          "updatedAt": "2025-03-04T22:22:32Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "If it doesn't have a config, it uses 0b111, which is now defined as unroutable. That's the big change in this PR.",
              "createdAt": "2025-03-04T22:22:31Z",
              "updatedAt": "2025-03-04T22:22:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc6egK4T",
          "commit": {
            "abbreviatedOid": "173a7f4"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-04T22:26:24Z",
          "updatedAt": "2025-03-04T22:26:24Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "How so? IIRC those things won't change the 4-tuple.  By either using a pure 4-tuple hash, or a table of results by 4-tuple, the LB will get consistent results over handshake timescales, unless it uses a table and the table overflows.",
              "createdAt": "2025-03-04T22:26:24Z",
              "updatedAt": "2025-03-04T22:26:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc6egLy6",
          "commit": {
            "abbreviatedOid": "173a7f4"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-04T22:27:13Z",
          "updatedAt": "2025-03-04T22:27:13Z",
          "comments": [
            {
              "originalPosition": 150,
              "body": "Again, all of this is covering the case when the server does not have a config and is using 0b111.",
              "createdAt": "2025-03-04T22:27:13Z",
              "updatedAt": "2025-03-04T22:27:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc6egO7l",
          "commit": {
            "abbreviatedOid": "173a7f4"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-04T22:31:48Z",
          "updatedAt": "2025-03-04T22:31:48Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "Whoops, the language about disable_active_migration and NEW_CONNECTION_ID fell out of the edit. I've restored it.",
              "createdAt": "2025-03-04T22:31:48Z",
              "updatedAt": "2025-03-04T22:31:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc6egxbL",
          "commit": {
            "abbreviatedOid": "2413b6f"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-04T23:12:07Z",
          "updatedAt": "2025-03-04T23:12:07Z",
          "comments": [
            {
              "originalPosition": 192,
              "body": "I filed #238 to delete all that text.",
              "createdAt": "2025-03-04T23:12:07Z",
              "updatedAt": "2025-03-04T23:12:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc6ervpK",
          "commit": {
            "abbreviatedOid": "e2baee4"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Defininetly improving!\r\n\r\nI think we should have an explanation of how we use hash buckets for mapping 4-tuples to server, and how memorizing CID improves robustness somewhat, with a special case for the transition from IDCID to server provided DCID. Maybe add a consideration that for QUIC V1, remembering CIDs found in Initial packets is futile, since we do not support NAT rebinding during the initial exchange.",
          "createdAt": "2025-03-05T19:21:57Z",
          "updatedAt": "2025-03-05T19:47:56Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "I am trying to get a picture of the underlying data model. I understand the first two steps:\r\n\r\n1. Routable CID. That one seems obvious, but there is the issue of the Initial DCID that becomes routable \"by chance\". These will be assigned to the \"decoded\" server, regardless of the source address and source port. Is that intentional?\r\n\r\n2. Unroutable CID that has been memorized in a global CID table. That seems obvious too. (Small question: when are such CID ejected from the table?)\r\n\r\n3. Unroutable CID that has been memorized in a \"per 4 tuple\" CID table. Picoquic does something like that for the Initial DCID, because it isolate the routing from collisions due to either poor DCID (e.g., everybody pick 999...999, or everybody picks 0) or deliberate attack -- attacker sends packet with copied DCID, intercepts the connection. But doing that for other DCID than the IDCID prevents handling of NAT rebinding.\r\n\r\nIt seems weird to check the global table of ICID first, and the per tuple table second. Is that what implementations do?\r\n\r\nShould we be explicit about the data model of the load balancer, and the tradeoff between robustness against poor random number generation of IDCID and support for NAT rebinding? ",
              "createdAt": "2025-03-05T19:21:57Z",
              "updatedAt": "2025-03-05T19:47:56Z"
            },
            {
              "originalPosition": 127,
              "body": "OK.",
              "createdAt": "2025-03-05T19:22:25Z",
              "updatedAt": "2025-03-05T19:47:56Z"
            },
            {
              "originalPosition": 138,
              "body": "OK.",
              "createdAt": "2025-03-05T19:22:54Z",
              "updatedAt": "2025-03-05T19:47:56Z"
            },
            {
              "originalPosition": 146,
              "body": "Stateless retry will not change the 4 tuple, but it will change the DCID. The client that receives the retry will get a new DCID suggested by the server. The response will come from that new DCID. If the server is not configured yet, that new DCID will be \"unroutable\". This new unroutable DCID will be coming from the same 4-tuple, but the hashing of four tuples to servers may change between the time the IDCID was first seen and the new DCID is first seen.\r\n\r\nRSS forces a kind of handshake between client and server. The client will switch from using the IDCID to using as DCID that the CID server used as a source CID. The same handshake will happen if the server sends an initial ACK before the client has sent all initial packets, after the client receives the first packets from the server. Same risk: if the hash table changes, the transition to the new DCID will fail.\r\n\r\nBasically, if we route per hash of 4 tuple, the routing fails when hash changes. If the LB remembers the DCID, the routing fails if both the DCID and the hash table change. Remembering the DCID in the global table improves the robustness generally, with the possible exception of the IDCID (routing of initial packets). It might be better to not insert those in any table. In case of NAT rebinding, the connection only survives if the LB remembers the DCID in the global table.\r\n\r\n",
              "createdAt": "2025-03-05T19:42:09Z",
              "updatedAt": "2025-03-05T19:47:56Z"
            },
            {
              "originalPosition": 150,
              "body": "OK.",
              "createdAt": "2025-03-05T19:42:21Z",
              "updatedAt": "2025-03-05T19:47:56Z"
            },
            {
              "originalPosition": 285,
              "body": "Typo, defintion -> definition",
              "createdAt": "2025-03-05T19:43:42Z",
              "updatedAt": "2025-03-05T19:47:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc6esP1c",
          "commit": {
            "abbreviatedOid": "173a7f4"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-05T20:20:11Z",
          "updatedAt": "2025-03-05T20:20:11Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "For stateless retry, we have to split this into the happy path, the unhappy path, and the very unhappy path, and the very very unhappy path.\r\n\r\nIn the happy path, the Retry packet provides a routable CID, and there is no problem.\r\n\r\nIn the unhappy path, there is no common configuration, so the server's CID is unroutable. The client's second attempt, it uses the same 4-tuple almost immediately, and the rest of the packet is pretty much the same. The second packet is a hit in the 4-tuple table, so it goes to the same place.\r\n\r\nIn the very unhappy path, there is no common config and the 4-tuple table is missing or overflowing (maybe reasonable in a Retry case). Pretty much everything in the second packet is the same except the DCID, so any fallback algorithm that does not use DCID should work. One that uses DCID will probably fail.\r\n\r\nIn the very very unhappy path, there is not common config, and the client delays the second attempt, long enough that there the hash result changes or there is a NAT rebinding, and/or the 4-tuple table entry times out. I would consider this edge case to be pathological behavior.\r\n\r\nIf by \"RSS\" you mean \"HRR\", I don't see that it's functionally different. The HRR will provide a new CID that has similar QUIC-LB properties.\r\n\r\nFinally, this is all presumptive of v1/v2. Many other patterns are possible.",
              "createdAt": "2025-03-05T20:20:11Z",
              "updatedAt": "2025-03-05T20:20:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD6yc6esvvi",
          "commit": {
            "abbreviatedOid": "e2baee4"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-05T21:26:13Z",
          "updatedAt": "2025-03-05T21:26:13Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "> I am trying to get a picture of the underlying data model. I understand the first two steps:\r\n> \r\n> 1. Routable CID. That one seems obvious, but there is the issue of the Initial DCID that becomes routable \"by chance\". These will be assigned to the \"decoded\" server, regardless of the source address and source port. Is that intentional?\r\n\r\nYes. This is extremely unlikely because (1) clients sending 8B CIDs is a de facto standard, and QUIC-LB will rarely come out to 8B and (2) even if so, the right thing to do is have a sparse server ID result (as described in S3.3) so that even if it decodes, the server ID is invalid.\r\n\r\n> 2. Unroutable CID that has been memorized in a global CID table. That seems obvious too. (Small question: when are such CID ejected from the table?)\r\n\r\nwe chatted offline and agreed that it would be possible for an attacker to eject people from the table if it was on a routable CID, so ejection should be timer based.\r\n\r\n> 3. Unroutable CID that has been memorized in a \"per 4 tuple\" CID table. Picoquic does something like that for the Initial DCID, because it isolate the routing from collisions due to either poor DCID (e.g., everybody pick 999...999, or everybody picks 0) or deliberate attack -- attacker sends packet with copied DCID, intercepts the connection. But doing that for other DCID than the IDCID prevents handling of NAT rebinding.\r\n> \r\n> It seems weird to check the global table of ICID first, and the per tuple table second. Is that what implementations do?\r\n\r\nThere are no implementations of this PR! As you mentioned in our discussion, it's possible to have multiple connection IDs on the same connection.\r\n\r\n> \r\n> Should we be explicit about the data model of the load balancer, and the tradeoff between robustness against poor random number generation of IDCID and support for NAT rebinding?\r\n\r\nOnline we discussed a major rewrite, which I'll summarize in another comment.\r\n\r\n",
              "createdAt": "2025-03-05T21:26:13Z",
              "updatedAt": "2025-03-05T21:26:13Z"
            }
          ]
        }
      ]
    }
  ]
}